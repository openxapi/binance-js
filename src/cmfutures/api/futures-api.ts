/* tslint:disable */
/* eslint-disable */
/**
 * Binance COIN-M Futures API
 * OpenAPI specification for Binance exchange - Cmfutures API
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CmfuturesCreateBatchOrderV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { CmfuturesCreateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CmfuturesDeleteBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CmfuturesGetContinuousKlinesV1RespInnerInner } from '../model';
// @ts-ignore
import type { CmfuturesGetExchangeInfoV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { CmfuturesUpdateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CreateCountdownCancelAllV1Resp } from '../model';
// @ts-ignore
import type { CreateLeverageV1Resp } from '../model';
// @ts-ignore
import type { CreateListenKeyV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginTypeV1Resp } from '../model';
// @ts-ignore
import type { CreateOrderV1Resp } from '../model';
// @ts-ignore
import type { CreatePositionMarginV1Resp } from '../model';
// @ts-ignore
import type { CreatePositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { DeleteAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteOrderV1Resp } from '../model';
// @ts-ignore
import type { GetAccountV1Resp } from '../model';
// @ts-ignore
import type { GetAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { GetAggTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetBalanceV1RespItem } from '../model';
// @ts-ignore
import type { GetCommissionRateV1Resp } from '../model';
// @ts-ignore
import type { GetConstituentsV1Resp } from '../model';
// @ts-ignore
import type { GetDepthV1Resp } from '../model';
// @ts-ignore
import type { GetFundingInfoV1RespItem } from '../model';
// @ts-ignore
import type { GetFundingRateV1RespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataBasisRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataGlobalLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataOpenInterestHistRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTakerBuySellVolRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTopLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTopLongShortPositionRatioRespItem } from '../model';
// @ts-ignore
import type { GetHistoricalTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetIncomeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetIncomeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetIncomeV1RespItem } from '../model';
// @ts-ignore
import type { GetLeverageBracketV1RespItem } from '../model';
// @ts-ignore
import type { GetLeverageBracketV2RespItem } from '../model';
// @ts-ignore
import type { GetOpenInterestV1Resp } from '../model';
// @ts-ignore
import type { GetOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { GetOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetOrderAsynV1Resp } from '../model';
// @ts-ignore
import type { GetOrderV1Resp } from '../model';
// @ts-ignore
import type { GetPmAccountInfoV1Resp } from '../model';
// @ts-ignore
import type { GetPositionMarginHistoryV1RespItem } from '../model';
// @ts-ignore
import type { GetPositionRiskV1RespItem } from '../model';
// @ts-ignore
import type { GetPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { GetPremiumIndexV1RespItem } from '../model';
// @ts-ignore
import type { GetTicker24hrV1RespItem } from '../model';
// @ts-ignore
import type { GetTickerBookTickerV1RespItem } from '../model';
// @ts-ignore
import type { GetTickerPriceV1RespItem } from '../model';
// @ts-ignore
import type { GetTimeV1Resp } from '../model';
// @ts-ignore
import type { GetTradeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetTradeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { UpdateOrderV1Resp } from '../model';
/**
 * FuturesApi - axios parameter creator
 * @export
 */
export const FuturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1: async (batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {number} countdownTime 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1: async (countdownTime: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countdownTime' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'countdownTime', countdownTime)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/countdownCancelAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (countdownTime !== undefined) { 
                localVarFormParams.set('countdownTime', countdownTime as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('createLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginTypeV1: async (marginType: string, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marginType' is not null or undefined
            assertParamExists('createMarginTypeV1', 'marginType', marginType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginTypeV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginTypeV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/marginType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (marginType !== undefined) { 
                localVarFormParams.set('marginType', marginType as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderV1', 'type', type)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionMarginV1: async (amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createPositionMarginV1', 'amount', amount)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createPositionMarginV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPositionMarginV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createPositionMarginV1', 'type', type)
            const localVarPath = `/dapi/v1/positionMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('createPositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1: async (symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIdList) {
                localVarQueryParameter['orderIdList'] = orderIdList;
            }

            if (origClientOrderIdList) {
                localVarQueryParameter['origClientOrderIdList'] = origClientOrderIdList;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information.
         * @summary Account Information (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdlQuantileV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAdlQuantileV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV1: async (symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAggTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/aggTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV1: async (timestamp: number, symbol?: string, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check futures account balance
         * @summary Futures Account Balance (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBalanceV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user commission rate
         * @summary User Commission Rate (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommissionRateV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCommissionRateV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCommissionRateV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/commissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstituentsV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getConstituentsV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/constituents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinuousKlinesV1: async (pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'contractType', contractType)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/continuousKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getDepthV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] 
         * @param {number} [recvWindow] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, recvWindow?: number, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/fundingInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {string} symbol 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateV1: async (symbol: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFundingRateV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/fundingRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query basis
         * @summary Basis
         * @param {string} pair BTCUSD
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataBasis: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'period', period)
            const localVarPath = `/futures/data/basis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataGlobalLongShortAccountRatio: async (pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataGlobalLongShortAccountRatio', 'pair', pair)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataGlobalLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/globalLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataOpenInterestHist: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'period', period)
            const localVarPath = `/futures/data/openInterestHist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTakerBuySellVol: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataTakerBuySellVol', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getFuturesDataTakerBuySellVol', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTakerBuySellVol', 'period', period)
            const localVarPath = `/futures/data/takerBuySellVol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortPositionRatio: async (pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortPositionRatio', 'pair', pair)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortPositionRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortPositionRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1: async (symbol: string, limit?: number, fromId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getHistoricalTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/income/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/income/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get income history
         * @summary Get Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeV1: async (timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/income`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (incomeType !== undefined) {
                localVarQueryParameter['incomeType'] = incomeType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexPriceKlinesV1: async (pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getIndexPriceKlinesV1', 'pair', pair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getIndexPriceKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/indexPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Not recommended to continue using this v1 endpoint
         * @summary Notional Bracket for Pair(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV1: async (timestamp: number, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getLeverageBracketV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the symbol\'s notional bracket list.
         * @summary Notional Bracket for Symbol(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV2: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getLeverageBracketV2', 'timestamp', timestamp)
            const localVarPath = `/dapi/v2/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkPriceKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarkPriceKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getMarkPriceKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/markPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenInterestV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/openInterest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1: async (timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getOrderAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getOrderAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getOrderAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAsynV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {string} asset 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmAccountInfoV1: async (asset: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPmAccountInfoV1', 'asset', asset)
            const localVarPath = `/dapi/v1/pmAccountInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin,2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default: 50
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionMarginHistoryV1: async (symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPositionMarginHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionMarginHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionMargin/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV1: async (timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionRiskV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (marginAsset !== undefined) {
                localVarQueryParameter['marginAsset'] = marginAsset;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionSideDualV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPremiumIndexKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getPremiumIndexKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/premiumIndexKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/premiumIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/24hr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/bookTicker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getTradeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTradeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/trade/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getTradeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getTradeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTradeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/trade/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {string} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1: async (timestamp: number, symbol?: string, pair?: string, orderId?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchOrdersV1: async (batchOrders: Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('updateBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderV1: async (side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('updateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('updateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FuturesApi - functional programming interface
 * @export
 */
export const FuturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FuturesApiAxiosParamCreator(configuration)
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchOrdersV1(batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {number} countdownTime 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCountdownCancelAllV1(countdownTime: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCountdownCancelAllV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCountdownCancelAllV1(countdownTime, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createCountdownCancelAllV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginTypeV1(marginType: string, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginTypeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginTypeV1(marginType, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createMarginTypeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionMarginV1(amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePositionMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionMarginV1(amount, symbol, timestamp, type, positionSide, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createPositionMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.deleteAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatchOrdersV1(symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatchOrdersV1(symbol, timestamp, orderIdList, origClientOrderIdList, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.deleteBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.deleteListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.deleteOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information.
         * @summary Account Information (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdlQuantileV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdlQuantileV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggTradesV1(symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAggTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggTradesV1(symbol, fromId, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAggTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrdersV1(timestamp: number, symbol?: string, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrdersV1(timestamp, symbol, pair, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check futures account balance
         * @summary Futures Account Balance (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBalanceV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user commission rate
         * @summary User Commission Rate (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommissionRateV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommissionRateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionRateV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getCommissionRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConstituentsV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConstituentsV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConstituentsV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getConstituentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContinuousKlinesV1(pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContinuousKlinesV1(pair, contractType, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getContinuousKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepthV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDepthV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepthV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getDepthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetExchangeInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] 
         * @param {number} [recvWindow] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, recvWindow?: number, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForceOrdersV1(timestamp, symbol, autoCloseType, recvWindow, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFundingInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFundingInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {string} symbol 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingRateV1(symbol: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFundingRateV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingRateV1(symbol, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFundingRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query basis
         * @summary Basis
         * @param {string} pair BTCUSD
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataBasis(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataBasisRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataBasis(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataBasis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataGlobalLongShortAccountRatio(pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataGlobalLongShortAccountRatio(pair, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataGlobalLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataOpenInterestHist(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataOpenInterestHist(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataOpenInterestHist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTakerBuySellVol(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTakerBuySellVolRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTakerBuySellVol(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataTakerBuySellVol']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTopLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTopLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataTopLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTopLongShortPositionRatio(pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTopLongShortPositionRatio(pair, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataTopLongShortPositionRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTradesV1(symbol: string, limit?: number, fromId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetHistoricalTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTradesV1(symbol, limit, fromId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getHistoricalTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getIncomeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getIncomeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get income history
         * @summary Get Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeV1(timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetIncomeV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeV1(timestamp, symbol, incomeType, startTime, endTime, page, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getIncomeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndexPriceKlinesV1(pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndexPriceKlinesV1(pair, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getIndexPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Not recommended to continue using this v1 endpoint
         * @summary Notional Bracket for Pair(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeverageBracketV1(timestamp: number, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLeverageBracketV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeverageBracketV1(timestamp, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the symbol\'s notional bracket list.
         * @summary Notional Bracket for Symbol(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeverageBracketV2(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLeverageBracketV2RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeverageBracketV2(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getLeverageBracketV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarkPriceKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarkPriceKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getMarkPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenInterestV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOpenInterestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenInterestV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOpenInterestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrdersV1(timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrdersV1(timestamp, symbol, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOrderAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOrderAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {string} asset 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmAccountInfoV1(asset: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPmAccountInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmAccountInfoV1(asset, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPmAccountInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin,2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default: 50
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionMarginHistoryV1(symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionMarginHistoryV1(symbol, timestamp, type, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPositionMarginHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionRiskV1(timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionRiskV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionRiskV1(timestamp, marginAsset, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPositionRiskV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionSideDualV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionSideDualV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPremiumIndexKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPremiumIndexKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPremiumIndexKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPremiumIndexV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPremiumIndexV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPremiumIndexV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPremiumIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicker24hrV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTicker24hrV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker24hrV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTicker24hrV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerBookTickerV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTickerBookTickerV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerBookTickerV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTickerBookTickerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerPriceV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTickerPriceV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerPriceV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTickerPriceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTimeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTimeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTradeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTradeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTradeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTradeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradesV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradesV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {string} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTradesV1(timestamp: number, symbol?: string, pair?: string, orderId?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTradesV1(timestamp, symbol, pair, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatchOrdersV1(batchOrders: Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.updateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.updateListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrderV1(side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrderV1(side, symbol, timestamp, orderId, origClientOrderId, price, priceMatch, quantity, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.updateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FuturesApi - factory interface
 * @export
 */
export const FuturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FuturesApiFp(configuration)
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {FuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1(requestParameters: FuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>> {
            return localVarFp.createBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {FuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1(requestParameters: FuturesApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCountdownCancelAllV1Resp> {
            return localVarFp.createCountdownCancelAllV1(requestParameters.countdownTime, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {FuturesApiCreateLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeverageV1(requestParameters: FuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeverageV1Resp> {
            return localVarFp.createLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp> {
            return localVarFp.createListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {FuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginTypeV1(requestParameters: FuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginTypeV1Resp> {
            return localVarFp.createMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {FuturesApiCreateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1(requestParameters: FuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderV1Resp> {
            return localVarFp.createOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {FuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionMarginV1(requestParameters: FuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionMarginV1Resp> {
            return localVarFp.createPositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {FuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionSideDualV1(requestParameters: FuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionSideDualV1Resp> {
            return localVarFp.createPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {FuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1(requestParameters: FuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp> {
            return localVarFp.deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {FuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1(requestParameters: FuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>> {
            return localVarFp.deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {FuturesApiDeleteOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1(requestParameters: FuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp> {
            return localVarFp.deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information.
         * @summary Account Information (USER_DATA)
         * @param {FuturesApiGetAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1(requestParameters: FuturesApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV1Resp> {
            return localVarFp.getAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {FuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdlQuantileV1(requestParameters: FuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAdlQuantileV1RespItem>> {
            return localVarFp.getAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {FuturesApiGetAggTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV1(requestParameters: FuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAggTradesV1RespItem>> {
            return localVarFp.getAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {FuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV1(requestParameters: FuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV1RespItem>> {
            return localVarFp.getAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check futures account balance
         * @summary Futures Account Balance (USER_DATA)
         * @param {FuturesApiGetBalanceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV1(requestParameters: FuturesApiGetBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV1RespItem>> {
            return localVarFp.getBalanceV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user commission rate
         * @summary User Commission Rate (USER_DATA)
         * @param {FuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommissionRateV1(requestParameters: FuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCommissionRateV1Resp> {
            return localVarFp.getCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {FuturesApiGetConstituentsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstituentsV1(requestParameters: FuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConstituentsV1Resp> {
            return localVarFp.getConstituentsV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {FuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinuousKlinesV1(requestParameters: FuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {FuturesApiGetDepthV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1(requestParameters: FuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp> {
            return localVarFp.getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetExchangeInfoV1Resp> {
            return localVarFp.getExchangeInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {FuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForceOrdersV1(requestParameters: FuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>> {
            return localVarFp.getForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.recvWindow, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingInfoV1RespItem>> {
            return localVarFp.getFundingInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {FuturesApiGetFundingRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateV1(requestParameters: FuturesApiGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingRateV1RespItem>> {
            return localVarFp.getFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query basis
         * @summary Basis
         * @param {FuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataBasis(requestParameters: FuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataBasisRespItem>> {
            return localVarFp.getFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataGlobalLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>> {
            return localVarFp.getFuturesDataGlobalLongShortAccountRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {FuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataOpenInterestHist(requestParameters: FuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>> {
            return localVarFp.getFuturesDataOpenInterestHist(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {FuturesApiGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTakerBuySellVol(requestParameters: FuturesApiGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTakerBuySellVolRespItem>> {
            return localVarFp.getFuturesDataTakerBuySellVol(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {FuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>> {
            return localVarFp.getFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {FuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortPositionRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>> {
            return localVarFp.getFuturesDataTopLongShortPositionRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {FuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1(requestParameters: FuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>> {
            return localVarFp.getHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {FuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1(requestParameters: FuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp> {
            return localVarFp.getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {FuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1(requestParameters: FuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp> {
            return localVarFp.getIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get income history
         * @summary Get Income History(USER_DATA)
         * @param {FuturesApiGetIncomeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeV1(requestParameters: FuturesApiGetIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIncomeV1RespItem>> {
            return localVarFp.getIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {FuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexPriceKlinesV1(requestParameters: FuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {FuturesApiGetKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1(requestParameters: FuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Not recommended to continue using this v1 endpoint
         * @summary Notional Bracket for Pair(USER_DATA)
         * @param {FuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV1(requestParameters: FuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeverageBracketV1RespItem>> {
            return localVarFp.getLeverageBracketV1(requestParameters.timestamp, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the symbol\'s notional bracket list.
         * @summary Notional Bracket for Symbol(USER_DATA)
         * @param {FuturesApiGetLeverageBracketV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV2(requestParameters: FuturesApiGetLeverageBracketV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeverageBracketV2RespItem>> {
            return localVarFp.getLeverageBracketV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {FuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkPriceKlinesV1(requestParameters: FuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {FuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1(requestParameters: FuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenInterestV1Resp> {
            return localVarFp.getOpenInterestV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {FuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderV1(requestParameters: FuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenOrderV1Resp> {
            return localVarFp.getOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {FuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1(requestParameters: FuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>> {
            return localVarFp.getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {FuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAmendmentV1(requestParameters: FuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOrderAmendmentV1RespItem>> {
            return localVarFp.getOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {FuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynIdV1(requestParameters: FuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynIdV1Resp> {
            return localVarFp.getOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {FuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynV1(requestParameters: FuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynV1Resp> {
            return localVarFp.getOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {FuturesApiGetOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1(requestParameters: FuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp> {
            return localVarFp.getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {FuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmAccountInfoV1(requestParameters: FuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPmAccountInfoV1Resp> {
            return localVarFp.getPmAccountInfoV1(requestParameters.asset, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {FuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionMarginHistoryV1(requestParameters: FuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>> {
            return localVarFp.getPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {FuturesApiGetPositionRiskV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV1(requestParameters: FuturesApiGetPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV1RespItem>> {
            return localVarFp.getPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {FuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionSideDualV1(requestParameters: FuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPositionSideDualV1Resp> {
            return localVarFp.getPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {FuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexKlinesV1(requestParameters: FuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {FuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexV1(requestParameters: FuturesApiGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPremiumIndexV1RespItem>> {
            return localVarFp.getPremiumIndexV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {FuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV1(requestParameters: FuturesApiGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTicker24hrV1RespItem>> {
            return localVarFp.getTicker24hrV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {FuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV1(requestParameters: FuturesApiGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerBookTickerV1RespItem>> {
            return localVarFp.getTickerBookTickerV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {FuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV1(requestParameters: FuturesApiGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerPriceV1RespItem>> {
            return localVarFp.getTickerPriceV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp> {
            return localVarFp.getTimeV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {FuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynIdV1(requestParameters: FuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynIdV1Resp> {
            return localVarFp.getTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {FuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynV1(requestParameters: FuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynV1Resp> {
            return localVarFp.getTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {FuturesApiGetTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1(requestParameters: FuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>> {
            return localVarFp.getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {FuturesApiGetUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1(requestParameters: FuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>> {
            return localVarFp.getUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {FuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchOrdersV1(requestParameters: FuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>> {
            return localVarFp.updateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {FuturesApiUpdateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderV1(requestParameters: FuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderV1Resp> {
            return localVarFp.updateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FuturesApi - interface
 * @export
 * @interface FuturesApi
 */
export interface FuturesApiInterface {
    /**
     * Place multiple orders
     * @summary Place Multiple Orders(TRADE)
     * @param {FuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createBatchOrdersV1(requestParameters: FuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>>;

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {FuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createCountdownCancelAllV1(requestParameters: FuturesApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCountdownCancelAllV1Resp>;

    /**
     * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
     * @summary Change Initial Leverage (TRADE)
     * @param {FuturesApiCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createLeverageV1(requestParameters: FuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeverageV1Resp>;

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp>;

    /**
     * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
     * @summary Change Margin Type (TRADE)
     * @param {FuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createMarginTypeV1(requestParameters: FuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginTypeV1Resp>;

    /**
     * Send in a new order.
     * @summary New Order (TRADE)
     * @param {FuturesApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createOrderV1(requestParameters: FuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderV1Resp>;

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {FuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createPositionMarginV1(requestParameters: FuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionMarginV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {FuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createPositionSideDualV1(requestParameters: FuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionSideDualV1Resp>;

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders(TRADE)
     * @param {FuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    deleteAllOpenOrdersV1(requestParameters: FuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp>;

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders(TRADE)
     * @param {FuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    deleteBatchOrdersV1(requestParameters: FuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>>;

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream(USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {FuturesApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    deleteOrderV1(requestParameters: FuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp>;

    /**
     * Get current account information.
     * @summary Account Information (USER_DATA)
     * @param {FuturesApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAccountV1(requestParameters: FuturesApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV1Resp>;

    /**
     * Query position ADL quantile estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {FuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAdlQuantileV1(requestParameters: FuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAdlQuantileV1RespItem>>;

    /**
     * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {FuturesApiGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAggTradesV1(requestParameters: FuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAggTradesV1RespItem>>;

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {FuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAllOrdersV1(requestParameters: FuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV1RespItem>>;

    /**
     * Check futures account balance
     * @summary Futures Account Balance (USER_DATA)
     * @param {FuturesApiGetBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getBalanceV1(requestParameters: FuturesApiGetBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV1RespItem>>;

    /**
     * Query user commission rate
     * @summary User Commission Rate (USER_DATA)
     * @param {FuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getCommissionRateV1(requestParameters: FuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCommissionRateV1Resp>;

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {FuturesApiGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getConstituentsV1(requestParameters: FuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConstituentsV1Resp>;

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {FuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getContinuousKlinesV1(requestParameters: FuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query orderbook on specific symbol
     * @summary Order Book
     * @param {FuturesApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getDepthV1(requestParameters: FuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp>;

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetExchangeInfoV1Resp>;

    /**
     * User\'s Force Orders
     * @summary User\'s Force Orders(USER_DATA)
     * @param {FuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getForceOrdersV1(requestParameters: FuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>>;

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingInfoV1RespItem>>;

    /**
     * Get Funding Rate History of Perpetual Futures
     * @summary Get Funding Rate History of Perpetual Futures
     * @param {FuturesApiGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFundingRateV1(requestParameters: FuturesApiGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingRateV1RespItem>>;

    /**
     * Query basis
     * @summary Basis
     * @param {FuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataBasis(requestParameters: FuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataBasisRespItem>>;

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataGlobalLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>>;

    /**
     * Query open interest stats
     * @summary Open Interest Statistics
     * @param {FuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataOpenInterestHist(requestParameters: FuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>>;

    /**
     * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
     * @summary Taker Buy/Sell Volume
     * @param {FuturesApiGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataTakerBuySellVol(requestParameters: FuturesApiGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTakerBuySellVolRespItem>>;

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {FuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataTopLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>>;

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {FuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataTopLongShortPositionRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>>;

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup(MARKET_DATA)
     * @param {FuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getHistoricalTradesV1(requestParameters: FuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>>;

    /**
     * Get futures transaction history download link by Id
     * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
     * @param {FuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getIncomeAsynIdV1(requestParameters: FuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp>;

    /**
     * Get download id for futures transaction history
     * @summary Get Download Id For Futures Transaction History(USER_DATA)
     * @param {FuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getIncomeAsynV1(requestParameters: FuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp>;

    /**
     * Get income history
     * @summary Get Income History(USER_DATA)
     * @param {FuturesApiGetIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getIncomeV1(requestParameters: FuturesApiGetIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIncomeV1RespItem>>;

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {FuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getIndexPriceKlinesV1(requestParameters: FuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {FuturesApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getKlinesV1(requestParameters: FuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Not recommended to continue using this v1 endpoint
     * @summary Notional Bracket for Pair(USER_DATA)
     * @param {FuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getLeverageBracketV1(requestParameters: FuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeverageBracketV1RespItem>>;

    /**
     * Get the symbol\'s notional bracket list.
     * @summary Notional Bracket for Symbol(USER_DATA)
     * @param {FuturesApiGetLeverageBracketV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getLeverageBracketV2(requestParameters: FuturesApiGetLeverageBracketV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeverageBracketV2RespItem>>;

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {FuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getMarkPriceKlinesV1(requestParameters: FuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {FuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOpenInterestV1(requestParameters: FuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenInterestV1Resp>;

    /**
     * Query Current Open Order
     * @summary Query Current Open Order(USER_DATA)
     * @param {FuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOpenOrderV1(requestParameters: FuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {FuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOpenOrdersV1(requestParameters: FuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {FuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOrderAmendmentV1(requestParameters: FuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOrderAmendmentV1RespItem>>;

    /**
     * Get futures order history download link by Id
     * @summary Get Futures Order History Download Link by Id (USER_DATA)
     * @param {FuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOrderAsynIdV1(requestParameters: FuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynIdV1Resp>;

    /**
     * Get Download Id For Futures Order History
     * @summary Get Download Id For Futures Order History (USER_DATA)
     * @param {FuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOrderAsynV1(requestParameters: FuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynV1Resp>;

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {FuturesApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOrderV1(requestParameters: FuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Get Classic Portfolio Margin current account information.
     * @summary Classic Portfolio Margin Account Information (USER_DATA)
     * @param {FuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPmAccountInfoV1(requestParameters: FuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPmAccountInfoV1Resp>;

    /**
     * Get position margin change history
     * @summary Get Position Margin Change History(TRADE)
     * @param {FuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPositionMarginHistoryV1(requestParameters: FuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>>;

    /**
     * Get current account information.
     * @summary Position Information(USER_DATA)
     * @param {FuturesApiGetPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPositionRiskV1(requestParameters: FuturesApiGetPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV1RespItem>>;

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Get Current Position Mode(USER_DATA)
     * @param {FuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPositionSideDualV1(requestParameters: FuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPositionSideDualV1Resp>;

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {FuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPremiumIndexKlinesV1(requestParameters: FuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query index price and mark price
     * @summary Index Price and Mark Price
     * @param {FuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPremiumIndexV1(requestParameters?: FuturesApiGetPremiumIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPremiumIndexV1RespItem>>;

    /**
     * 24 hour rolling window price change statistics.
     * @summary 24hr Ticker Price Change Statistics
     * @param {FuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTicker24hrV1(requestParameters?: FuturesApiGetTicker24hrV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTicker24hrV1RespItem>>;

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {FuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTickerBookTickerV1(requestParameters?: FuturesApiGetTickerBookTickerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerBookTickerV1RespItem>>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {FuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTickerPriceV1(requestParameters?: FuturesApiGetTickerPriceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerPriceV1RespItem>>;

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp>;

    /**
     * Get futures trade download link by Id
     * @summary Get Futures Trade Download Link by Id(USER_DATA)
     * @param {FuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTradeAsynIdV1(requestParameters: FuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynIdV1Resp>;

    /**
     * Get download id for futures trade history
     * @summary Get Download Id For Futures Trade History (USER_DATA)
     * @param {FuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTradeAsynV1(requestParameters: FuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynV1Resp>;

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {FuturesApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTradesV1(requestParameters: FuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {FuturesApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getUserTradesV1(requestParameters: FuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>>;

    /**
     * Modify Multiple Orders
     * @summary Modify Multiple Orders(TRADE)
     * @param {FuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    updateBatchOrdersV1(requestParameters: FuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>>;

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {FuturesApiUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    updateOrderV1(requestParameters: FuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderV1Resp>;

}

/**
 * Request parameters for createBatchOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateBatchOrdersV1Request
 */
export interface FuturesApiCreateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>}
     * @memberof FuturesApiCreateBatchOrdersV1
     */
    readonly batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createCountdownCancelAllV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateCountdownCancelAllV1Request
 */
export interface FuturesApiCreateCountdownCancelAllV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateCountdownCancelAllV1
     */
    readonly countdownTime: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateCountdownCancelAllV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateCountdownCancelAllV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateCountdownCancelAllV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createLeverageV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateLeverageV1Request
 */
export interface FuturesApiCreateLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginTypeV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateMarginTypeV1Request
 */
export interface FuturesApiCreateMarginTypeV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateMarginTypeV1
     */
    readonly marginType: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateMarginTypeV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateMarginTypeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateMarginTypeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateOrderV1Request
 */
export interface FuturesApiCreateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for createPositionMarginV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreatePositionMarginV1Request
 */
export interface FuturesApiCreatePositionMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly type: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createPositionSideDualV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreatePositionSideDualV1Request
 */
export interface FuturesApiCreatePositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreatePositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteAllOpenOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiDeleteAllOpenOrdersV1Request
 */
export interface FuturesApiDeleteAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiDeleteAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteBatchOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiDeleteBatchOrdersV1Request
 */
export interface FuturesApiDeleteBatchOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * max length 10 &lt;br/&gt; e.g. [1234567,2345678]
     * @type {Array<number>}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly orderIdList?: Array<number>

    /**
     * max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
     * @type {Array<string>}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly origClientOrderIdList?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiDeleteOrderV1Request
 */
export interface FuturesApiDeleteOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAccountV1Request
 */
export interface FuturesApiGetAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAdlQuantileV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAdlQuantileV1Request
 */
export interface FuturesApiGetAdlQuantileV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAdlQuantileV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetAdlQuantileV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAdlQuantileV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAggTradesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAggTradesV1Request
 */
export interface FuturesApiGetAggTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly symbol: string

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly fromId?: number

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getAllOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAllOrdersV1Request
 */
export interface FuturesApiGetAllOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBalanceV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetBalanceV1Request
 */
export interface FuturesApiGetBalanceV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetBalanceV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetBalanceV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCommissionRateV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetCommissionRateV1Request
 */
export interface FuturesApiGetCommissionRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetCommissionRateV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetCommissionRateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetCommissionRateV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getConstituentsV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetConstituentsV1Request
 */
export interface FuturesApiGetConstituentsV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetConstituentsV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getContinuousKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetContinuousKlinesV1Request
 */
export interface FuturesApiGetContinuousKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly contractType: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getDepthV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetDepthV1Request
 */
export interface FuturesApiGetDepthV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetDepthV1
     */
    readonly symbol: string

    /**
     * Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
     * @type {number}
     * @memberof FuturesApiGetDepthV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getForceOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetForceOrdersV1Request
 */
export interface FuturesApiGetForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFundingRateV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFundingRateV1Request
 */
export interface FuturesApiGetFundingRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetFundingRateV1
     */
    readonly symbol: string

    /**
     * Timestamp in ms to get funding rate from INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetFundingRateV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding rate  until INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetFundingRateV1
     */
    readonly endTime?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof FuturesApiGetFundingRateV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getFuturesDataBasis operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataBasisRequest
 */
export interface FuturesApiGetFuturesDataBasisRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly pair: string

    /**
     * CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataGlobalLongShortAccountRatio operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest
 */
export interface FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly pair: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataOpenInterestHist operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataOpenInterestHistRequest
 */
export interface FuturesApiGetFuturesDataOpenInterestHistRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly pair: string

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTakerBuySellVol operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataTakerBuySellVolRequest
 */
export interface FuturesApiGetFuturesDataTakerBuySellVolRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly pair: string

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTopLongShortAccountRatio operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataTopLongShortAccountRatioRequest
 */
export interface FuturesApiGetFuturesDataTopLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTopLongShortPositionRatio operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataTopLongShortPositionRatioRequest
 */
export interface FuturesApiGetFuturesDataTopLongShortPositionRatioRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly pair: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getHistoricalTradesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetHistoricalTradesV1Request
 */
export interface FuturesApiGetHistoricalTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetHistoricalTradesV1
     */
    readonly symbol: string

    /**
     * Default 100; max 500.
     * @type {number}
     * @memberof FuturesApiGetHistoricalTradesV1
     */
    readonly limit?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof FuturesApiGetHistoricalTradesV1
     */
    readonly fromId?: number
}

/**
 * Request parameters for getIncomeAsynIdV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetIncomeAsynIdV1Request
 */
export interface FuturesApiGetIncomeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof FuturesApiGetIncomeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIncomeAsynV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetIncomeAsynV1Request
 */
export interface FuturesApiGetIncomeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIncomeV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetIncomeV1Request
 */
export interface FuturesApiGetIncomeV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetIncomeV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetIncomeV1
     */
    readonly incomeType?: string

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetIncomeV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetIncomeV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeV1
     */
    readonly page?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof FuturesApiGetIncomeV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIndexPriceKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetIndexPriceKlinesV1Request
 */
export interface FuturesApiGetIndexPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetKlinesV1Request
 */
export interface FuturesApiGetKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getLeverageBracketV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetLeverageBracketV1Request
 */
export interface FuturesApiGetLeverageBracketV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetLeverageBracketV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetLeverageBracketV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetLeverageBracketV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getLeverageBracketV2 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetLeverageBracketV2Request
 */
export interface FuturesApiGetLeverageBracketV2Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetLeverageBracketV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetLeverageBracketV2
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetLeverageBracketV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarkPriceKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetMarkPriceKlinesV1Request
 */
export interface FuturesApiGetMarkPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getOpenInterestV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOpenInterestV1Request
 */
export interface FuturesApiGetOpenInterestV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenInterestV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getOpenOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOpenOrderV1Request
 */
export interface FuturesApiGetOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOpenOrdersV1Request
 */
export interface FuturesApiGetOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAmendmentV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOrderAmendmentV1Request
 */
export interface FuturesApiGetOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAsynIdV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOrderAsynIdV1Request
 */
export interface FuturesApiGetOrderAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof FuturesApiGetOrderAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAsynV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOrderAsynV1Request
 */
export interface FuturesApiGetOrderAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetOrderAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetOrderAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOrderV1Request
 */
export interface FuturesApiGetOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPmAccountInfoV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPmAccountInfoV1Request
 */
export interface FuturesApiGetPmAccountInfoV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPmAccountInfoV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPmAccountInfoV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionMarginHistoryV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPositionMarginHistoryV1Request
 */
export interface FuturesApiGetPositionMarginHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly timestamp: number

    /**
     * 1: Add position margin,2: Reduce position margin
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly type?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly endTime?: number

    /**
     * Default: 50
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionRiskV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPositionRiskV1Request
 */
export interface FuturesApiGetPositionRiskV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionRiskV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPositionRiskV1
     */
    readonly marginAsset?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPositionRiskV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionRiskV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionSideDualV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPositionSideDualV1Request
 */
export interface FuturesApiGetPositionSideDualV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPremiumIndexKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPremiumIndexKlinesV1Request
 */
export interface FuturesApiGetPremiumIndexKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getPremiumIndexV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPremiumIndexV1Request
 */
export interface FuturesApiGetPremiumIndexV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPremiumIndexV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPremiumIndexV1
     */
    readonly pair?: string
}

/**
 * Request parameters for getTicker24hrV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTicker24hrV1Request
 */
export interface FuturesApiGetTicker24hrV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTicker24hrV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTicker24hrV1
     */
    readonly pair?: string
}

/**
 * Request parameters for getTickerBookTickerV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTickerBookTickerV1Request
 */
export interface FuturesApiGetTickerBookTickerV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTickerBookTickerV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTickerBookTickerV1
     */
    readonly pair?: string
}

/**
 * Request parameters for getTickerPriceV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTickerPriceV1Request
 */
export interface FuturesApiGetTickerPriceV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTickerPriceV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTickerPriceV1
     */
    readonly pair?: string
}

/**
 * Request parameters for getTradeAsynIdV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTradeAsynIdV1Request
 */
export interface FuturesApiGetTradeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof FuturesApiGetTradeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetTradeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetTradeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTradeAsynV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTradeAsynV1Request
 */
export interface FuturesApiGetTradeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetTradeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetTradeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetTradeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetTradeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTradesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTradesV1Request
 */
export interface FuturesApiGetTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTradesV1
     */
    readonly symbol: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof FuturesApiGetTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getUserTradesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetUserTradesV1Request
 */
export interface FuturesApiGetUserTradesV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly pair?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly orderId?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 50; max 1000
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateBatchOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiUpdateBatchOrdersV1Request
 */
export interface FuturesApiUpdateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>}
     * @memberof FuturesApiUpdateBatchOrdersV1
     */
    readonly batchOrders: Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiUpdateOrderV1Request
 */
export interface FuturesApiUpdateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly recvWindow?: number
}

/**
 * FuturesApi - object-oriented interface
 * @export
 * @class FuturesApi
 * @extends {BaseAPI}
 */
export class FuturesApi extends BaseAPI implements FuturesApiInterface {
    /**
     * Place multiple orders
     * @summary Place Multiple Orders(TRADE)
     * @param {FuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createBatchOrdersV1(requestParameters: FuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {FuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createCountdownCancelAllV1(requestParameters: FuturesApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createCountdownCancelAllV1(requestParameters.countdownTime, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
     * @summary Change Initial Leverage (TRADE)
     * @param {FuturesApiCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createLeverageV1(requestParameters: FuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createListenKeyV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
     * @summary Change Margin Type (TRADE)
     * @param {FuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createMarginTypeV1(requestParameters: FuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new order.
     * @summary New Order (TRADE)
     * @param {FuturesApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createOrderV1(requestParameters: FuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {FuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createPositionMarginV1(requestParameters: FuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createPositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {FuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createPositionSideDualV1(requestParameters: FuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders(TRADE)
     * @param {FuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public deleteAllOpenOrdersV1(requestParameters: FuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders(TRADE)
     * @param {FuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public deleteBatchOrdersV1(requestParameters: FuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream(USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public deleteListenKeyV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).deleteListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {FuturesApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public deleteOrderV1(requestParameters: FuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information.
     * @summary Account Information (USER_DATA)
     * @param {FuturesApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAccountV1(requestParameters: FuturesApiGetAccountV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query position ADL quantile estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {FuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAdlQuantileV1(requestParameters: FuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {FuturesApiGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAggTradesV1(requestParameters: FuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {FuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAllOrdersV1(requestParameters: FuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check futures account balance
     * @summary Futures Account Balance (USER_DATA)
     * @param {FuturesApiGetBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getBalanceV1(requestParameters: FuturesApiGetBalanceV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getBalanceV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user commission rate
     * @summary User Commission Rate (USER_DATA)
     * @param {FuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getCommissionRateV1(requestParameters: FuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {FuturesApiGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getConstituentsV1(requestParameters: FuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getConstituentsV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {FuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getContinuousKlinesV1(requestParameters: FuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query orderbook on specific symbol
     * @summary Order Book
     * @param {FuturesApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getDepthV1(requestParameters: FuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getExchangeInfoV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getExchangeInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User\'s Force Orders
     * @summary User\'s Force Orders(USER_DATA)
     * @param {FuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getForceOrdersV1(requestParameters: FuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.recvWindow, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFundingInfoV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFundingInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Funding Rate History of Perpetual Futures
     * @summary Get Funding Rate History of Perpetual Futures
     * @param {FuturesApiGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFundingRateV1(requestParameters: FuturesApiGetFundingRateV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query basis
     * @summary Basis
     * @param {FuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataBasis(requestParameters: FuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataGlobalLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataGlobalLongShortAccountRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query open interest stats
     * @summary Open Interest Statistics
     * @param {FuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataOpenInterestHist(requestParameters: FuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataOpenInterestHist(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
     * @summary Taker Buy/Sell Volume
     * @param {FuturesApiGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataTakerBuySellVol(requestParameters: FuturesApiGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataTakerBuySellVol(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {FuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataTopLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {FuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataTopLongShortPositionRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataTopLongShortPositionRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup(MARKET_DATA)
     * @param {FuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getHistoricalTradesV1(requestParameters: FuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures transaction history download link by Id
     * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
     * @param {FuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getIncomeAsynIdV1(requestParameters: FuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for futures transaction history
     * @summary Get Download Id For Futures Transaction History(USER_DATA)
     * @param {FuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getIncomeAsynV1(requestParameters: FuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get income history
     * @summary Get Income History(USER_DATA)
     * @param {FuturesApiGetIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getIncomeV1(requestParameters: FuturesApiGetIncomeV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {FuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getIndexPriceKlinesV1(requestParameters: FuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {FuturesApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getKlinesV1(requestParameters: FuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Not recommended to continue using this v1 endpoint
     * @summary Notional Bracket for Pair(USER_DATA)
     * @param {FuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getLeverageBracketV1(requestParameters: FuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getLeverageBracketV1(requestParameters.timestamp, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the symbol\'s notional bracket list.
     * @summary Notional Bracket for Symbol(USER_DATA)
     * @param {FuturesApiGetLeverageBracketV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getLeverageBracketV2(requestParameters: FuturesApiGetLeverageBracketV2Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getLeverageBracketV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {FuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getMarkPriceKlinesV1(requestParameters: FuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {FuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOpenInterestV1(requestParameters: FuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOpenInterestV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current Open Order
     * @summary Query Current Open Order(USER_DATA)
     * @param {FuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOpenOrderV1(requestParameters: FuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {FuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOpenOrdersV1(requestParameters: FuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {FuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOrderAmendmentV1(requestParameters: FuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures order history download link by Id
     * @summary Get Futures Order History Download Link by Id (USER_DATA)
     * @param {FuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOrderAsynIdV1(requestParameters: FuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Download Id For Futures Order History
     * @summary Get Download Id For Futures Order History (USER_DATA)
     * @param {FuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOrderAsynV1(requestParameters: FuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {FuturesApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOrderV1(requestParameters: FuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPingV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Classic Portfolio Margin current account information.
     * @summary Classic Portfolio Margin Account Information (USER_DATA)
     * @param {FuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPmAccountInfoV1(requestParameters: FuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPmAccountInfoV1(requestParameters.asset, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get position margin change history
     * @summary Get Position Margin Change History(TRADE)
     * @param {FuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPositionMarginHistoryV1(requestParameters: FuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information.
     * @summary Position Information(USER_DATA)
     * @param {FuturesApiGetPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPositionRiskV1(requestParameters: FuturesApiGetPositionRiskV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Get Current Position Mode(USER_DATA)
     * @param {FuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPositionSideDualV1(requestParameters: FuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {FuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPremiumIndexKlinesV1(requestParameters: FuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price and mark price
     * @summary Index Price and Mark Price
     * @param {FuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPremiumIndexV1(requestParameters: FuturesApiGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPremiumIndexV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics.
     * @summary 24hr Ticker Price Change Statistics
     * @param {FuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTicker24hrV1(requestParameters: FuturesApiGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTicker24hrV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {FuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTickerBookTickerV1(requestParameters: FuturesApiGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTickerBookTickerV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {FuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTickerPriceV1(requestParameters: FuturesApiGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTickerPriceV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTimeV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTimeV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures trade download link by Id
     * @summary Get Futures Trade Download Link by Id(USER_DATA)
     * @param {FuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTradeAsynIdV1(requestParameters: FuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for futures trade history
     * @summary Get Download Id For Futures Trade History (USER_DATA)
     * @param {FuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTradeAsynV1(requestParameters: FuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {FuturesApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTradesV1(requestParameters: FuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {FuturesApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getUserTradesV1(requestParameters: FuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Multiple Orders
     * @summary Modify Multiple Orders(TRADE)
     * @param {FuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public updateBatchOrdersV1(requestParameters: FuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).updateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public updateListenKeyV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).updateListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {FuturesApiUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public updateOrderV1(requestParameters: FuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).updateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

