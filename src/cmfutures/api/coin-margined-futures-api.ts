/* tslint:disable */
/* eslint-disable */
/**
 * Binance COIN-M Futures API
 * OpenAPI specification for Binance exchange - Cmfutures API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CmfuturesCreateBatchOrderV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { CmfuturesCreateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CmfuturesDeleteBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CmfuturesGetContinuousKlinesV1RespInnerInner } from '../model';
// @ts-ignore
import type { CmfuturesGetExchangeInfoV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { CmfuturesUpdateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CreateCountdownCancelAllV1Resp } from '../model';
// @ts-ignore
import type { CreateLeverageV1Resp } from '../model';
// @ts-ignore
import type { CreateListenKeyV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginTypeV1Resp } from '../model';
// @ts-ignore
import type { CreateOrderV1Resp } from '../model';
// @ts-ignore
import type { CreatePositionMarginV1Resp } from '../model';
// @ts-ignore
import type { CreatePositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { DeleteAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteOrderV1Resp } from '../model';
// @ts-ignore
import type { GetAccountV1Resp } from '../model';
// @ts-ignore
import type { GetAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { GetAggTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetBalanceV1RespItem } from '../model';
// @ts-ignore
import type { GetCommissionRateV1Resp } from '../model';
// @ts-ignore
import type { GetConstituentsV1Resp } from '../model';
// @ts-ignore
import type { GetDepthV1Resp } from '../model';
// @ts-ignore
import type { GetFundingInfoV1RespItem } from '../model';
// @ts-ignore
import type { GetFundingRateV1RespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataBasisRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataGlobalLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataOpenInterestHistRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTakerBuySellVolRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTopLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTopLongShortPositionRatioRespItem } from '../model';
// @ts-ignore
import type { GetHistoricalTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetIncomeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetIncomeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetIncomeV1RespItem } from '../model';
// @ts-ignore
import type { GetLeverageBracketV1RespItem } from '../model';
// @ts-ignore
import type { GetLeverageBracketV2RespItem } from '../model';
// @ts-ignore
import type { GetOpenInterestV1Resp } from '../model';
// @ts-ignore
import type { GetOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { GetOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetOrderAsynV1Resp } from '../model';
// @ts-ignore
import type { GetOrderV1Resp } from '../model';
// @ts-ignore
import type { GetPmAccountInfoV1Resp } from '../model';
// @ts-ignore
import type { GetPositionMarginHistoryV1RespItem } from '../model';
// @ts-ignore
import type { GetPositionRiskV1RespItem } from '../model';
// @ts-ignore
import type { GetPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { GetPremiumIndexV1RespItem } from '../model';
// @ts-ignore
import type { GetTicker24hrV1RespItem } from '../model';
// @ts-ignore
import type { GetTickerBookTickerV1RespItem } from '../model';
// @ts-ignore
import type { GetTickerPriceV1RespItem } from '../model';
// @ts-ignore
import type { GetTimeV1Resp } from '../model';
// @ts-ignore
import type { GetTradeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetTradeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { UpdateOrderV1Resp } from '../model';
/**
 * CoinMarginedFuturesApi - axios parameter creator
 * @export
 */
export const CoinMarginedFuturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1: async (batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {number} countdownTime 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1: async (countdownTime: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countdownTime' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'countdownTime', countdownTime)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/countdownCancelAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (countdownTime !== undefined) { 
                localVarFormParams.set('countdownTime', countdownTime as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('createLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginTypeV1: async (marginType: string, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marginType' is not null or undefined
            assertParamExists('createMarginTypeV1', 'marginType', marginType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginTypeV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginTypeV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/marginType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (marginType !== undefined) { 
                localVarFormParams.set('marginType', marginType as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderV1', 'type', type)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionMarginV1: async (amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createPositionMarginV1', 'amount', amount)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createPositionMarginV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPositionMarginV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createPositionMarginV1', 'type', type)
            const localVarPath = `/dapi/v1/positionMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('createPositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1: async (symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIdList) {
                localVarQueryParameter['orderIdList'] = orderIdList;
            }

            if (origClientOrderIdList) {
                localVarQueryParameter['origClientOrderIdList'] = origClientOrderIdList;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information.
         * @summary Account Information (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdlQuantileV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAdlQuantileV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV1: async (symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAggTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/aggTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV1: async (timestamp: number, symbol?: string, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check futures account balance
         * @summary Futures Account Balance (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBalanceV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user commission rate
         * @summary User Commission Rate (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommissionRateV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCommissionRateV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCommissionRateV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/commissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstituentsV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getConstituentsV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/constituents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinuousKlinesV1: async (pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'contractType', contractType)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/continuousKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getDepthV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] 
         * @param {number} [recvWindow] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, recvWindow?: number, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/fundingInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {string} symbol 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateV1: async (symbol: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFundingRateV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/fundingRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query basis
         * @summary Basis
         * @param {string} pair BTCUSD
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataBasis: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'period', period)
            const localVarPath = `/futures/data/basis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataGlobalLongShortAccountRatio: async (pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataGlobalLongShortAccountRatio', 'pair', pair)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataGlobalLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/globalLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataOpenInterestHist: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'period', period)
            const localVarPath = `/futures/data/openInterestHist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTakerBuySellVol: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataTakerBuySellVol', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getFuturesDataTakerBuySellVol', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTakerBuySellVol', 'period', period)
            const localVarPath = `/futures/data/takerBuySellVol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortPositionRatio: async (pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortPositionRatio', 'pair', pair)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortPositionRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortPositionRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1: async (symbol: string, limit?: number, fromId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getHistoricalTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/income/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/income/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get income history
         * @summary Get Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeV1: async (timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/income`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (incomeType !== undefined) {
                localVarQueryParameter['incomeType'] = incomeType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexPriceKlinesV1: async (pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getIndexPriceKlinesV1', 'pair', pair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getIndexPriceKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/indexPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Not recommended to continue using this v1 endpoint
         * @summary Notional Bracket for Pair(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV1: async (timestamp: number, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getLeverageBracketV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the symbol\'s notional bracket list.
         * @summary Notional Bracket for Symbol(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV2: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getLeverageBracketV2', 'timestamp', timestamp)
            const localVarPath = `/dapi/v2/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkPriceKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarkPriceKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getMarkPriceKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/markPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenInterestV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/openInterest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1: async (timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getOrderAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getOrderAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getOrderAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAsynV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {string} asset 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmAccountInfoV1: async (asset: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPmAccountInfoV1', 'asset', asset)
            const localVarPath = `/dapi/v1/pmAccountInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin,2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default: 50
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionMarginHistoryV1: async (symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPositionMarginHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionMarginHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionMargin/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV1: async (timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionRiskV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (marginAsset !== undefined) {
                localVarQueryParameter['marginAsset'] = marginAsset;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionSideDualV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPremiumIndexKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getPremiumIndexKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/premiumIndexKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/premiumIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/24hr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/bookTicker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getTradeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTradeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/trade/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getTradeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getTradeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTradeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/trade/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {string} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1: async (timestamp: number, symbol?: string, pair?: string, orderId?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchOrdersV1: async (batchOrders: Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('updateBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderV1: async (side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('updateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('updateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoinMarginedFuturesApi - functional programming interface
 * @export
 */
export const CoinMarginedFuturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoinMarginedFuturesApiAxiosParamCreator(configuration)
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchOrdersV1(batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.createBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {number} countdownTime 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCountdownCancelAllV1(countdownTime: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCountdownCancelAllV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCountdownCancelAllV1(countdownTime, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.createCountdownCancelAllV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.createLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.createListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginTypeV1(marginType: string, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginTypeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginTypeV1(marginType, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.createMarginTypeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.createOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionMarginV1(amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePositionMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionMarginV1(amount, symbol, timestamp, type, positionSide, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.createPositionMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.createPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.deleteAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatchOrdersV1(symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatchOrdersV1(symbol, timestamp, orderIdList, origClientOrderIdList, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.deleteBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.deleteListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.deleteOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information.
         * @summary Account Information (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdlQuantileV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdlQuantileV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggTradesV1(symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAggTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggTradesV1(symbol, fromId, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getAggTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrdersV1(timestamp: number, symbol?: string, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrdersV1(timestamp, symbol, pair, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check futures account balance
         * @summary Futures Account Balance (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBalanceV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user commission rate
         * @summary User Commission Rate (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommissionRateV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommissionRateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionRateV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getCommissionRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConstituentsV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConstituentsV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConstituentsV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getConstituentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContinuousKlinesV1(pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContinuousKlinesV1(pair, contractType, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getContinuousKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepthV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDepthV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepthV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getDepthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetExchangeInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] 
         * @param {number} [recvWindow] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, recvWindow?: number, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForceOrdersV1(timestamp, symbol, autoCloseType, recvWindow, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFundingInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getFundingInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {string} symbol 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingRateV1(symbol: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFundingRateV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingRateV1(symbol, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getFundingRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query basis
         * @summary Basis
         * @param {string} pair BTCUSD
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataBasis(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataBasisRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataBasis(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getFuturesDataBasis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataGlobalLongShortAccountRatio(pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataGlobalLongShortAccountRatio(pair, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getFuturesDataGlobalLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataOpenInterestHist(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataOpenInterestHist(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getFuturesDataOpenInterestHist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTakerBuySellVol(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTakerBuySellVolRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTakerBuySellVol(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getFuturesDataTakerBuySellVol']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTopLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTopLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getFuturesDataTopLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTopLongShortPositionRatio(pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTopLongShortPositionRatio(pair, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getFuturesDataTopLongShortPositionRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTradesV1(symbol: string, limit?: number, fromId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetHistoricalTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTradesV1(symbol, limit, fromId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getHistoricalTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getIncomeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getIncomeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get income history
         * @summary Get Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeV1(timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetIncomeV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeV1(timestamp, symbol, incomeType, startTime, endTime, page, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getIncomeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndexPriceKlinesV1(pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndexPriceKlinesV1(pair, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getIndexPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Not recommended to continue using this v1 endpoint
         * @summary Notional Bracket for Pair(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeverageBracketV1(timestamp: number, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLeverageBracketV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeverageBracketV1(timestamp, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the symbol\'s notional bracket list.
         * @summary Notional Bracket for Symbol(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeverageBracketV2(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLeverageBracketV2RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeverageBracketV2(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getLeverageBracketV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarkPriceKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarkPriceKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getMarkPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenInterestV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOpenInterestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenInterestV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getOpenInterestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrdersV1(timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrdersV1(timestamp, symbol, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getOrderAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getOrderAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getPingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {string} asset 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmAccountInfoV1(asset: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPmAccountInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmAccountInfoV1(asset, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getPmAccountInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin,2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default: 50
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionMarginHistoryV1(symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionMarginHistoryV1(symbol, timestamp, type, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getPositionMarginHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionRiskV1(timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionRiskV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionRiskV1(timestamp, marginAsset, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getPositionRiskV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionSideDualV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionSideDualV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPremiumIndexKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPremiumIndexKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getPremiumIndexKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPremiumIndexV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPremiumIndexV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPremiumIndexV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getPremiumIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicker24hrV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTicker24hrV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker24hrV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getTicker24hrV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerBookTickerV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTickerBookTickerV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerBookTickerV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getTickerBookTickerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerPriceV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTickerPriceV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerPriceV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getTickerPriceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTimeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getTimeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTradeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getTradeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTradeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getTradeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradesV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradesV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {string} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTradesV1(timestamp: number, symbol?: string, pair?: string, orderId?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTradesV1(timestamp, symbol, pair, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.getUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatchOrdersV1(batchOrders: Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.updateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.updateListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrderV1(side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrderV1(side, symbol, timestamp, orderId, origClientOrderId, price, priceMatch, quantity, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinMarginedFuturesApi.updateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoinMarginedFuturesApi - factory interface
 * @export
 */
export const CoinMarginedFuturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoinMarginedFuturesApiFp(configuration)
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {CoinMarginedFuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1(requestParameters: CoinMarginedFuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>> {
            return localVarFp.createBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {CoinMarginedFuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1(requestParameters: CoinMarginedFuturesApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCountdownCancelAllV1Resp> {
            return localVarFp.createCountdownCancelAllV1(requestParameters.countdownTime, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {CoinMarginedFuturesApiCreateLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeverageV1(requestParameters: CoinMarginedFuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeverageV1Resp> {
            return localVarFp.createLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp> {
            return localVarFp.createListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {CoinMarginedFuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginTypeV1(requestParameters: CoinMarginedFuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginTypeV1Resp> {
            return localVarFp.createMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {CoinMarginedFuturesApiCreateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1(requestParameters: CoinMarginedFuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderV1Resp> {
            return localVarFp.createOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {CoinMarginedFuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionMarginV1(requestParameters: CoinMarginedFuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionMarginV1Resp> {
            return localVarFp.createPositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {CoinMarginedFuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionSideDualV1(requestParameters: CoinMarginedFuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionSideDualV1Resp> {
            return localVarFp.createPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {CoinMarginedFuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1(requestParameters: CoinMarginedFuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp> {
            return localVarFp.deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {CoinMarginedFuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1(requestParameters: CoinMarginedFuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>> {
            return localVarFp.deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {CoinMarginedFuturesApiDeleteOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1(requestParameters: CoinMarginedFuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp> {
            return localVarFp.deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information.
         * @summary Account Information (USER_DATA)
         * @param {CoinMarginedFuturesApiGetAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1(requestParameters: CoinMarginedFuturesApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV1Resp> {
            return localVarFp.getAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {CoinMarginedFuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdlQuantileV1(requestParameters: CoinMarginedFuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAdlQuantileV1RespItem>> {
            return localVarFp.getAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {CoinMarginedFuturesApiGetAggTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV1(requestParameters: CoinMarginedFuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAggTradesV1RespItem>> {
            return localVarFp.getAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {CoinMarginedFuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV1(requestParameters: CoinMarginedFuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV1RespItem>> {
            return localVarFp.getAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check futures account balance
         * @summary Futures Account Balance (USER_DATA)
         * @param {CoinMarginedFuturesApiGetBalanceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV1(requestParameters: CoinMarginedFuturesApiGetBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV1RespItem>> {
            return localVarFp.getBalanceV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user commission rate
         * @summary User Commission Rate (USER_DATA)
         * @param {CoinMarginedFuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommissionRateV1(requestParameters: CoinMarginedFuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCommissionRateV1Resp> {
            return localVarFp.getCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {CoinMarginedFuturesApiGetConstituentsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstituentsV1(requestParameters: CoinMarginedFuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConstituentsV1Resp> {
            return localVarFp.getConstituentsV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {CoinMarginedFuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinuousKlinesV1(requestParameters: CoinMarginedFuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {CoinMarginedFuturesApiGetDepthV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1(requestParameters: CoinMarginedFuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp> {
            return localVarFp.getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetExchangeInfoV1Resp> {
            return localVarFp.getExchangeInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {CoinMarginedFuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForceOrdersV1(requestParameters: CoinMarginedFuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>> {
            return localVarFp.getForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.recvWindow, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingInfoV1RespItem>> {
            return localVarFp.getFundingInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {CoinMarginedFuturesApiGetFundingRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateV1(requestParameters: CoinMarginedFuturesApiGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingRateV1RespItem>> {
            return localVarFp.getFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query basis
         * @summary Basis
         * @param {CoinMarginedFuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataBasis(requestParameters: CoinMarginedFuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataBasisRespItem>> {
            return localVarFp.getFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataGlobalLongShortAccountRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>> {
            return localVarFp.getFuturesDataGlobalLongShortAccountRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {CoinMarginedFuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataOpenInterestHist(requestParameters: CoinMarginedFuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>> {
            return localVarFp.getFuturesDataOpenInterestHist(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {CoinMarginedFuturesApiGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTakerBuySellVol(requestParameters: CoinMarginedFuturesApiGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTakerBuySellVolRespItem>> {
            return localVarFp.getFuturesDataTakerBuySellVol(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortAccountRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>> {
            return localVarFp.getFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortPositionRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>> {
            return localVarFp.getFuturesDataTopLongShortPositionRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {CoinMarginedFuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1(requestParameters: CoinMarginedFuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>> {
            return localVarFp.getHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {CoinMarginedFuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1(requestParameters: CoinMarginedFuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp> {
            return localVarFp.getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {CoinMarginedFuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1(requestParameters: CoinMarginedFuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp> {
            return localVarFp.getIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get income history
         * @summary Get Income History(USER_DATA)
         * @param {CoinMarginedFuturesApiGetIncomeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeV1(requestParameters: CoinMarginedFuturesApiGetIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIncomeV1RespItem>> {
            return localVarFp.getIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {CoinMarginedFuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexPriceKlinesV1(requestParameters: CoinMarginedFuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {CoinMarginedFuturesApiGetKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1(requestParameters: CoinMarginedFuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Not recommended to continue using this v1 endpoint
         * @summary Notional Bracket for Pair(USER_DATA)
         * @param {CoinMarginedFuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV1(requestParameters: CoinMarginedFuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeverageBracketV1RespItem>> {
            return localVarFp.getLeverageBracketV1(requestParameters.timestamp, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the symbol\'s notional bracket list.
         * @summary Notional Bracket for Symbol(USER_DATA)
         * @param {CoinMarginedFuturesApiGetLeverageBracketV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV2(requestParameters: CoinMarginedFuturesApiGetLeverageBracketV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeverageBracketV2RespItem>> {
            return localVarFp.getLeverageBracketV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {CoinMarginedFuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkPriceKlinesV1(requestParameters: CoinMarginedFuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {CoinMarginedFuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1(requestParameters: CoinMarginedFuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenInterestV1Resp> {
            return localVarFp.getOpenInterestV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {CoinMarginedFuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderV1(requestParameters: CoinMarginedFuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenOrderV1Resp> {
            return localVarFp.getOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {CoinMarginedFuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1(requestParameters: CoinMarginedFuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>> {
            return localVarFp.getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {CoinMarginedFuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAmendmentV1(requestParameters: CoinMarginedFuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOrderAmendmentV1RespItem>> {
            return localVarFp.getOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {CoinMarginedFuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynIdV1(requestParameters: CoinMarginedFuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynIdV1Resp> {
            return localVarFp.getOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {CoinMarginedFuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynV1(requestParameters: CoinMarginedFuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynV1Resp> {
            return localVarFp.getOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {CoinMarginedFuturesApiGetOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1(requestParameters: CoinMarginedFuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp> {
            return localVarFp.getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {CoinMarginedFuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmAccountInfoV1(requestParameters: CoinMarginedFuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPmAccountInfoV1Resp> {
            return localVarFp.getPmAccountInfoV1(requestParameters.asset, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {CoinMarginedFuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionMarginHistoryV1(requestParameters: CoinMarginedFuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>> {
            return localVarFp.getPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {CoinMarginedFuturesApiGetPositionRiskV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV1(requestParameters: CoinMarginedFuturesApiGetPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV1RespItem>> {
            return localVarFp.getPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {CoinMarginedFuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionSideDualV1(requestParameters: CoinMarginedFuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPositionSideDualV1Resp> {
            return localVarFp.getPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {CoinMarginedFuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexKlinesV1(requestParameters: CoinMarginedFuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {CoinMarginedFuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexV1(requestParameters: CoinMarginedFuturesApiGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPremiumIndexV1RespItem>> {
            return localVarFp.getPremiumIndexV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {CoinMarginedFuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV1(requestParameters: CoinMarginedFuturesApiGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTicker24hrV1RespItem>> {
            return localVarFp.getTicker24hrV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {CoinMarginedFuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV1(requestParameters: CoinMarginedFuturesApiGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerBookTickerV1RespItem>> {
            return localVarFp.getTickerBookTickerV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {CoinMarginedFuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV1(requestParameters: CoinMarginedFuturesApiGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerPriceV1RespItem>> {
            return localVarFp.getTickerPriceV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp> {
            return localVarFp.getTimeV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {CoinMarginedFuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynIdV1(requestParameters: CoinMarginedFuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynIdV1Resp> {
            return localVarFp.getTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {CoinMarginedFuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynV1(requestParameters: CoinMarginedFuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynV1Resp> {
            return localVarFp.getTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {CoinMarginedFuturesApiGetTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1(requestParameters: CoinMarginedFuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>> {
            return localVarFp.getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {CoinMarginedFuturesApiGetUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1(requestParameters: CoinMarginedFuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>> {
            return localVarFp.getUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {CoinMarginedFuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchOrdersV1(requestParameters: CoinMarginedFuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>> {
            return localVarFp.updateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {CoinMarginedFuturesApiUpdateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderV1(requestParameters: CoinMarginedFuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderV1Resp> {
            return localVarFp.updateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoinMarginedFuturesApi - interface
 * @export
 * @interface CoinMarginedFuturesApi
 */
export interface CoinMarginedFuturesApiInterface {
    /**
     * Place multiple orders
     * @summary Place Multiple Orders(TRADE)
     * @param {CoinMarginedFuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    createBatchOrdersV1(requestParameters: CoinMarginedFuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>>;

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {CoinMarginedFuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    createCountdownCancelAllV1(requestParameters: CoinMarginedFuturesApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCountdownCancelAllV1Resp>;

    /**
     * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
     * @summary Change Initial Leverage (TRADE)
     * @param {CoinMarginedFuturesApiCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    createLeverageV1(requestParameters: CoinMarginedFuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeverageV1Resp>;

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp>;

    /**
     * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
     * @summary Change Margin Type (TRADE)
     * @param {CoinMarginedFuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    createMarginTypeV1(requestParameters: CoinMarginedFuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginTypeV1Resp>;

    /**
     * Send in a new order.
     * @summary New Order (TRADE)
     * @param {CoinMarginedFuturesApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    createOrderV1(requestParameters: CoinMarginedFuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderV1Resp>;

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {CoinMarginedFuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    createPositionMarginV1(requestParameters: CoinMarginedFuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionMarginV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {CoinMarginedFuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    createPositionSideDualV1(requestParameters: CoinMarginedFuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionSideDualV1Resp>;

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders(TRADE)
     * @param {CoinMarginedFuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    deleteAllOpenOrdersV1(requestParameters: CoinMarginedFuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp>;

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders(TRADE)
     * @param {CoinMarginedFuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    deleteBatchOrdersV1(requestParameters: CoinMarginedFuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>>;

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream(USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {CoinMarginedFuturesApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    deleteOrderV1(requestParameters: CoinMarginedFuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp>;

    /**
     * Get current account information.
     * @summary Account Information (USER_DATA)
     * @param {CoinMarginedFuturesApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getAccountV1(requestParameters: CoinMarginedFuturesApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV1Resp>;

    /**
     * Query position ADL quantile estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {CoinMarginedFuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getAdlQuantileV1(requestParameters: CoinMarginedFuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAdlQuantileV1RespItem>>;

    /**
     * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {CoinMarginedFuturesApiGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getAggTradesV1(requestParameters: CoinMarginedFuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAggTradesV1RespItem>>;

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {CoinMarginedFuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getAllOrdersV1(requestParameters: CoinMarginedFuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV1RespItem>>;

    /**
     * Check futures account balance
     * @summary Futures Account Balance (USER_DATA)
     * @param {CoinMarginedFuturesApiGetBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getBalanceV1(requestParameters: CoinMarginedFuturesApiGetBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV1RespItem>>;

    /**
     * Query user commission rate
     * @summary User Commission Rate (USER_DATA)
     * @param {CoinMarginedFuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getCommissionRateV1(requestParameters: CoinMarginedFuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCommissionRateV1Resp>;

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {CoinMarginedFuturesApiGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getConstituentsV1(requestParameters: CoinMarginedFuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConstituentsV1Resp>;

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {CoinMarginedFuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getContinuousKlinesV1(requestParameters: CoinMarginedFuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query orderbook on specific symbol
     * @summary Order Book
     * @param {CoinMarginedFuturesApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getDepthV1(requestParameters: CoinMarginedFuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp>;

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetExchangeInfoV1Resp>;

    /**
     * User\'s Force Orders
     * @summary User\'s Force Orders(USER_DATA)
     * @param {CoinMarginedFuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getForceOrdersV1(requestParameters: CoinMarginedFuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>>;

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingInfoV1RespItem>>;

    /**
     * Get Funding Rate History of Perpetual Futures
     * @summary Get Funding Rate History of Perpetual Futures
     * @param {CoinMarginedFuturesApiGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getFundingRateV1(requestParameters: CoinMarginedFuturesApiGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingRateV1RespItem>>;

    /**
     * Query basis
     * @summary Basis
     * @param {CoinMarginedFuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getFuturesDataBasis(requestParameters: CoinMarginedFuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataBasisRespItem>>;

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getFuturesDataGlobalLongShortAccountRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>>;

    /**
     * Query open interest stats
     * @summary Open Interest Statistics
     * @param {CoinMarginedFuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getFuturesDataOpenInterestHist(requestParameters: CoinMarginedFuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>>;

    /**
     * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
     * @summary Taker Buy/Sell Volume
     * @param {CoinMarginedFuturesApiGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getFuturesDataTakerBuySellVol(requestParameters: CoinMarginedFuturesApiGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTakerBuySellVolRespItem>>;

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getFuturesDataTopLongShortAccountRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>>;

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getFuturesDataTopLongShortPositionRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>>;

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup(MARKET_DATA)
     * @param {CoinMarginedFuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getHistoricalTradesV1(requestParameters: CoinMarginedFuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>>;

    /**
     * Get futures transaction history download link by Id
     * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
     * @param {CoinMarginedFuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getIncomeAsynIdV1(requestParameters: CoinMarginedFuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp>;

    /**
     * Get download id for futures transaction history
     * @summary Get Download Id For Futures Transaction History(USER_DATA)
     * @param {CoinMarginedFuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getIncomeAsynV1(requestParameters: CoinMarginedFuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp>;

    /**
     * Get income history
     * @summary Get Income History(USER_DATA)
     * @param {CoinMarginedFuturesApiGetIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getIncomeV1(requestParameters: CoinMarginedFuturesApiGetIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIncomeV1RespItem>>;

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {CoinMarginedFuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getIndexPriceKlinesV1(requestParameters: CoinMarginedFuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {CoinMarginedFuturesApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getKlinesV1(requestParameters: CoinMarginedFuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Not recommended to continue using this v1 endpoint
     * @summary Notional Bracket for Pair(USER_DATA)
     * @param {CoinMarginedFuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getLeverageBracketV1(requestParameters: CoinMarginedFuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeverageBracketV1RespItem>>;

    /**
     * Get the symbol\'s notional bracket list.
     * @summary Notional Bracket for Symbol(USER_DATA)
     * @param {CoinMarginedFuturesApiGetLeverageBracketV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getLeverageBracketV2(requestParameters: CoinMarginedFuturesApiGetLeverageBracketV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeverageBracketV2RespItem>>;

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {CoinMarginedFuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getMarkPriceKlinesV1(requestParameters: CoinMarginedFuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {CoinMarginedFuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getOpenInterestV1(requestParameters: CoinMarginedFuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenInterestV1Resp>;

    /**
     * Query Current Open Order
     * @summary Query Current Open Order(USER_DATA)
     * @param {CoinMarginedFuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getOpenOrderV1(requestParameters: CoinMarginedFuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getOpenOrdersV1(requestParameters: CoinMarginedFuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getOrderAmendmentV1(requestParameters: CoinMarginedFuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOrderAmendmentV1RespItem>>;

    /**
     * Get futures order history download link by Id
     * @summary Get Futures Order History Download Link by Id (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getOrderAsynIdV1(requestParameters: CoinMarginedFuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynIdV1Resp>;

    /**
     * Get Download Id For Futures Order History
     * @summary Get Download Id For Futures Order History (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getOrderAsynV1(requestParameters: CoinMarginedFuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynV1Resp>;

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getOrderV1(requestParameters: CoinMarginedFuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Get Classic Portfolio Margin current account information.
     * @summary Classic Portfolio Margin Account Information (USER_DATA)
     * @param {CoinMarginedFuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getPmAccountInfoV1(requestParameters: CoinMarginedFuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPmAccountInfoV1Resp>;

    /**
     * Get position margin change history
     * @summary Get Position Margin Change History(TRADE)
     * @param {CoinMarginedFuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getPositionMarginHistoryV1(requestParameters: CoinMarginedFuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>>;

    /**
     * Get current account information.
     * @summary Position Information(USER_DATA)
     * @param {CoinMarginedFuturesApiGetPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getPositionRiskV1(requestParameters: CoinMarginedFuturesApiGetPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV1RespItem>>;

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Get Current Position Mode(USER_DATA)
     * @param {CoinMarginedFuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getPositionSideDualV1(requestParameters: CoinMarginedFuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPositionSideDualV1Resp>;

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {CoinMarginedFuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getPremiumIndexKlinesV1(requestParameters: CoinMarginedFuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query index price and mark price
     * @summary Index Price and Mark Price
     * @param {CoinMarginedFuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getPremiumIndexV1(requestParameters?: CoinMarginedFuturesApiGetPremiumIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPremiumIndexV1RespItem>>;

    /**
     * 24 hour rolling window price change statistics.
     * @summary 24hr Ticker Price Change Statistics
     * @param {CoinMarginedFuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getTicker24hrV1(requestParameters?: CoinMarginedFuturesApiGetTicker24hrV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTicker24hrV1RespItem>>;

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {CoinMarginedFuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getTickerBookTickerV1(requestParameters?: CoinMarginedFuturesApiGetTickerBookTickerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerBookTickerV1RespItem>>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {CoinMarginedFuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getTickerPriceV1(requestParameters?: CoinMarginedFuturesApiGetTickerPriceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerPriceV1RespItem>>;

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp>;

    /**
     * Get futures trade download link by Id
     * @summary Get Futures Trade Download Link by Id(USER_DATA)
     * @param {CoinMarginedFuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getTradeAsynIdV1(requestParameters: CoinMarginedFuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynIdV1Resp>;

    /**
     * Get download id for futures trade history
     * @summary Get Download Id For Futures Trade History (USER_DATA)
     * @param {CoinMarginedFuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getTradeAsynV1(requestParameters: CoinMarginedFuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynV1Resp>;

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {CoinMarginedFuturesApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getTradesV1(requestParameters: CoinMarginedFuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {CoinMarginedFuturesApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    getUserTradesV1(requestParameters: CoinMarginedFuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>>;

    /**
     * Modify Multiple Orders
     * @summary Modify Multiple Orders(TRADE)
     * @param {CoinMarginedFuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    updateBatchOrdersV1(requestParameters: CoinMarginedFuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>>;

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {CoinMarginedFuturesApiUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApiInterface
     */
    updateOrderV1(requestParameters: CoinMarginedFuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderV1Resp>;

}

/**
 * Request parameters for createBatchOrdersV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiCreateBatchOrdersV1Request
 */
export interface CoinMarginedFuturesApiCreateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>}
     * @memberof CoinMarginedFuturesApiCreateBatchOrdersV1
     */
    readonly batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createCountdownCancelAllV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiCreateCountdownCancelAllV1Request
 */
export interface CoinMarginedFuturesApiCreateCountdownCancelAllV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateCountdownCancelAllV1
     */
    readonly countdownTime: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateCountdownCancelAllV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateCountdownCancelAllV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateCountdownCancelAllV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createLeverageV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiCreateLeverageV1Request
 */
export interface CoinMarginedFuturesApiCreateLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginTypeV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiCreateMarginTypeV1Request
 */
export interface CoinMarginedFuturesApiCreateMarginTypeV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateMarginTypeV1
     */
    readonly marginType: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateMarginTypeV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateMarginTypeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateMarginTypeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createOrderV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiCreateOrderV1Request
 */
export interface CoinMarginedFuturesApiCreateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreateOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for createPositionMarginV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiCreatePositionMarginV1Request
 */
export interface CoinMarginedFuturesApiCreatePositionMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreatePositionMarginV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreatePositionMarginV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreatePositionMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreatePositionMarginV1
     */
    readonly type: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreatePositionMarginV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreatePositionMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createPositionSideDualV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiCreatePositionSideDualV1Request
 */
export interface CoinMarginedFuturesApiCreatePositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiCreatePositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreatePositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiCreatePositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteAllOpenOrdersV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiDeleteAllOpenOrdersV1Request
 */
export interface CoinMarginedFuturesApiDeleteAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiDeleteAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiDeleteAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiDeleteAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteBatchOrdersV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiDeleteBatchOrdersV1Request
 */
export interface CoinMarginedFuturesApiDeleteBatchOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * max length 10 &lt;br/&gt; e.g. [1234567,2345678]
     * @type {Array<number>}
     * @memberof CoinMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly orderIdList?: Array<number>

    /**
     * max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
     * @type {Array<string>}
     * @memberof CoinMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly origClientOrderIdList?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteOrderV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiDeleteOrderV1Request
 */
export interface CoinMarginedFuturesApiDeleteOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiDeleteOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiDeleteOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiDeleteOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiDeleteOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiDeleteOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetAccountV1Request
 */
export interface CoinMarginedFuturesApiGetAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAdlQuantileV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetAdlQuantileV1Request
 */
export interface CoinMarginedFuturesApiGetAdlQuantileV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAdlQuantileV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetAdlQuantileV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAdlQuantileV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAggTradesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetAggTradesV1Request
 */
export interface CoinMarginedFuturesApiGetAggTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetAggTradesV1
     */
    readonly symbol: string

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAggTradesV1
     */
    readonly fromId?: number

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAggTradesV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAggTradesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAggTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getAllOrdersV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetAllOrdersV1Request
 */
export interface CoinMarginedFuturesApiGetAllOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetAllOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetAllOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBalanceV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetBalanceV1Request
 */
export interface CoinMarginedFuturesApiGetBalanceV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetBalanceV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetBalanceV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCommissionRateV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetCommissionRateV1Request
 */
export interface CoinMarginedFuturesApiGetCommissionRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetCommissionRateV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetCommissionRateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetCommissionRateV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getConstituentsV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetConstituentsV1Request
 */
export interface CoinMarginedFuturesApiGetConstituentsV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetConstituentsV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getContinuousKlinesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetContinuousKlinesV1Request
 */
export interface CoinMarginedFuturesApiGetContinuousKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly contractType: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getDepthV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetDepthV1Request
 */
export interface CoinMarginedFuturesApiGetDepthV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetDepthV1
     */
    readonly symbol: string

    /**
     * Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetDepthV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getForceOrdersV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetForceOrdersV1Request
 */
export interface CoinMarginedFuturesApiGetForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetForceOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetForceOrdersV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetForceOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetForceOrdersV1
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFundingRateV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetFundingRateV1Request
 */
export interface CoinMarginedFuturesApiGetFundingRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFundingRateV1
     */
    readonly symbol: string

    /**
     * Timestamp in ms to get funding rate from INCLUSIVE.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFundingRateV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding rate  until INCLUSIVE.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFundingRateV1
     */
    readonly endTime?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFundingRateV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getFuturesDataBasis operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetFuturesDataBasisRequest
 */
export interface CoinMarginedFuturesApiGetFuturesDataBasisRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataBasis
     */
    readonly pair: string

    /**
     * CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataBasis
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataBasis
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataBasis
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataBasis
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataBasis
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataGlobalLongShortAccountRatio operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest
 */
export interface CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly pair: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataOpenInterestHist operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetFuturesDataOpenInterestHistRequest
 */
export interface CoinMarginedFuturesApiGetFuturesDataOpenInterestHistRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly pair: string

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTakerBuySellVol operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetFuturesDataTakerBuySellVolRequest
 */
export interface CoinMarginedFuturesApiGetFuturesDataTakerBuySellVolRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly pair: string

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTakerBuySellVol
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTopLongShortAccountRatio operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest
 */
export interface CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTopLongShortPositionRatio operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest
 */
export interface CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly pair: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getHistoricalTradesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetHistoricalTradesV1Request
 */
export interface CoinMarginedFuturesApiGetHistoricalTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetHistoricalTradesV1
     */
    readonly symbol: string

    /**
     * Default 100; max 500.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetHistoricalTradesV1
     */
    readonly limit?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetHistoricalTradesV1
     */
    readonly fromId?: number
}

/**
 * Request parameters for getIncomeAsynIdV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetIncomeAsynIdV1Request
 */
export interface CoinMarginedFuturesApiGetIncomeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetIncomeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIncomeAsynV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetIncomeAsynV1Request
 */
export interface CoinMarginedFuturesApiGetIncomeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIncomeV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetIncomeV1Request
 */
export interface CoinMarginedFuturesApiGetIncomeV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetIncomeV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetIncomeV1
     */
    readonly incomeType?: string

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeV1
     */
    readonly page?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIncomeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIndexPriceKlinesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetIndexPriceKlinesV1Request
 */
export interface CoinMarginedFuturesApiGetIndexPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getKlinesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetKlinesV1Request
 */
export interface CoinMarginedFuturesApiGetKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getLeverageBracketV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetLeverageBracketV1Request
 */
export interface CoinMarginedFuturesApiGetLeverageBracketV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetLeverageBracketV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetLeverageBracketV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetLeverageBracketV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getLeverageBracketV2 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetLeverageBracketV2Request
 */
export interface CoinMarginedFuturesApiGetLeverageBracketV2Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetLeverageBracketV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetLeverageBracketV2
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetLeverageBracketV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarkPriceKlinesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetMarkPriceKlinesV1Request
 */
export interface CoinMarginedFuturesApiGetMarkPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getOpenInterestV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetOpenInterestV1Request
 */
export interface CoinMarginedFuturesApiGetOpenInterestV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOpenInterestV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getOpenOrderV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetOpenOrderV1Request
 */
export interface CoinMarginedFuturesApiGetOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenOrdersV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetOpenOrdersV1Request
 */
export interface CoinMarginedFuturesApiGetOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOpenOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAmendmentV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetOrderAmendmentV1Request
 */
export interface CoinMarginedFuturesApiGetOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAsynIdV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetOrderAsynIdV1Request
 */
export interface CoinMarginedFuturesApiGetOrderAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOrderAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAsynV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetOrderAsynV1Request
 */
export interface CoinMarginedFuturesApiGetOrderAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetOrderV1Request
 */
export interface CoinMarginedFuturesApiGetOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPmAccountInfoV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetPmAccountInfoV1Request
 */
export interface CoinMarginedFuturesApiGetPmAccountInfoV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetPmAccountInfoV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPmAccountInfoV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionMarginHistoryV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetPositionMarginHistoryV1Request
 */
export interface CoinMarginedFuturesApiGetPositionMarginHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly timestamp: number

    /**
     * 1: Add position margin,2: Reduce position margin
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly type?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly endTime?: number

    /**
     * Default: 50
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionRiskV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetPositionRiskV1Request
 */
export interface CoinMarginedFuturesApiGetPositionRiskV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionRiskV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetPositionRiskV1
     */
    readonly marginAsset?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetPositionRiskV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionRiskV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionSideDualV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetPositionSideDualV1Request
 */
export interface CoinMarginedFuturesApiGetPositionSideDualV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPremiumIndexKlinesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetPremiumIndexKlinesV1Request
 */
export interface CoinMarginedFuturesApiGetPremiumIndexKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getPremiumIndexV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetPremiumIndexV1Request
 */
export interface CoinMarginedFuturesApiGetPremiumIndexV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetPremiumIndexV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetPremiumIndexV1
     */
    readonly pair?: string
}

/**
 * Request parameters for getTicker24hrV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetTicker24hrV1Request
 */
export interface CoinMarginedFuturesApiGetTicker24hrV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetTicker24hrV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetTicker24hrV1
     */
    readonly pair?: string
}

/**
 * Request parameters for getTickerBookTickerV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetTickerBookTickerV1Request
 */
export interface CoinMarginedFuturesApiGetTickerBookTickerV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetTickerBookTickerV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetTickerBookTickerV1
     */
    readonly pair?: string
}

/**
 * Request parameters for getTickerPriceV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetTickerPriceV1Request
 */
export interface CoinMarginedFuturesApiGetTickerPriceV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetTickerPriceV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetTickerPriceV1
     */
    readonly pair?: string
}

/**
 * Request parameters for getTradeAsynIdV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetTradeAsynIdV1Request
 */
export interface CoinMarginedFuturesApiGetTradeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetTradeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetTradeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetTradeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTradeAsynV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetTradeAsynV1Request
 */
export interface CoinMarginedFuturesApiGetTradeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetTradeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetTradeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetTradeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetTradeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTradesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetTradesV1Request
 */
export interface CoinMarginedFuturesApiGetTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetTradesV1
     */
    readonly symbol: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getUserTradesV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiGetUserTradesV1Request
 */
export interface CoinMarginedFuturesApiGetUserTradesV1Request {
    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly pair?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly orderId?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 50; max 1000
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiGetUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateBatchOrdersV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiUpdateBatchOrdersV1Request
 */
export interface CoinMarginedFuturesApiUpdateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>}
     * @memberof CoinMarginedFuturesApiUpdateBatchOrdersV1
     */
    readonly batchOrders: Array<CmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiUpdateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiUpdateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateOrderV1 operation in CoinMarginedFuturesApi.
 * @export
 * @interface CoinMarginedFuturesApiUpdateOrderV1Request
 */
export interface CoinMarginedFuturesApiUpdateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof CoinMarginedFuturesApiUpdateOrderV1
     */
    readonly recvWindow?: number
}

/**
 * CoinMarginedFuturesApi - object-oriented interface
 * @export
 * @class CoinMarginedFuturesApi
 * @extends {BaseAPI}
 */
export class CoinMarginedFuturesApi extends BaseAPI implements CoinMarginedFuturesApiInterface {
    /**
     * Place multiple orders
     * @summary Place Multiple Orders(TRADE)
     * @param {CoinMarginedFuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public createBatchOrdersV1(requestParameters: CoinMarginedFuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).createBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {CoinMarginedFuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public createCountdownCancelAllV1(requestParameters: CoinMarginedFuturesApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).createCountdownCancelAllV1(requestParameters.countdownTime, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
     * @summary Change Initial Leverage (TRADE)
     * @param {CoinMarginedFuturesApiCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public createLeverageV1(requestParameters: CoinMarginedFuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).createLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public createListenKeyV1(options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).createListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
     * @summary Change Margin Type (TRADE)
     * @param {CoinMarginedFuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public createMarginTypeV1(requestParameters: CoinMarginedFuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).createMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new order.
     * @summary New Order (TRADE)
     * @param {CoinMarginedFuturesApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public createOrderV1(requestParameters: CoinMarginedFuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).createOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {CoinMarginedFuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public createPositionMarginV1(requestParameters: CoinMarginedFuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).createPositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {CoinMarginedFuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public createPositionSideDualV1(requestParameters: CoinMarginedFuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).createPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders(TRADE)
     * @param {CoinMarginedFuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public deleteAllOpenOrdersV1(requestParameters: CoinMarginedFuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders(TRADE)
     * @param {CoinMarginedFuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public deleteBatchOrdersV1(requestParameters: CoinMarginedFuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream(USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public deleteListenKeyV1(options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).deleteListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {CoinMarginedFuturesApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public deleteOrderV1(requestParameters: CoinMarginedFuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information.
     * @summary Account Information (USER_DATA)
     * @param {CoinMarginedFuturesApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getAccountV1(requestParameters: CoinMarginedFuturesApiGetAccountV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query position ADL quantile estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {CoinMarginedFuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getAdlQuantileV1(requestParameters: CoinMarginedFuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {CoinMarginedFuturesApiGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getAggTradesV1(requestParameters: CoinMarginedFuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {CoinMarginedFuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getAllOrdersV1(requestParameters: CoinMarginedFuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check futures account balance
     * @summary Futures Account Balance (USER_DATA)
     * @param {CoinMarginedFuturesApiGetBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getBalanceV1(requestParameters: CoinMarginedFuturesApiGetBalanceV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getBalanceV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user commission rate
     * @summary User Commission Rate (USER_DATA)
     * @param {CoinMarginedFuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getCommissionRateV1(requestParameters: CoinMarginedFuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {CoinMarginedFuturesApiGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getConstituentsV1(requestParameters: CoinMarginedFuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getConstituentsV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {CoinMarginedFuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getContinuousKlinesV1(requestParameters: CoinMarginedFuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query orderbook on specific symbol
     * @summary Order Book
     * @param {CoinMarginedFuturesApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getDepthV1(requestParameters: CoinMarginedFuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getExchangeInfoV1(options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getExchangeInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User\'s Force Orders
     * @summary User\'s Force Orders(USER_DATA)
     * @param {CoinMarginedFuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getForceOrdersV1(requestParameters: CoinMarginedFuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.recvWindow, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getFundingInfoV1(options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getFundingInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Funding Rate History of Perpetual Futures
     * @summary Get Funding Rate History of Perpetual Futures
     * @param {CoinMarginedFuturesApiGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getFundingRateV1(requestParameters: CoinMarginedFuturesApiGetFundingRateV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query basis
     * @summary Basis
     * @param {CoinMarginedFuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getFuturesDataBasis(requestParameters: CoinMarginedFuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getFuturesDataGlobalLongShortAccountRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getFuturesDataGlobalLongShortAccountRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query open interest stats
     * @summary Open Interest Statistics
     * @param {CoinMarginedFuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getFuturesDataOpenInterestHist(requestParameters: CoinMarginedFuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getFuturesDataOpenInterestHist(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
     * @summary Taker Buy/Sell Volume
     * @param {CoinMarginedFuturesApiGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getFuturesDataTakerBuySellVol(requestParameters: CoinMarginedFuturesApiGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getFuturesDataTakerBuySellVol(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getFuturesDataTopLongShortAccountRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getFuturesDataTopLongShortPositionRatio(requestParameters: CoinMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getFuturesDataTopLongShortPositionRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup(MARKET_DATA)
     * @param {CoinMarginedFuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getHistoricalTradesV1(requestParameters: CoinMarginedFuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures transaction history download link by Id
     * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
     * @param {CoinMarginedFuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getIncomeAsynIdV1(requestParameters: CoinMarginedFuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for futures transaction history
     * @summary Get Download Id For Futures Transaction History(USER_DATA)
     * @param {CoinMarginedFuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getIncomeAsynV1(requestParameters: CoinMarginedFuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get income history
     * @summary Get Income History(USER_DATA)
     * @param {CoinMarginedFuturesApiGetIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getIncomeV1(requestParameters: CoinMarginedFuturesApiGetIncomeV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {CoinMarginedFuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getIndexPriceKlinesV1(requestParameters: CoinMarginedFuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {CoinMarginedFuturesApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getKlinesV1(requestParameters: CoinMarginedFuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Not recommended to continue using this v1 endpoint
     * @summary Notional Bracket for Pair(USER_DATA)
     * @param {CoinMarginedFuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getLeverageBracketV1(requestParameters: CoinMarginedFuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getLeverageBracketV1(requestParameters.timestamp, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the symbol\'s notional bracket list.
     * @summary Notional Bracket for Symbol(USER_DATA)
     * @param {CoinMarginedFuturesApiGetLeverageBracketV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getLeverageBracketV2(requestParameters: CoinMarginedFuturesApiGetLeverageBracketV2Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getLeverageBracketV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {CoinMarginedFuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getMarkPriceKlinesV1(requestParameters: CoinMarginedFuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {CoinMarginedFuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getOpenInterestV1(requestParameters: CoinMarginedFuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getOpenInterestV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current Open Order
     * @summary Query Current Open Order(USER_DATA)
     * @param {CoinMarginedFuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getOpenOrderV1(requestParameters: CoinMarginedFuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getOpenOrdersV1(requestParameters: CoinMarginedFuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getOrderAmendmentV1(requestParameters: CoinMarginedFuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures order history download link by Id
     * @summary Get Futures Order History Download Link by Id (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getOrderAsynIdV1(requestParameters: CoinMarginedFuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Download Id For Futures Order History
     * @summary Get Download Id For Futures Order History (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getOrderAsynV1(requestParameters: CoinMarginedFuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {CoinMarginedFuturesApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getOrderV1(requestParameters: CoinMarginedFuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getPingV1(options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getPingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Classic Portfolio Margin current account information.
     * @summary Classic Portfolio Margin Account Information (USER_DATA)
     * @param {CoinMarginedFuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getPmAccountInfoV1(requestParameters: CoinMarginedFuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getPmAccountInfoV1(requestParameters.asset, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get position margin change history
     * @summary Get Position Margin Change History(TRADE)
     * @param {CoinMarginedFuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getPositionMarginHistoryV1(requestParameters: CoinMarginedFuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information.
     * @summary Position Information(USER_DATA)
     * @param {CoinMarginedFuturesApiGetPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getPositionRiskV1(requestParameters: CoinMarginedFuturesApiGetPositionRiskV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Get Current Position Mode(USER_DATA)
     * @param {CoinMarginedFuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getPositionSideDualV1(requestParameters: CoinMarginedFuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {CoinMarginedFuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getPremiumIndexKlinesV1(requestParameters: CoinMarginedFuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price and mark price
     * @summary Index Price and Mark Price
     * @param {CoinMarginedFuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getPremiumIndexV1(requestParameters: CoinMarginedFuturesApiGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getPremiumIndexV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics.
     * @summary 24hr Ticker Price Change Statistics
     * @param {CoinMarginedFuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getTicker24hrV1(requestParameters: CoinMarginedFuturesApiGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getTicker24hrV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {CoinMarginedFuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getTickerBookTickerV1(requestParameters: CoinMarginedFuturesApiGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getTickerBookTickerV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {CoinMarginedFuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getTickerPriceV1(requestParameters: CoinMarginedFuturesApiGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getTickerPriceV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getTimeV1(options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getTimeV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures trade download link by Id
     * @summary Get Futures Trade Download Link by Id(USER_DATA)
     * @param {CoinMarginedFuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getTradeAsynIdV1(requestParameters: CoinMarginedFuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for futures trade history
     * @summary Get Download Id For Futures Trade History (USER_DATA)
     * @param {CoinMarginedFuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getTradeAsynV1(requestParameters: CoinMarginedFuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {CoinMarginedFuturesApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getTradesV1(requestParameters: CoinMarginedFuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {CoinMarginedFuturesApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public getUserTradesV1(requestParameters: CoinMarginedFuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).getUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Multiple Orders
     * @summary Modify Multiple Orders(TRADE)
     * @param {CoinMarginedFuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public updateBatchOrdersV1(requestParameters: CoinMarginedFuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).updateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public updateListenKeyV1(options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).updateListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {CoinMarginedFuturesApiUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinMarginedFuturesApi
     */
    public updateOrderV1(requestParameters: CoinMarginedFuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig) {
        return CoinMarginedFuturesApiFp(this.configuration).updateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

