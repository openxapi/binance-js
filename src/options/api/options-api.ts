/* tslint:disable */
/* eslint-disable */
/**
 * Binance Options API
 * OpenAPI specification for Binance exchange - Options API
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CreateBlockOrderExecuteV1Resp } from '../model';
// @ts-ignore
import type { CreateCountdownCancelAllHeartBeatV1Resp } from '../model';
// @ts-ignore
import type { CreateCountdownCancelAllV1Resp } from '../model';
// @ts-ignore
import type { CreateListenKeyV1Resp } from '../model';
// @ts-ignore
import type { CreateMmpResetV1Resp } from '../model';
// @ts-ignore
import type { CreateMmpSetV1Resp } from '../model';
// @ts-ignore
import type { DeleteAllOpenOrdersByUnderlyingV1Resp } from '../model';
// @ts-ignore
import type { DeleteAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteOrderV1Resp } from '../model';
// @ts-ignore
import type { GetAccountV1Resp } from '../model';
// @ts-ignore
import type { GetBillV1RespItem } from '../model';
// @ts-ignore
import type { GetBlockOrderExecuteV1Resp } from '../model';
// @ts-ignore
import type { GetBlockOrderOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetBlockTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetBlockUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetCountdownCancelAllV1Resp } from '../model';
// @ts-ignore
import type { GetDepthV1Resp } from '../model';
// @ts-ignore
import type { GetExerciseHistoryV1RespItem } from '../model';
// @ts-ignore
import type { GetExerciseRecordV1RespItem } from '../model';
// @ts-ignore
import type { GetHistoricalTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetHistoryOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetIncomeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetIncomeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetIndexV1Resp } from '../model';
// @ts-ignore
import type { GetKlinesV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginAccountV1Resp } from '../model';
// @ts-ignore
import type { GetMarkV1RespItem } from '../model';
// @ts-ignore
import type { GetMmpV1Resp } from '../model';
// @ts-ignore
import type { GetOpenInterestV1RespItem } from '../model';
// @ts-ignore
import type { GetOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderV1Resp } from '../model';
// @ts-ignore
import type { GetPositionV1RespItem } from '../model';
// @ts-ignore
import type { GetTickerV1RespItem } from '../model';
// @ts-ignore
import type { GetTimeV1Resp } from '../model';
// @ts-ignore
import type { GetTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { OptionsCreateBatchOrdersV1ReqOrdersItem } from '../model';
// @ts-ignore
import type { OptionsCreateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { OptionsCreateOrderV1Resp } from '../model';
// @ts-ignore
import type { OptionsDeleteBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { OptionsGetExchangeInfoV1Resp } from '../model';
// @ts-ignore
import type { UpdateBlockOrderCreateV1Resp } from '../model';
/**
 * OptionsApi - axios parameter creator
 * @export
 */
export const OptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send multiple option orders.
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<OptionsCreateBatchOrdersV1ReqOrdersItem>} orders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1: async (orders: Array<OptionsCreateBatchOrdersV1ReqOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orders' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'orders', orders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (orders) {
                localVarFormParams.set('orders', orders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept a block trade order
         * @summary Accept Block Trade Order (TRADE)
         * @param {string} blockOrderMatchingKey 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockOrderExecuteV1: async (blockOrderMatchingKey: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockOrderMatchingKey' is not null or undefined
            assertParamExists('createBlockOrderExecuteV1', 'blockOrderMatchingKey', blockOrderMatchingKey)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createBlockOrderExecuteV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/block/order/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (blockOrderMatchingKey !== undefined) { 
                localVarFormParams.set('blockOrderMatchingKey', blockOrderMatchingKey as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint resets the time from which the countdown will begin to the time this messaged is received.  It should be called repeatedly as heartbeats.  Multiple heartbeats can be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in the underlyings parameter.
         * @summary Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)
         * @param {number} timestamp 
         * @param {string} underlyings 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllHeartBeatV1: async (timestamp: number, underlyings: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCountdownCancelAllHeartBeatV1', 'timestamp', timestamp)
            // verify required parameter 'underlyings' is not null or undefined
            assertParamExists('createCountdownCancelAllHeartBeatV1', 'underlyings', underlyings)
            const localVarPath = `/eapi/v1/countdownCancelAllHeartBeat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (underlyings !== undefined) { 
                localVarFormParams.set('underlyings', underlyings as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sets the parameters of the auto-cancel feature which cancels all open orders (both market maker protection and non market maker protection order types) of the underlying symbol at the end of the specified countdown time period if no heartbeat message is sent.  After the countdown time period, all open orders will be cancelled and new orders will be rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel feature is turned off by setting countdownTime to 0.
         * @summary Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
         * @param {number} countdownTime 
         * @param {number} timestamp 
         * @param {string} underlying 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1: async (countdownTime: number, timestamp: number, underlying: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countdownTime' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'countdownTime', countdownTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'timestamp', timestamp)
            // verify required parameter 'underlying' is not null or undefined
            assertParamExists('createCountdownCancelAllV1', 'underlying', underlying)
            const localVarPath = `/eapi/v1/countdownCancelAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (countdownTime !== undefined) { 
                localVarFormParams.set('countdownTime', countdownTime as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (underlying !== undefined) { 
                localVarFormParams.set('underlying', underlying as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset MMP, start MMP order again.
         * @summary Reset Market Maker Protection Config (TRADE)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {string} [underlying] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMmpResetV1: async (timestamp: number, recvWindow?: number, underlying?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMmpResetV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/mmpReset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (underlying !== undefined) { 
                localVarFormParams.set('underlying', underlying as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set config for MMP. Market Maker Protection(MMP) is a set of protection mechanism for option market maker, this mechanism is able to prevent mass trading in short period time. Once market maker\'s account branches the threshold, the Market Maker Protection will be triggered. When Market Maker Protection triggers, all the current MMP orders will be canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate market and modify order price.
         * @summary Set Market Maker Protection Config (TRADE)
         * @param {number} timestamp 
         * @param {string} [deltaLimit] 
         * @param {number} [frozenTimeInMilliseconds] 
         * @param {string} [qtyLimit] 
         * @param {number} [recvWindow] 
         * @param {string} [underlying] 
         * @param {number} [windowTimeInMilliseconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMmpSetV1: async (timestamp: number, deltaLimit?: string, frozenTimeInMilliseconds?: number, qtyLimit?: string, recvWindow?: number, underlying?: string, windowTimeInMilliseconds?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMmpSetV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/mmpSet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (deltaLimit !== undefined) { 
                localVarFormParams.set('deltaLimit', deltaLimit as any);
            }
    
            if (frozenTimeInMilliseconds !== undefined) { 
                localVarFormParams.set('frozenTimeInMilliseconds', frozenTimeInMilliseconds as any);
            }
    
            if (qtyLimit !== undefined) { 
                localVarFormParams.set('qtyLimit', qtyLimit as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (underlying !== undefined) { 
                localVarFormParams.set('underlying', underlying as any);
            }
    
            if (windowTimeInMilliseconds !== undefined) { 
                localVarFormParams.set('windowTimeInMilliseconds', windowTimeInMilliseconds as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a new order.
         * @summary New Order (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [clientOrderId] 
         * @param {boolean} [isMmp] 
         * @param {string} [newOrderRespType] 
         * @param {boolean} [postOnly] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {boolean} [reduceOnly] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1: async (quantity: string, side: string, symbol: string, timestamp: number, type: string, clientOrderId?: string, isMmp?: boolean, newOrderRespType?: string, postOnly?: boolean, price?: string, recvWindow?: number, reduceOnly?: boolean, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('createOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderV1', 'type', type)
            const localVarPath = `/eapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (clientOrderId !== undefined) { 
                localVarFormParams.set('clientOrderId', clientOrderId as any);
            }
    
            if (isMmp !== undefined) { 
                localVarFormParams.set('isMmp', isMmp as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (postOnly !== undefined) { 
                localVarFormParams.set('postOnly', postOnly as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all active orders on specified underlying.
         * @summary Cancel All Option Orders By Underlying (TRADE)
         * @param {string} underlying Option underlying, e.g BTCUSDT
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersByUnderlyingV1: async (underlying: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlying' is not null or undefined
            assertParamExists('deleteAllOpenOrdersByUnderlyingV1', 'underlying', underlying)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteAllOpenOrdersByUnderlyingV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/allOpenOrdersByUnderlying`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (underlying !== undefined) {
                localVarQueryParameter['underlying'] = underlying;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all active order on a symbol.
         * @summary Cancel all Option orders on specific symbol (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel multiple orders.
         * @summary Cancel Multiple Option Orders (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {Array<number>} [orderIds] Order ID, e.g [4611875134427365377,4611875134427365378]
         * @param {Array<string>} [clientOrderIds] User-defined order ID, e.g [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;]
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1: async (symbol: string, timestamp: number, orderIds?: Array<number>, clientOrderIds?: Array<string>, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds;
            }

            if (clientOrderIds) {
                localVarQueryParameter['clientOrderIds'] = clientOrderIds;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel Option Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [orderId] Order ID, e.g 4611875134427365377
         * @param {string} [clientOrderId] User-defined order ID, e.g 10000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1: async (symbol: string, timestamp: number, orderId?: number, clientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteOrderV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (clientOrderId !== undefined) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information.
         * @summary Option Account Information(TRADE)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account funding flows.
         * @summary Account Funding Flow (USER_DATA)
         * @param {string} currency Asset type, only support USDT  as of now
         * @param {number} timestamp 
         * @param {number} [recordId] Return the recordId and subsequent data, the latest data is returned by default, e.g 100000
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillV1: async (currency: string, timestamp: number, recordId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('getBillV1', 'currency', currency)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBillV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/bill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (recordId !== undefined) {
                localVarQueryParameter['recordId'] = recordId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query block trade details; returns block trade details from counterparty\'s perspective.
         * @summary Query Block Trade Details (USER_DATA)
         * @param {string} blockOrderMatchingKey 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockOrderExecuteV1: async (blockOrderMatchingKey: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockOrderMatchingKey' is not null or undefined
            assertParamExists('getBlockOrderExecuteV1', 'blockOrderMatchingKey', blockOrderMatchingKey)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBlockOrderExecuteV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/block/order/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (blockOrderMatchingKey !== undefined) {
                localVarQueryParameter['blockOrderMatchingKey'] = blockOrderMatchingKey;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check block trade order status.
         * @summary Query Block Trade Order (TRADE)
         * @param {number} timestamp 
         * @param {string} [blockOrderMatchingKey] If specified, returns the specific block trade associated with the blockOrderMatchingKey
         * @param {number} [endTime] 
         * @param {number} [startTime] 
         * @param {string} [underlying] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockOrderOrdersV1: async (timestamp: number, blockOrderMatchingKey?: string, endTime?: number, startTime?: number, underlying?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBlockOrderOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/block/order/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (blockOrderMatchingKey !== undefined) {
                localVarQueryParameter['blockOrderMatchingKey'] = blockOrderMatchingKey;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (underlying !== undefined) {
                localVarQueryParameter['underlying'] = underlying;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent block trades
         * @summary Recent Block Trades List
         * @param {string} [symbol] Option trading pair, e.g. BTC-200730-9000-C
         * @param {number} [limit] Number of records; Default: 100 and Max: 500
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTradesV1: async (symbol?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/blockTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets block trades for a specific account.
         * @summary Account Block Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [endTime] 
         * @param {number} [startTime] 
         * @param {string} [underlying] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockUserTradesV1: async (timestamp: number, endTime?: number, startTime?: number, underlying?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBlockUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/block/user-trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (underlying !== undefined) {
                localVarQueryParameter['underlying'] = underlying;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the auto-cancel parameters for each underlying symbol. Note only active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie. countdownTime has been turned off), the underlying symbol and corresponding countdownTime parameter will not be returned in the response.
         * @summary Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
         * @param {number} timestamp 
         * @param {string} [underlying] Option underlying, e.g BTCUSDT
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountdownCancelAllV1: async (timestamp: number, underlying?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCountdownCancelAllV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/countdownCancelAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (underlying !== undefined) {
                localVarQueryParameter['underlying'] = underlying;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check orderbook depth on specific symbol
         * @summary Order Book
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [limit] Default:100 Max:1000.Optional value:[10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getDepthV1', 'symbol', symbol)
            const localVarPath = `/eapi/v1/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical exercise records.
         * @summary Historical Exercise Records
         * @param {string} [underlying] Underlying index like BTCUSDT
         * @param {number} [startTime] Start Time
         * @param {number} [endTime] End Time
         * @param {number} [limit] Number of records Default:100 Max:100
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseHistoryV1: async (underlying?: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/exerciseHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (underlying !== undefined) {
                localVarQueryParameter['underlying'] = underlying;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account exercise records.
         * @summary User Exercise Record (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {number} [limit] default 1000, max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseRecordV1: async (timestamp: number, symbol?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getExerciseRecordV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/exerciseRecord`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [fromId] The UniqueId ID from which to return. The latest deal record is returned by default
         * @param {number} [limit] Number of records Default:100 Max:500
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1: async (symbol: string, fromId?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getHistoricalTradesV1', 'symbol', symbol)
            const localVarPath = `/eapi/v1/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
         * @summary Query Option Order History (TRADE)
         * @param {string} symbol Option trading pair
         * @param {number} timestamp 
         * @param {number} [orderId] Returns the orderId and subsequent orders, the most recent order is returned by default
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getHistoryOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getHistoryOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/historyOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get option transaction history download Link by Id
         * @summary Get Option Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/income/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for option transaction history
         * @summary Get Download Id For Option Transaction History (USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/income/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get spot index price for option underlying.
         * @summary Symbol Price Ticker
         * @param {string} underlying Spot pair（Option contract underlying asset, e.g BTCUSDT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexV1: async (underlying: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlying' is not null or undefined
            assertParamExists('getIndexV1', 'underlying', underlying)
            const localVarPath = `/eapi/v1/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (underlying !== undefined) {
                localVarQueryParameter['underlying'] = underlying;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for an option symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {string} interval Time interval
         * @param {number} [startTime] Start Time  1592317127349
         * @param {number} [endTime] End Time
         * @param {number} [limit] Number of records Default:500 Max:1500
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getKlinesV1', 'interval', interval)
            const localVarPath = `/eapi/v1/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information.
         * @summary Option Margin Account Information (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginAccountV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/marginAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Option mark price and greek info.
         * @summary Option Mark Price
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/mark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get config for MMP.
         * @summary Get Market Maker Protection Config (TRADE)
         * @param {number} timestamp 
         * @param {string} [underlying] underlying, e.g BTCUSDT
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmpV1: async (timestamp: number, underlying?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMmpV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/mmp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (underlying !== undefined) {
                localVarQueryParameter['underlying'] = underlying;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get open interest for specific underlying asset on specific expiration date.
         * @summary Open Interest
         * @param {string} underlyingAsset underlying asset, e.g ETH/BTC
         * @param {string} expiration expiration date, e.g 221225
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1: async (underlyingAsset: string, expiration: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlyingAsset' is not null or undefined
            assertParamExists('getOpenInterestV1', 'underlyingAsset', underlyingAsset)
            // verify required parameter 'expiration' is not null or undefined
            assertParamExists('getOpenInterestV1', 'expiration', expiration)
            const localVarPath = `/eapi/v1/openInterest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (underlyingAsset !== undefined) {
                localVarQueryParameter['underlyingAsset'] = underlyingAsset;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
         * @summary Query Current Open Option Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] return all orders if don&amp;#39;t pass, Option trading pair, e.g BTC-200730-9000-C,
         * @param {number} [orderId] Returns the orderId and subsequent orders, the most recent order is returned by default
         * @param {number} [startTime] Start Time
         * @param {number} [endTime] End Time
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1: async (timestamp: number, symbol?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order status.
         * @summary Query Single Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [orderId] Order id
         * @param {string} [clientOrderId] User-defined order ID cannot be repeated in pending orders
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1: async (symbol: string, timestamp: number, orderId?: number, clientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (clientOrderId !== undefined) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current position information.
         * @summary Option Position Information (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/position`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/ticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [limit] Number of records Default:100 Max:500
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTradesV1', 'symbol', symbol)
            const localVarPath = `/eapi/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option symbol, e.g BTC-200730-9000-C
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades, e.g 4611875134427365376
         * @param {number} [startTime] Start time, e.g 1593511200000
         * @param {number} [endTime] End time, e.g 1593512200000
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1: async (timestamp: number, symbol?: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extends a block trade expire time by 30 mins from the current time.
         * @summary Extend Block Trade Order (TRADE)
         * @param {string} blockOrderMatchingKey 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlockOrderCreateV1: async (blockOrderMatchingKey: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockOrderMatchingKey' is not null or undefined
            assertParamExists('updateBlockOrderCreateV1', 'blockOrderMatchingKey', blockOrderMatchingKey)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateBlockOrderCreateV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/block/order/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (blockOrderMatchingKey !== undefined) { 
                localVarFormParams.set('blockOrderMatchingKey', blockOrderMatchingKey as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OptionsApi - functional programming interface
 * @export
 */
export const OptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Send multiple option orders.
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<OptionsCreateBatchOrdersV1ReqOrdersItem>} orders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchOrdersV1(orders: Array<OptionsCreateBatchOrdersV1ReqOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsCreateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchOrdersV1(orders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accept a block trade order
         * @summary Accept Block Trade Order (TRADE)
         * @param {string} blockOrderMatchingKey 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlockOrderExecuteV1(blockOrderMatchingKey: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBlockOrderExecuteV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBlockOrderExecuteV1(blockOrderMatchingKey, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createBlockOrderExecuteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint resets the time from which the countdown will begin to the time this messaged is received.  It should be called repeatedly as heartbeats.  Multiple heartbeats can be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in the underlyings parameter.
         * @summary Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)
         * @param {number} timestamp 
         * @param {string} underlyings 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCountdownCancelAllHeartBeatV1(timestamp: number, underlyings: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCountdownCancelAllHeartBeatV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCountdownCancelAllHeartBeatV1(timestamp, underlyings, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createCountdownCancelAllHeartBeatV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sets the parameters of the auto-cancel feature which cancels all open orders (both market maker protection and non market maker protection order types) of the underlying symbol at the end of the specified countdown time period if no heartbeat message is sent.  After the countdown time period, all open orders will be cancelled and new orders will be rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel feature is turned off by setting countdownTime to 0.
         * @summary Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
         * @param {number} countdownTime 
         * @param {number} timestamp 
         * @param {string} underlying 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCountdownCancelAllV1(countdownTime: number, timestamp: number, underlying: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCountdownCancelAllV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCountdownCancelAllV1(countdownTime, timestamp, underlying, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createCountdownCancelAllV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset MMP, start MMP order again.
         * @summary Reset Market Maker Protection Config (TRADE)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {string} [underlying] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMmpResetV1(timestamp: number, recvWindow?: number, underlying?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMmpResetV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMmpResetV1(timestamp, recvWindow, underlying, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createMmpResetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set config for MMP. Market Maker Protection(MMP) is a set of protection mechanism for option market maker, this mechanism is able to prevent mass trading in short period time. Once market maker\'s account branches the threshold, the Market Maker Protection will be triggered. When Market Maker Protection triggers, all the current MMP orders will be canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate market and modify order price.
         * @summary Set Market Maker Protection Config (TRADE)
         * @param {number} timestamp 
         * @param {string} [deltaLimit] 
         * @param {number} [frozenTimeInMilliseconds] 
         * @param {string} [qtyLimit] 
         * @param {number} [recvWindow] 
         * @param {string} [underlying] 
         * @param {number} [windowTimeInMilliseconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMmpSetV1(timestamp: number, deltaLimit?: string, frozenTimeInMilliseconds?: number, qtyLimit?: string, recvWindow?: number, underlying?: string, windowTimeInMilliseconds?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMmpSetV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMmpSetV1(timestamp, deltaLimit, frozenTimeInMilliseconds, qtyLimit, recvWindow, underlying, windowTimeInMilliseconds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createMmpSetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a new order.
         * @summary New Order (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [clientOrderId] 
         * @param {boolean} [isMmp] 
         * @param {string} [newOrderRespType] 
         * @param {boolean} [postOnly] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {boolean} [reduceOnly] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderV1(quantity: string, side: string, symbol: string, timestamp: number, type: string, clientOrderId?: string, isMmp?: boolean, newOrderRespType?: string, postOnly?: boolean, price?: string, recvWindow?: number, reduceOnly?: boolean, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsCreateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderV1(quantity, side, symbol, timestamp, type, clientOrderId, isMmp, newOrderRespType, postOnly, price, recvWindow, reduceOnly, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all active orders on specified underlying.
         * @summary Cancel All Option Orders By Underlying (TRADE)
         * @param {string} underlying Option underlying, e.g BTCUSDT
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllOpenOrdersByUnderlyingV1(underlying: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAllOpenOrdersByUnderlyingV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllOpenOrdersByUnderlyingV1(underlying, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.deleteAllOpenOrdersByUnderlyingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all active order on a symbol.
         * @summary Cancel all Option orders on specific symbol (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.deleteAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel multiple orders.
         * @summary Cancel Multiple Option Orders (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {Array<number>} [orderIds] Order ID, e.g [4611875134427365377,4611875134427365378]
         * @param {Array<string>} [clientOrderIds] User-defined order ID, e.g [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;]
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatchOrdersV1(symbol: string, timestamp: number, orderIds?: Array<number>, clientOrderIds?: Array<string>, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsDeleteBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatchOrdersV1(symbol, timestamp, orderIds, clientOrderIds, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.deleteBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.deleteListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel Option Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [orderId] Order ID, e.g 4611875134427365377
         * @param {string} [clientOrderId] User-defined order ID, e.g 10000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrderV1(symbol: string, timestamp: number, orderId?: number, clientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrderV1(symbol, timestamp, orderId, clientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.deleteOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information.
         * @summary Option Account Information(TRADE)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account funding flows.
         * @summary Account Funding Flow (USER_DATA)
         * @param {string} currency Asset type, only support USDT  as of now
         * @param {number} timestamp 
         * @param {number} [recordId] Return the recordId and subsequent data, the latest data is returned by default, e.g 100000
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBillV1(currency: string, timestamp: number, recordId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBillV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBillV1(currency, timestamp, recordId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getBillV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query block trade details; returns block trade details from counterparty\'s perspective.
         * @summary Query Block Trade Details (USER_DATA)
         * @param {string} blockOrderMatchingKey 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockOrderExecuteV1(blockOrderMatchingKey: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlockOrderExecuteV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockOrderExecuteV1(blockOrderMatchingKey, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getBlockOrderExecuteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check block trade order status.
         * @summary Query Block Trade Order (TRADE)
         * @param {number} timestamp 
         * @param {string} [blockOrderMatchingKey] If specified, returns the specific block trade associated with the blockOrderMatchingKey
         * @param {number} [endTime] 
         * @param {number} [startTime] 
         * @param {string} [underlying] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockOrderOrdersV1(timestamp: number, blockOrderMatchingKey?: string, endTime?: number, startTime?: number, underlying?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBlockOrderOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockOrderOrdersV1(timestamp, blockOrderMatchingKey, endTime, startTime, underlying, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getBlockOrderOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent block trades
         * @summary Recent Block Trades List
         * @param {string} [symbol] Option trading pair, e.g. BTC-200730-9000-C
         * @param {number} [limit] Number of records; Default: 100 and Max: 500
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockTradesV1(symbol?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBlockTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockTradesV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getBlockTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets block trades for a specific account.
         * @summary Account Block Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [endTime] 
         * @param {number} [startTime] 
         * @param {string} [underlying] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockUserTradesV1(timestamp: number, endTime?: number, startTime?: number, underlying?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBlockUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockUserTradesV1(timestamp, endTime, startTime, underlying, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getBlockUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns the auto-cancel parameters for each underlying symbol. Note only active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie. countdownTime has been turned off), the underlying symbol and corresponding countdownTime parameter will not be returned in the response.
         * @summary Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
         * @param {number} timestamp 
         * @param {string} [underlying] Option underlying, e.g BTCUSDT
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountdownCancelAllV1(timestamp: number, underlying?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCountdownCancelAllV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountdownCancelAllV1(timestamp, underlying, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getCountdownCancelAllV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check orderbook depth on specific symbol
         * @summary Order Book
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [limit] Default:100 Max:1000.Optional value:[10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepthV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDepthV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepthV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getDepthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsGetExchangeInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historical exercise records.
         * @summary Historical Exercise Records
         * @param {string} [underlying] Underlying index like BTCUSDT
         * @param {number} [startTime] Start Time
         * @param {number} [endTime] End Time
         * @param {number} [limit] Number of records Default:100 Max:100
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExerciseHistoryV1(underlying?: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetExerciseHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExerciseHistoryV1(underlying, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getExerciseHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account exercise records.
         * @summary User Exercise Record (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {number} [limit] default 1000, max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExerciseRecordV1(timestamp: number, symbol?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetExerciseRecordV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExerciseRecordV1(timestamp, symbol, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getExerciseRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [fromId] The UniqueId ID from which to return. The latest deal record is returned by default
         * @param {number} [limit] Number of records Default:100 Max:500
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTradesV1(symbol: string, fromId?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetHistoricalTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTradesV1(symbol, fromId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getHistoricalTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
         * @summary Query Option Order History (TRADE)
         * @param {string} symbol Option trading pair
         * @param {number} timestamp 
         * @param {number} [orderId] Returns the orderId and subsequent orders, the most recent order is returned by default
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoryOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetHistoryOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoryOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getHistoryOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get option transaction history download Link by Id
         * @summary Get Option Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getIncomeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for option transaction history
         * @summary Get Download Id For Option Transaction History (USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getIncomeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get spot index price for option underlying.
         * @summary Symbol Price Ticker
         * @param {string} underlying Spot pair（Option contract underlying asset, e.g BTCUSDT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndexV1(underlying: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIndexV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndexV1(underlying, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for an option symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {string} interval Time interval
         * @param {number} [startTime] Start Time  1592317127349
         * @param {number} [endTime] End Time
         * @param {number} [limit] Number of records Default:500 Max:1500
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetKlinesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information.
         * @summary Option Margin Account Information (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getMarginAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Option mark price and greek info.
         * @summary Option Mark Price
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarkV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarkV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarkV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getMarkV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get config for MMP.
         * @summary Get Market Maker Protection Config (TRADE)
         * @param {number} timestamp 
         * @param {string} [underlying] underlying, e.g BTCUSDT
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmpV1(timestamp: number, underlying?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMmpV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmpV1(timestamp, underlying, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getMmpV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get open interest for specific underlying asset on specific expiration date.
         * @summary Open Interest
         * @param {string} underlyingAsset underlying asset, e.g ETH/BTC
         * @param {string} expiration expiration date, e.g 221225
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenInterestV1(underlyingAsset: string, expiration: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOpenInterestV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenInterestV1(underlyingAsset, expiration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getOpenInterestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
         * @summary Query Current Open Option Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] return all orders if don&amp;#39;t pass, Option trading pair, e.g BTC-200730-9000-C,
         * @param {number} [orderId] Returns the orderId and subsequent orders, the most recent order is returned by default
         * @param {number} [startTime] Start Time
         * @param {number} [endTime] End Time
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrdersV1(timestamp: number, symbol?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrdersV1(timestamp, symbol, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order status.
         * @summary Query Single Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [orderId] Order id
         * @param {string} [clientOrderId] User-defined order ID cannot be repeated in pending orders
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderV1(symbol: string, timestamp: number, orderId?: number, clientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderV1(symbol, timestamp, orderId, clientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getPingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current position information.
         * @summary Option Position Information (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getPositionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTickerV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getTickerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTimeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getTimeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [limit] Number of records Default:100 Max:500
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradesV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradesV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option symbol, e.g BTC-200730-9000-C
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades, e.g 4611875134427365376
         * @param {number} [startTime] Start time, e.g 1593511200000
         * @param {number} [endTime] End time, e.g 1593512200000
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTradesV1(timestamp: number, symbol?: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTradesV1(timestamp, symbol, fromId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.getUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Extends a block trade expire time by 30 mins from the current time.
         * @summary Extend Block Trade Order (TRADE)
         * @param {string} blockOrderMatchingKey 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlockOrderCreateV1(blockOrderMatchingKey: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateBlockOrderCreateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBlockOrderCreateV1(blockOrderMatchingKey, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.updateBlockOrderCreateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.updateListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OptionsApi - factory interface
 * @export
 */
export const OptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OptionsApiFp(configuration)
    return {
        /**
         * Send multiple option orders.
         * @summary Place Multiple Orders(TRADE)
         * @param {OptionsApiCreateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1(requestParameters: OptionsApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsCreateBatchOrdersV1RespInner>> {
            return localVarFp.createBatchOrdersV1(requestParameters.orders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept a block trade order
         * @summary Accept Block Trade Order (TRADE)
         * @param {OptionsApiCreateBlockOrderExecuteV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockOrderExecuteV1(requestParameters: OptionsApiCreateBlockOrderExecuteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateBlockOrderExecuteV1Resp> {
            return localVarFp.createBlockOrderExecuteV1(requestParameters.blockOrderMatchingKey, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint resets the time from which the countdown will begin to the time this messaged is received.  It should be called repeatedly as heartbeats.  Multiple heartbeats can be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in the underlyings parameter.
         * @summary Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)
         * @param {OptionsApiCreateCountdownCancelAllHeartBeatV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllHeartBeatV1(requestParameters: OptionsApiCreateCountdownCancelAllHeartBeatV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCountdownCancelAllHeartBeatV1Resp> {
            return localVarFp.createCountdownCancelAllHeartBeatV1(requestParameters.timestamp, requestParameters.underlyings, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sets the parameters of the auto-cancel feature which cancels all open orders (both market maker protection and non market maker protection order types) of the underlying symbol at the end of the specified countdown time period if no heartbeat message is sent.  After the countdown time period, all open orders will be cancelled and new orders will be rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel feature is turned off by setting countdownTime to 0.
         * @summary Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
         * @param {OptionsApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1(requestParameters: OptionsApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCountdownCancelAllV1Resp> {
            return localVarFp.createCountdownCancelAllV1(requestParameters.countdownTime, requestParameters.timestamp, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp> {
            return localVarFp.createListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Reset MMP, start MMP order again.
         * @summary Reset Market Maker Protection Config (TRADE)
         * @param {OptionsApiCreateMmpResetV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMmpResetV1(requestParameters: OptionsApiCreateMmpResetV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMmpResetV1Resp> {
            return localVarFp.createMmpResetV1(requestParameters.timestamp, requestParameters.recvWindow, requestParameters.underlying, options).then((request) => request(axios, basePath));
        },
        /**
         * Set config for MMP. Market Maker Protection(MMP) is a set of protection mechanism for option market maker, this mechanism is able to prevent mass trading in short period time. Once market maker\'s account branches the threshold, the Market Maker Protection will be triggered. When Market Maker Protection triggers, all the current MMP orders will be canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate market and modify order price.
         * @summary Set Market Maker Protection Config (TRADE)
         * @param {OptionsApiCreateMmpSetV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMmpSetV1(requestParameters: OptionsApiCreateMmpSetV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMmpSetV1Resp> {
            return localVarFp.createMmpSetV1(requestParameters.timestamp, requestParameters.deltaLimit, requestParameters.frozenTimeInMilliseconds, requestParameters.qtyLimit, requestParameters.recvWindow, requestParameters.underlying, requestParameters.windowTimeInMilliseconds, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a new order.
         * @summary New Order (TRADE)
         * @param {OptionsApiCreateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1(requestParameters: OptionsApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsCreateOrderV1Resp> {
            return localVarFp.createOrderV1(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.clientOrderId, requestParameters.isMmp, requestParameters.newOrderRespType, requestParameters.postOnly, requestParameters.price, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all active orders on specified underlying.
         * @summary Cancel All Option Orders By Underlying (TRADE)
         * @param {OptionsApiDeleteAllOpenOrdersByUnderlyingV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersByUnderlyingV1(requestParameters: OptionsApiDeleteAllOpenOrdersByUnderlyingV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersByUnderlyingV1Resp> {
            return localVarFp.deleteAllOpenOrdersByUnderlyingV1(requestParameters.underlying, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all active order on a symbol.
         * @summary Cancel all Option orders on specific symbol (TRADE)
         * @param {OptionsApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1(requestParameters: OptionsApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp> {
            return localVarFp.deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel multiple orders.
         * @summary Cancel Multiple Option Orders (TRADE)
         * @param {OptionsApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1(requestParameters: OptionsApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsDeleteBatchOrdersV1RespInner>> {
            return localVarFp.deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIds, requestParameters.clientOrderIds, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel Option Order (TRADE)
         * @param {OptionsApiDeleteOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1(requestParameters: OptionsApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp> {
            return localVarFp.deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.clientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information.
         * @summary Option Account Information(TRADE)
         * @param {OptionsApiGetAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1(requestParameters: OptionsApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV1Resp> {
            return localVarFp.getAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account funding flows.
         * @summary Account Funding Flow (USER_DATA)
         * @param {OptionsApiGetBillV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillV1(requestParameters: OptionsApiGetBillV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBillV1RespItem>> {
            return localVarFp.getBillV1(requestParameters.currency, requestParameters.timestamp, requestParameters.recordId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query block trade details; returns block trade details from counterparty\'s perspective.
         * @summary Query Block Trade Details (USER_DATA)
         * @param {OptionsApiGetBlockOrderExecuteV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockOrderExecuteV1(requestParameters: OptionsApiGetBlockOrderExecuteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetBlockOrderExecuteV1Resp> {
            return localVarFp.getBlockOrderExecuteV1(requestParameters.blockOrderMatchingKey, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check block trade order status.
         * @summary Query Block Trade Order (TRADE)
         * @param {OptionsApiGetBlockOrderOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockOrderOrdersV1(requestParameters: OptionsApiGetBlockOrderOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBlockOrderOrdersV1RespItem>> {
            return localVarFp.getBlockOrderOrdersV1(requestParameters.timestamp, requestParameters.blockOrderMatchingKey, requestParameters.endTime, requestParameters.startTime, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent block trades
         * @summary Recent Block Trades List
         * @param {OptionsApiGetBlockTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTradesV1(requestParameters: OptionsApiGetBlockTradesV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBlockTradesV1RespItem>> {
            return localVarFp.getBlockTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets block trades for a specific account.
         * @summary Account Block Trade List (USER_DATA)
         * @param {OptionsApiGetBlockUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockUserTradesV1(requestParameters: OptionsApiGetBlockUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBlockUserTradesV1RespItem>> {
            return localVarFp.getBlockUserTradesV1(requestParameters.timestamp, requestParameters.endTime, requestParameters.startTime, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the auto-cancel parameters for each underlying symbol. Note only active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie. countdownTime has been turned off), the underlying symbol and corresponding countdownTime parameter will not be returned in the response.
         * @summary Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
         * @param {OptionsApiGetCountdownCancelAllV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountdownCancelAllV1(requestParameters: OptionsApiGetCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCountdownCancelAllV1Resp> {
            return localVarFp.getCountdownCancelAllV1(requestParameters.timestamp, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check orderbook depth on specific symbol
         * @summary Order Book
         * @param {OptionsApiGetDepthV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1(requestParameters: OptionsApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp> {
            return localVarFp.getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<OptionsGetExchangeInfoV1Resp> {
            return localVarFp.getExchangeInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get historical exercise records.
         * @summary Historical Exercise Records
         * @param {OptionsApiGetExerciseHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseHistoryV1(requestParameters: OptionsApiGetExerciseHistoryV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetExerciseHistoryV1RespItem>> {
            return localVarFp.getExerciseHistoryV1(requestParameters.underlying, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account exercise records.
         * @summary User Exercise Record (USER_DATA)
         * @param {OptionsApiGetExerciseRecordV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseRecordV1(requestParameters: OptionsApiGetExerciseRecordV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetExerciseRecordV1RespItem>> {
            return localVarFp.getExerciseRecordV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {OptionsApiGetHistoricalTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1(requestParameters: OptionsApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>> {
            return localVarFp.getHistoricalTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
         * @summary Query Option Order History (TRADE)
         * @param {OptionsApiGetHistoryOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryOrdersV1(requestParameters: OptionsApiGetHistoryOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoryOrdersV1RespItem>> {
            return localVarFp.getHistoryOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get option transaction history download Link by Id
         * @summary Get Option Transaction History Download Link by Id (USER_DATA)
         * @param {OptionsApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1(requestParameters: OptionsApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp> {
            return localVarFp.getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for option transaction history
         * @summary Get Download Id For Option Transaction History (USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1(options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp> {
            return localVarFp.getIncomeAsynV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get spot index price for option underlying.
         * @summary Symbol Price Ticker
         * @param {OptionsApiGetIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexV1(requestParameters: OptionsApiGetIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIndexV1Resp> {
            return localVarFp.getIndexV1(requestParameters.underlying, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for an option symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {OptionsApiGetKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1(requestParameters: OptionsApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetKlinesV1RespItem>> {
            return localVarFp.getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information.
         * @summary Option Margin Account Information (USER_DATA)
         * @param {OptionsApiGetMarginAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAccountV1(requestParameters: OptionsApiGetMarginAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginAccountV1Resp> {
            return localVarFp.getMarginAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Option mark price and greek info.
         * @summary Option Mark Price
         * @param {OptionsApiGetMarkV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkV1(requestParameters: OptionsApiGetMarkV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarkV1RespItem>> {
            return localVarFp.getMarkV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Get config for MMP.
         * @summary Get Market Maker Protection Config (TRADE)
         * @param {OptionsApiGetMmpV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmpV1(requestParameters: OptionsApiGetMmpV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMmpV1Resp> {
            return localVarFp.getMmpV1(requestParameters.timestamp, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get open interest for specific underlying asset on specific expiration date.
         * @summary Open Interest
         * @param {OptionsApiGetOpenInterestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1(requestParameters: OptionsApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenInterestV1RespItem>> {
            return localVarFp.getOpenInterestV1(requestParameters.underlyingAsset, requestParameters.expiration, options).then((request) => request(axios, basePath));
        },
        /**
         * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
         * @summary Query Current Open Option Orders (USER_DATA)
         * @param {OptionsApiGetOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1(requestParameters: OptionsApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>> {
            return localVarFp.getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order status.
         * @summary Query Single Order (TRADE)
         * @param {OptionsApiGetOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1(requestParameters: OptionsApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp> {
            return localVarFp.getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.clientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get current position information.
         * @summary Option Position Information (USER_DATA)
         * @param {OptionsApiGetPositionV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionV1(requestParameters: OptionsApiGetPositionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionV1RespItem>> {
            return localVarFp.getPositionV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {OptionsApiGetTickerV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerV1(requestParameters: OptionsApiGetTickerV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerV1RespItem>> {
            return localVarFp.getTickerV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp> {
            return localVarFp.getTimeV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {OptionsApiGetTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1(requestParameters: OptionsApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>> {
            return localVarFp.getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {OptionsApiGetUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1(requestParameters: OptionsApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>> {
            return localVarFp.getUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Extends a block trade expire time by 30 mins from the current time.
         * @summary Extend Block Trade Order (TRADE)
         * @param {OptionsApiUpdateBlockOrderCreateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlockOrderCreateV1(requestParameters: OptionsApiUpdateBlockOrderCreateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateBlockOrderCreateV1Resp> {
            return localVarFp.updateBlockOrderCreateV1(requestParameters.blockOrderMatchingKey, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateListenKeyV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OptionsApi - interface
 * @export
 * @interface OptionsApi
 */
export interface OptionsApiInterface {
    /**
     * Send multiple option orders.
     * @summary Place Multiple Orders(TRADE)
     * @param {OptionsApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    createBatchOrdersV1(requestParameters: OptionsApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsCreateBatchOrdersV1RespInner>>;

    /**
     * Accept a block trade order
     * @summary Accept Block Trade Order (TRADE)
     * @param {OptionsApiCreateBlockOrderExecuteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    createBlockOrderExecuteV1(requestParameters: OptionsApiCreateBlockOrderExecuteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateBlockOrderExecuteV1Resp>;

    /**
     * This endpoint resets the time from which the countdown will begin to the time this messaged is received.  It should be called repeatedly as heartbeats.  Multiple heartbeats can be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in the underlyings parameter.
     * @summary Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)
     * @param {OptionsApiCreateCountdownCancelAllHeartBeatV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    createCountdownCancelAllHeartBeatV1(requestParameters: OptionsApiCreateCountdownCancelAllHeartBeatV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCountdownCancelAllHeartBeatV1Resp>;

    /**
     * This endpoint sets the parameters of the auto-cancel feature which cancels all open orders (both market maker protection and non market maker protection order types) of the underlying symbol at the end of the specified countdown time period if no heartbeat message is sent.  After the countdown time period, all open orders will be cancelled and new orders will be rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel feature is turned off by setting countdownTime to 0.
     * @summary Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
     * @param {OptionsApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    createCountdownCancelAllV1(requestParameters: OptionsApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCountdownCancelAllV1Resp>;

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp>;

    /**
     * Reset MMP, start MMP order again.
     * @summary Reset Market Maker Protection Config (TRADE)
     * @param {OptionsApiCreateMmpResetV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    createMmpResetV1(requestParameters: OptionsApiCreateMmpResetV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMmpResetV1Resp>;

    /**
     * Set config for MMP. Market Maker Protection(MMP) is a set of protection mechanism for option market maker, this mechanism is able to prevent mass trading in short period time. Once market maker\'s account branches the threshold, the Market Maker Protection will be triggered. When Market Maker Protection triggers, all the current MMP orders will be canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate market and modify order price.
     * @summary Set Market Maker Protection Config (TRADE)
     * @param {OptionsApiCreateMmpSetV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    createMmpSetV1(requestParameters: OptionsApiCreateMmpSetV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMmpSetV1Resp>;

    /**
     * Send a new order.
     * @summary New Order (TRADE)
     * @param {OptionsApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    createOrderV1(requestParameters: OptionsApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsCreateOrderV1Resp>;

    /**
     * Cancel all active orders on specified underlying.
     * @summary Cancel All Option Orders By Underlying (TRADE)
     * @param {OptionsApiDeleteAllOpenOrdersByUnderlyingV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    deleteAllOpenOrdersByUnderlyingV1(requestParameters: OptionsApiDeleteAllOpenOrdersByUnderlyingV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersByUnderlyingV1Resp>;

    /**
     * Cancel all active order on a symbol.
     * @summary Cancel all Option orders on specific symbol (TRADE)
     * @param {OptionsApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    deleteAllOpenOrdersV1(requestParameters: OptionsApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp>;

    /**
     * Cancel multiple orders.
     * @summary Cancel Multiple Option Orders (TRADE)
     * @param {OptionsApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    deleteBatchOrdersV1(requestParameters: OptionsApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsDeleteBatchOrdersV1RespInner>>;

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Cancel an active order.
     * @summary Cancel Option Order (TRADE)
     * @param {OptionsApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    deleteOrderV1(requestParameters: OptionsApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp>;

    /**
     * Get current account information.
     * @summary Option Account Information(TRADE)
     * @param {OptionsApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getAccountV1(requestParameters: OptionsApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV1Resp>;

    /**
     * Query account funding flows.
     * @summary Account Funding Flow (USER_DATA)
     * @param {OptionsApiGetBillV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getBillV1(requestParameters: OptionsApiGetBillV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBillV1RespItem>>;

    /**
     * Query block trade details; returns block trade details from counterparty\'s perspective.
     * @summary Query Block Trade Details (USER_DATA)
     * @param {OptionsApiGetBlockOrderExecuteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getBlockOrderExecuteV1(requestParameters: OptionsApiGetBlockOrderExecuteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetBlockOrderExecuteV1Resp>;

    /**
     * Check block trade order status.
     * @summary Query Block Trade Order (TRADE)
     * @param {OptionsApiGetBlockOrderOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getBlockOrderOrdersV1(requestParameters: OptionsApiGetBlockOrderOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBlockOrderOrdersV1RespItem>>;

    /**
     * Get recent block trades
     * @summary Recent Block Trades List
     * @param {OptionsApiGetBlockTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getBlockTradesV1(requestParameters?: OptionsApiGetBlockTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBlockTradesV1RespItem>>;

    /**
     * Gets block trades for a specific account.
     * @summary Account Block Trade List (USER_DATA)
     * @param {OptionsApiGetBlockUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getBlockUserTradesV1(requestParameters: OptionsApiGetBlockUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBlockUserTradesV1RespItem>>;

    /**
     * This endpoint returns the auto-cancel parameters for each underlying symbol. Note only active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie. countdownTime has been turned off), the underlying symbol and corresponding countdownTime parameter will not be returned in the response.
     * @summary Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
     * @param {OptionsApiGetCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getCountdownCancelAllV1(requestParameters: OptionsApiGetCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCountdownCancelAllV1Resp>;

    /**
     * Check orderbook depth on specific symbol
     * @summary Order Book
     * @param {OptionsApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getDepthV1(requestParameters: OptionsApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp>;

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<OptionsGetExchangeInfoV1Resp>;

    /**
     * Get historical exercise records.
     * @summary Historical Exercise Records
     * @param {OptionsApiGetExerciseHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getExerciseHistoryV1(requestParameters?: OptionsApiGetExerciseHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetExerciseHistoryV1RespItem>>;

    /**
     * Get account exercise records.
     * @summary User Exercise Record (USER_DATA)
     * @param {OptionsApiGetExerciseRecordV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getExerciseRecordV1(requestParameters: OptionsApiGetExerciseRecordV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetExerciseRecordV1RespItem>>;

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {OptionsApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getHistoricalTradesV1(requestParameters: OptionsApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>>;

    /**
     * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
     * @summary Query Option Order History (TRADE)
     * @param {OptionsApiGetHistoryOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getHistoryOrdersV1(requestParameters: OptionsApiGetHistoryOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoryOrdersV1RespItem>>;

    /**
     * Get option transaction history download Link by Id
     * @summary Get Option Transaction History Download Link by Id (USER_DATA)
     * @param {OptionsApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getIncomeAsynIdV1(requestParameters: OptionsApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp>;

    /**
     * Get download id for option transaction history
     * @summary Get Download Id For Option Transaction History (USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getIncomeAsynV1(options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp>;

    /**
     * Get spot index price for option underlying.
     * @summary Symbol Price Ticker
     * @param {OptionsApiGetIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getIndexV1(requestParameters: OptionsApiGetIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIndexV1Resp>;

    /**
     * Kline/candlestick bars for an option symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {OptionsApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getKlinesV1(requestParameters: OptionsApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetKlinesV1RespItem>>;

    /**
     * Get current account information.
     * @summary Option Margin Account Information (USER_DATA)
     * @param {OptionsApiGetMarginAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getMarginAccountV1(requestParameters: OptionsApiGetMarginAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginAccountV1Resp>;

    /**
     * Option mark price and greek info.
     * @summary Option Mark Price
     * @param {OptionsApiGetMarkV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getMarkV1(requestParameters?: OptionsApiGetMarkV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarkV1RespItem>>;

    /**
     * Get config for MMP.
     * @summary Get Market Maker Protection Config (TRADE)
     * @param {OptionsApiGetMmpV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getMmpV1(requestParameters: OptionsApiGetMmpV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMmpV1Resp>;

    /**
     * Get open interest for specific underlying asset on specific expiration date.
     * @summary Open Interest
     * @param {OptionsApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getOpenInterestV1(requestParameters: OptionsApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenInterestV1RespItem>>;

    /**
     * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
     * @summary Query Current Open Option Orders (USER_DATA)
     * @param {OptionsApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getOpenOrdersV1(requestParameters: OptionsApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>>;

    /**
     * Check an order status.
     * @summary Query Single Order (TRADE)
     * @param {OptionsApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getOrderV1(requestParameters: OptionsApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Get current position information.
     * @summary Option Position Information (USER_DATA)
     * @param {OptionsApiGetPositionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getPositionV1(requestParameters: OptionsApiGetPositionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionV1RespItem>>;

    /**
     * 24 hour rolling window price change statistics.
     * @summary 24hr Ticker Price Change Statistics
     * @param {OptionsApiGetTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getTickerV1(requestParameters?: OptionsApiGetTickerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTickerV1RespItem>>;

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp>;

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {OptionsApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getTradesV1(requestParameters: OptionsApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {OptionsApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    getUserTradesV1(requestParameters: OptionsApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>>;

    /**
     * Extends a block trade expire time by 30 mins from the current time.
     * @summary Extend Block Trade Order (TRADE)
     * @param {OptionsApiUpdateBlockOrderCreateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    updateBlockOrderCreateV1(requestParameters: OptionsApiUpdateBlockOrderCreateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateBlockOrderCreateV1Resp>;

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApiInterface
     */
    updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

}

/**
 * Request parameters for createBatchOrdersV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiCreateBatchOrdersV1Request
 */
export interface OptionsApiCreateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<OptionsCreateBatchOrdersV1ReqOrdersItem>}
     * @memberof OptionsApiCreateBatchOrdersV1
     */
    readonly orders: Array<OptionsCreateBatchOrdersV1ReqOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createBlockOrderExecuteV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiCreateBlockOrderExecuteV1Request
 */
export interface OptionsApiCreateBlockOrderExecuteV1Request {
    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateBlockOrderExecuteV1
     */
    readonly blockOrderMatchingKey: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateBlockOrderExecuteV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateBlockOrderExecuteV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createCountdownCancelAllHeartBeatV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiCreateCountdownCancelAllHeartBeatV1Request
 */
export interface OptionsApiCreateCountdownCancelAllHeartBeatV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateCountdownCancelAllHeartBeatV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateCountdownCancelAllHeartBeatV1
     */
    readonly underlyings: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateCountdownCancelAllHeartBeatV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createCountdownCancelAllV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiCreateCountdownCancelAllV1Request
 */
export interface OptionsApiCreateCountdownCancelAllV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateCountdownCancelAllV1
     */
    readonly countdownTime: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateCountdownCancelAllV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateCountdownCancelAllV1
     */
    readonly underlying: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateCountdownCancelAllV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMmpResetV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiCreateMmpResetV1Request
 */
export interface OptionsApiCreateMmpResetV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateMmpResetV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateMmpResetV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateMmpResetV1
     */
    readonly underlying?: string
}

/**
 * Request parameters for createMmpSetV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiCreateMmpSetV1Request
 */
export interface OptionsApiCreateMmpSetV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateMmpSetV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateMmpSetV1
     */
    readonly deltaLimit?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateMmpSetV1
     */
    readonly frozenTimeInMilliseconds?: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateMmpSetV1
     */
    readonly qtyLimit?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateMmpSetV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateMmpSetV1
     */
    readonly underlying?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateMmpSetV1
     */
    readonly windowTimeInMilliseconds?: number
}

/**
 * Request parameters for createOrderV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiCreateOrderV1Request
 */
export interface OptionsApiCreateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly clientOrderId?: string

    /**
     * 
     * @type {boolean}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly isMmp?: boolean

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {boolean}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly postOnly?: boolean

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {boolean}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly reduceOnly?: boolean

    /**
     * 
     * @type {string}
     * @memberof OptionsApiCreateOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for deleteAllOpenOrdersByUnderlyingV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiDeleteAllOpenOrdersByUnderlyingV1Request
 */
export interface OptionsApiDeleteAllOpenOrdersByUnderlyingV1Request {
    /**
     * Option underlying, e.g BTCUSDT
     * @type {string}
     * @memberof OptionsApiDeleteAllOpenOrdersByUnderlyingV1
     */
    readonly underlying: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiDeleteAllOpenOrdersByUnderlyingV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiDeleteAllOpenOrdersByUnderlyingV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteAllOpenOrdersV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiDeleteAllOpenOrdersV1Request
 */
export interface OptionsApiDeleteAllOpenOrdersV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiDeleteAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiDeleteAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiDeleteAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteBatchOrdersV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiDeleteBatchOrdersV1Request
 */
export interface OptionsApiDeleteBatchOrdersV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiDeleteBatchOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiDeleteBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * Order ID, e.g [4611875134427365377,4611875134427365378]
     * @type {Array<number>}
     * @memberof OptionsApiDeleteBatchOrdersV1
     */
    readonly orderIds?: Array<number>

    /**
     * User-defined order ID, e.g [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;]
     * @type {Array<string>}
     * @memberof OptionsApiDeleteBatchOrdersV1
     */
    readonly clientOrderIds?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof OptionsApiDeleteBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteOrderV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiDeleteOrderV1Request
 */
export interface OptionsApiDeleteOrderV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiDeleteOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiDeleteOrderV1
     */
    readonly timestamp: number

    /**
     * Order ID, e.g 4611875134427365377
     * @type {number}
     * @memberof OptionsApiDeleteOrderV1
     */
    readonly orderId?: number

    /**
     * User-defined order ID, e.g 10000
     * @type {string}
     * @memberof OptionsApiDeleteOrderV1
     */
    readonly clientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiDeleteOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetAccountV1Request
 */
export interface OptionsApiGetAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBillV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetBillV1Request
 */
export interface OptionsApiGetBillV1Request {
    /**
     * Asset type, only support USDT  as of now
     * @type {string}
     * @memberof OptionsApiGetBillV1
     */
    readonly currency: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBillV1
     */
    readonly timestamp: number

    /**
     * Return the recordId and subsequent data, the latest data is returned by default, e.g 100000
     * @type {number}
     * @memberof OptionsApiGetBillV1
     */
    readonly recordId?: number

    /**
     * Start Time, e.g 1593511200000
     * @type {number}
     * @memberof OptionsApiGetBillV1
     */
    readonly startTime?: number

    /**
     * End Time, e.g 1593512200000
     * @type {number}
     * @memberof OptionsApiGetBillV1
     */
    readonly endTime?: number

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof OptionsApiGetBillV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBillV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBlockOrderExecuteV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetBlockOrderExecuteV1Request
 */
export interface OptionsApiGetBlockOrderExecuteV1Request {
    /**
     * 
     * @type {string}
     * @memberof OptionsApiGetBlockOrderExecuteV1
     */
    readonly blockOrderMatchingKey: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBlockOrderExecuteV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof OptionsApiGetBlockOrderExecuteV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBlockOrderOrdersV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetBlockOrderOrdersV1Request
 */
export interface OptionsApiGetBlockOrderOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBlockOrderOrdersV1
     */
    readonly timestamp: number

    /**
     * If specified, returns the specific block trade associated with the blockOrderMatchingKey
     * @type {string}
     * @memberof OptionsApiGetBlockOrderOrdersV1
     */
    readonly blockOrderMatchingKey?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBlockOrderOrdersV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBlockOrderOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiGetBlockOrderOrdersV1
     */
    readonly underlying?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof OptionsApiGetBlockOrderOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBlockTradesV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetBlockTradesV1Request
 */
export interface OptionsApiGetBlockTradesV1Request {
    /**
     * Option trading pair, e.g. BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetBlockTradesV1
     */
    readonly symbol?: string

    /**
     * Number of records; Default: 100 and Max: 500
     * @type {number}
     * @memberof OptionsApiGetBlockTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getBlockUserTradesV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetBlockUserTradesV1Request
 */
export interface OptionsApiGetBlockUserTradesV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBlockUserTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBlockUserTradesV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetBlockUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {string}
     * @memberof OptionsApiGetBlockUserTradesV1
     */
    readonly underlying?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof OptionsApiGetBlockUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCountdownCancelAllV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetCountdownCancelAllV1Request
 */
export interface OptionsApiGetCountdownCancelAllV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetCountdownCancelAllV1
     */
    readonly timestamp: number

    /**
     * Option underlying, e.g BTCUSDT
     * @type {string}
     * @memberof OptionsApiGetCountdownCancelAllV1
     */
    readonly underlying?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetCountdownCancelAllV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getDepthV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetDepthV1Request
 */
export interface OptionsApiGetDepthV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetDepthV1
     */
    readonly symbol: string

    /**
     * Default:100 Max:1000.Optional value:[10, 20, 50, 100, 500, 1000]
     * @type {number}
     * @memberof OptionsApiGetDepthV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getExerciseHistoryV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetExerciseHistoryV1Request
 */
export interface OptionsApiGetExerciseHistoryV1Request {
    /**
     * Underlying index like BTCUSDT
     * @type {string}
     * @memberof OptionsApiGetExerciseHistoryV1
     */
    readonly underlying?: string

    /**
     * Start Time
     * @type {number}
     * @memberof OptionsApiGetExerciseHistoryV1
     */
    readonly startTime?: number

    /**
     * End Time
     * @type {number}
     * @memberof OptionsApiGetExerciseHistoryV1
     */
    readonly endTime?: number

    /**
     * Number of records Default:100 Max:100
     * @type {number}
     * @memberof OptionsApiGetExerciseHistoryV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getExerciseRecordV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetExerciseRecordV1Request
 */
export interface OptionsApiGetExerciseRecordV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetExerciseRecordV1
     */
    readonly timestamp: number

    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetExerciseRecordV1
     */
    readonly symbol?: string

    /**
     * startTime
     * @type {number}
     * @memberof OptionsApiGetExerciseRecordV1
     */
    readonly startTime?: number

    /**
     * endTime
     * @type {number}
     * @memberof OptionsApiGetExerciseRecordV1
     */
    readonly endTime?: number

    /**
     * default 1000, max 1000
     * @type {number}
     * @memberof OptionsApiGetExerciseRecordV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetExerciseRecordV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getHistoricalTradesV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetHistoricalTradesV1Request
 */
export interface OptionsApiGetHistoricalTradesV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetHistoricalTradesV1
     */
    readonly symbol: string

    /**
     * The UniqueId ID from which to return. The latest deal record is returned by default
     * @type {number}
     * @memberof OptionsApiGetHistoricalTradesV1
     */
    readonly fromId?: number

    /**
     * Number of records Default:100 Max:500
     * @type {number}
     * @memberof OptionsApiGetHistoricalTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getHistoryOrdersV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetHistoryOrdersV1Request
 */
export interface OptionsApiGetHistoryOrdersV1Request {
    /**
     * Option trading pair
     * @type {string}
     * @memberof OptionsApiGetHistoryOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetHistoryOrdersV1
     */
    readonly timestamp: number

    /**
     * Returns the orderId and subsequent orders, the most recent order is returned by default
     * @type {number}
     * @memberof OptionsApiGetHistoryOrdersV1
     */
    readonly orderId?: number

    /**
     * Start Time, e.g 1593511200000
     * @type {number}
     * @memberof OptionsApiGetHistoryOrdersV1
     */
    readonly startTime?: number

    /**
     * End Time, e.g 1593512200000
     * @type {number}
     * @memberof OptionsApiGetHistoryOrdersV1
     */
    readonly endTime?: number

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof OptionsApiGetHistoryOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetHistoryOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIncomeAsynIdV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetIncomeAsynIdV1Request
 */
export interface OptionsApiGetIncomeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof OptionsApiGetIncomeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetIncomeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetIncomeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIndexV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetIndexV1Request
 */
export interface OptionsApiGetIndexV1Request {
    /**
     * Spot pair（Option contract underlying asset, e.g BTCUSDT)
     * @type {string}
     * @memberof OptionsApiGetIndexV1
     */
    readonly underlying: string
}

/**
 * Request parameters for getKlinesV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetKlinesV1Request
 */
export interface OptionsApiGetKlinesV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetKlinesV1
     */
    readonly symbol: string

    /**
     * Time interval
     * @type {string}
     * @memberof OptionsApiGetKlinesV1
     */
    readonly interval: string

    /**
     * Start Time  1592317127349
     * @type {number}
     * @memberof OptionsApiGetKlinesV1
     */
    readonly startTime?: number

    /**
     * End Time
     * @type {number}
     * @memberof OptionsApiGetKlinesV1
     */
    readonly endTime?: number

    /**
     * Number of records Default:500 Max:1500
     * @type {number}
     * @memberof OptionsApiGetKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getMarginAccountV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetMarginAccountV1Request
 */
export interface OptionsApiGetMarginAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetMarginAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetMarginAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarkV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetMarkV1Request
 */
export interface OptionsApiGetMarkV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetMarkV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getMmpV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetMmpV1Request
 */
export interface OptionsApiGetMmpV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetMmpV1
     */
    readonly timestamp: number

    /**
     * underlying, e.g BTCUSDT
     * @type {string}
     * @memberof OptionsApiGetMmpV1
     */
    readonly underlying?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetMmpV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenInterestV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetOpenInterestV1Request
 */
export interface OptionsApiGetOpenInterestV1Request {
    /**
     * underlying asset, e.g ETH/BTC
     * @type {string}
     * @memberof OptionsApiGetOpenInterestV1
     */
    readonly underlyingAsset: string

    /**
     * expiration date, e.g 221225
     * @type {string}
     * @memberof OptionsApiGetOpenInterestV1
     */
    readonly expiration: string
}

/**
 * Request parameters for getOpenOrdersV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetOpenOrdersV1Request
 */
export interface OptionsApiGetOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * return all orders if don&amp;#39;t pass, Option trading pair, e.g BTC-200730-9000-C,
     * @type {string}
     * @memberof OptionsApiGetOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * Returns the orderId and subsequent orders, the most recent order is returned by default
     * @type {number}
     * @memberof OptionsApiGetOpenOrdersV1
     */
    readonly orderId?: number

    /**
     * Start Time
     * @type {number}
     * @memberof OptionsApiGetOpenOrdersV1
     */
    readonly startTime?: number

    /**
     * End Time
     * @type {number}
     * @memberof OptionsApiGetOpenOrdersV1
     */
    readonly endTime?: number

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof OptionsApiGetOpenOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetOrderV1Request
 */
export interface OptionsApiGetOrderV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetOrderV1
     */
    readonly timestamp: number

    /**
     * Order id
     * @type {number}
     * @memberof OptionsApiGetOrderV1
     */
    readonly orderId?: number

    /**
     * User-defined order ID cannot be repeated in pending orders
     * @type {string}
     * @memberof OptionsApiGetOrderV1
     */
    readonly clientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetPositionV1Request
 */
export interface OptionsApiGetPositionV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetPositionV1
     */
    readonly timestamp: number

    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetPositionV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetPositionV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTickerV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetTickerV1Request
 */
export interface OptionsApiGetTickerV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetTickerV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTradesV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetTradesV1Request
 */
export interface OptionsApiGetTradesV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetTradesV1
     */
    readonly symbol: string

    /**
     * Number of records Default:100 Max:500
     * @type {number}
     * @memberof OptionsApiGetTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getUserTradesV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiGetUserTradesV1Request
 */
export interface OptionsApiGetUserTradesV1Request {
    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetUserTradesV1
     */
    readonly timestamp: number

    /**
     * Option symbol, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof OptionsApiGetUserTradesV1
     */
    readonly symbol?: string

    /**
     * Trade id to fetch from. Default gets most recent trades, e.g 4611875134427365376
     * @type {number}
     * @memberof OptionsApiGetUserTradesV1
     */
    readonly fromId?: number

    /**
     * Start time, e.g 1593511200000
     * @type {number}
     * @memberof OptionsApiGetUserTradesV1
     */
    readonly startTime?: number

    /**
     * End time, e.g 1593512200000
     * @type {number}
     * @memberof OptionsApiGetUserTradesV1
     */
    readonly endTime?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof OptionsApiGetUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiGetUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateBlockOrderCreateV1 operation in OptionsApi.
 * @export
 * @interface OptionsApiUpdateBlockOrderCreateV1Request
 */
export interface OptionsApiUpdateBlockOrderCreateV1Request {
    /**
     * 
     * @type {string}
     * @memberof OptionsApiUpdateBlockOrderCreateV1
     */
    readonly blockOrderMatchingKey: string

    /**
     * 
     * @type {number}
     * @memberof OptionsApiUpdateBlockOrderCreateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof OptionsApiUpdateBlockOrderCreateV1
     */
    readonly recvWindow?: number
}

/**
 * OptionsApi - object-oriented interface
 * @export
 * @class OptionsApi
 * @extends {BaseAPI}
 */
export class OptionsApi extends BaseAPI implements OptionsApiInterface {
    /**
     * Send multiple option orders.
     * @summary Place Multiple Orders(TRADE)
     * @param {OptionsApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createBatchOrdersV1(requestParameters: OptionsApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createBatchOrdersV1(requestParameters.orders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept a block trade order
     * @summary Accept Block Trade Order (TRADE)
     * @param {OptionsApiCreateBlockOrderExecuteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createBlockOrderExecuteV1(requestParameters: OptionsApiCreateBlockOrderExecuteV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createBlockOrderExecuteV1(requestParameters.blockOrderMatchingKey, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint resets the time from which the countdown will begin to the time this messaged is received.  It should be called repeatedly as heartbeats.  Multiple heartbeats can be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in the underlyings parameter.
     * @summary Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)
     * @param {OptionsApiCreateCountdownCancelAllHeartBeatV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createCountdownCancelAllHeartBeatV1(requestParameters: OptionsApiCreateCountdownCancelAllHeartBeatV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createCountdownCancelAllHeartBeatV1(requestParameters.timestamp, requestParameters.underlyings, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sets the parameters of the auto-cancel feature which cancels all open orders (both market maker protection and non market maker protection order types) of the underlying symbol at the end of the specified countdown time period if no heartbeat message is sent.  After the countdown time period, all open orders will be cancelled and new orders will be rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel feature is turned off by setting countdownTime to 0.
     * @summary Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
     * @param {OptionsApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createCountdownCancelAllV1(requestParameters: OptionsApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createCountdownCancelAllV1(requestParameters.countdownTime, requestParameters.timestamp, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createListenKeyV1(options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset MMP, start MMP order again.
     * @summary Reset Market Maker Protection Config (TRADE)
     * @param {OptionsApiCreateMmpResetV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createMmpResetV1(requestParameters: OptionsApiCreateMmpResetV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createMmpResetV1(requestParameters.timestamp, requestParameters.recvWindow, requestParameters.underlying, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set config for MMP. Market Maker Protection(MMP) is a set of protection mechanism for option market maker, this mechanism is able to prevent mass trading in short period time. Once market maker\'s account branches the threshold, the Market Maker Protection will be triggered. When Market Maker Protection triggers, all the current MMP orders will be canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate market and modify order price.
     * @summary Set Market Maker Protection Config (TRADE)
     * @param {OptionsApiCreateMmpSetV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createMmpSetV1(requestParameters: OptionsApiCreateMmpSetV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createMmpSetV1(requestParameters.timestamp, requestParameters.deltaLimit, requestParameters.frozenTimeInMilliseconds, requestParameters.qtyLimit, requestParameters.recvWindow, requestParameters.underlying, requestParameters.windowTimeInMilliseconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a new order.
     * @summary New Order (TRADE)
     * @param {OptionsApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createOrderV1(requestParameters: OptionsApiCreateOrderV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createOrderV1(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.clientOrderId, requestParameters.isMmp, requestParameters.newOrderRespType, requestParameters.postOnly, requestParameters.price, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all active orders on specified underlying.
     * @summary Cancel All Option Orders By Underlying (TRADE)
     * @param {OptionsApiDeleteAllOpenOrdersByUnderlyingV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public deleteAllOpenOrdersByUnderlyingV1(requestParameters: OptionsApiDeleteAllOpenOrdersByUnderlyingV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).deleteAllOpenOrdersByUnderlyingV1(requestParameters.underlying, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all active order on a symbol.
     * @summary Cancel all Option orders on specific symbol (TRADE)
     * @param {OptionsApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public deleteAllOpenOrdersV1(requestParameters: OptionsApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel multiple orders.
     * @summary Cancel Multiple Option Orders (TRADE)
     * @param {OptionsApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public deleteBatchOrdersV1(requestParameters: OptionsApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIds, requestParameters.clientOrderIds, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public deleteListenKeyV1(options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).deleteListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel Option Order (TRADE)
     * @param {OptionsApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public deleteOrderV1(requestParameters: OptionsApiDeleteOrderV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.clientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information.
     * @summary Option Account Information(TRADE)
     * @param {OptionsApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getAccountV1(requestParameters: OptionsApiGetAccountV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account funding flows.
     * @summary Account Funding Flow (USER_DATA)
     * @param {OptionsApiGetBillV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getBillV1(requestParameters: OptionsApiGetBillV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getBillV1(requestParameters.currency, requestParameters.timestamp, requestParameters.recordId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query block trade details; returns block trade details from counterparty\'s perspective.
     * @summary Query Block Trade Details (USER_DATA)
     * @param {OptionsApiGetBlockOrderExecuteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getBlockOrderExecuteV1(requestParameters: OptionsApiGetBlockOrderExecuteV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getBlockOrderExecuteV1(requestParameters.blockOrderMatchingKey, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check block trade order status.
     * @summary Query Block Trade Order (TRADE)
     * @param {OptionsApiGetBlockOrderOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getBlockOrderOrdersV1(requestParameters: OptionsApiGetBlockOrderOrdersV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getBlockOrderOrdersV1(requestParameters.timestamp, requestParameters.blockOrderMatchingKey, requestParameters.endTime, requestParameters.startTime, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent block trades
     * @summary Recent Block Trades List
     * @param {OptionsApiGetBlockTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getBlockTradesV1(requestParameters: OptionsApiGetBlockTradesV1Request = {}, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getBlockTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets block trades for a specific account.
     * @summary Account Block Trade List (USER_DATA)
     * @param {OptionsApiGetBlockUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getBlockUserTradesV1(requestParameters: OptionsApiGetBlockUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getBlockUserTradesV1(requestParameters.timestamp, requestParameters.endTime, requestParameters.startTime, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the auto-cancel parameters for each underlying symbol. Note only active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie. countdownTime has been turned off), the underlying symbol and corresponding countdownTime parameter will not be returned in the response.
     * @summary Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
     * @param {OptionsApiGetCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getCountdownCancelAllV1(requestParameters: OptionsApiGetCountdownCancelAllV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getCountdownCancelAllV1(requestParameters.timestamp, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check orderbook depth on specific symbol
     * @summary Order Book
     * @param {OptionsApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getDepthV1(requestParameters: OptionsApiGetDepthV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getExchangeInfoV1(options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getExchangeInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historical exercise records.
     * @summary Historical Exercise Records
     * @param {OptionsApiGetExerciseHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getExerciseHistoryV1(requestParameters: OptionsApiGetExerciseHistoryV1Request = {}, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getExerciseHistoryV1(requestParameters.underlying, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account exercise records.
     * @summary User Exercise Record (USER_DATA)
     * @param {OptionsApiGetExerciseRecordV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getExerciseRecordV1(requestParameters: OptionsApiGetExerciseRecordV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getExerciseRecordV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {OptionsApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getHistoricalTradesV1(requestParameters: OptionsApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getHistoricalTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
     * @summary Query Option Order History (TRADE)
     * @param {OptionsApiGetHistoryOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getHistoryOrdersV1(requestParameters: OptionsApiGetHistoryOrdersV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getHistoryOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get option transaction history download Link by Id
     * @summary Get Option Transaction History Download Link by Id (USER_DATA)
     * @param {OptionsApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getIncomeAsynIdV1(requestParameters: OptionsApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for option transaction history
     * @summary Get Download Id For Option Transaction History (USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getIncomeAsynV1(options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getIncomeAsynV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get spot index price for option underlying.
     * @summary Symbol Price Ticker
     * @param {OptionsApiGetIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getIndexV1(requestParameters: OptionsApiGetIndexV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getIndexV1(requestParameters.underlying, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for an option symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {OptionsApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getKlinesV1(requestParameters: OptionsApiGetKlinesV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information.
     * @summary Option Margin Account Information (USER_DATA)
     * @param {OptionsApiGetMarginAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getMarginAccountV1(requestParameters: OptionsApiGetMarginAccountV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getMarginAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Option mark price and greek info.
     * @summary Option Mark Price
     * @param {OptionsApiGetMarkV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getMarkV1(requestParameters: OptionsApiGetMarkV1Request = {}, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getMarkV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get config for MMP.
     * @summary Get Market Maker Protection Config (TRADE)
     * @param {OptionsApiGetMmpV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getMmpV1(requestParameters: OptionsApiGetMmpV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getMmpV1(requestParameters.timestamp, requestParameters.underlying, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get open interest for specific underlying asset on specific expiration date.
     * @summary Open Interest
     * @param {OptionsApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getOpenInterestV1(requestParameters: OptionsApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getOpenInterestV1(requestParameters.underlyingAsset, requestParameters.expiration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
     * @summary Query Current Open Option Orders (USER_DATA)
     * @param {OptionsApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getOpenOrdersV1(requestParameters: OptionsApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order status.
     * @summary Query Single Order (TRADE)
     * @param {OptionsApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getOrderV1(requestParameters: OptionsApiGetOrderV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.clientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getPingV1(options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getPingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current position information.
     * @summary Option Position Information (USER_DATA)
     * @param {OptionsApiGetPositionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getPositionV1(requestParameters: OptionsApiGetPositionV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getPositionV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics.
     * @summary 24hr Ticker Price Change Statistics
     * @param {OptionsApiGetTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getTickerV1(requestParameters: OptionsApiGetTickerV1Request = {}, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getTickerV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getTimeV1(options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getTimeV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {OptionsApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getTradesV1(requestParameters: OptionsApiGetTradesV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {OptionsApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getUserTradesV1(requestParameters: OptionsApiGetUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extends a block trade expire time by 30 mins from the current time.
     * @summary Extend Block Trade Order (TRADE)
     * @param {OptionsApiUpdateBlockOrderCreateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public updateBlockOrderCreateV1(requestParameters: OptionsApiUpdateBlockOrderCreateV1Request, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).updateBlockOrderCreateV1(requestParameters.blockOrderMatchingKey, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public updateListenKeyV1(options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).updateListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }
}

