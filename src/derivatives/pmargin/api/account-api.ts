/* tslint:disable */
/* eslint-disable */
/**
 * Binance Portfolio Margin API
 * OpenAPI specification for Binance exchange - Pmargin API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { PmarginCreateAssetCollectionV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateAutoCollectionV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateBnbTransferV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateCmLeverageV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateCmPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateRepayFuturesNegativeBalanceV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateRepayFuturesSwitchV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateUmLeverageV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateUmPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetAccountV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetBalanceV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetCmAccountV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetCmCommissionRateV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetCmIncomeV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmLeverageBracketV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmPositionRiskV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetMarginMarginInterestHistoryV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetMarginMarginLoanV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetMarginMaxBorrowableV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetMarginMaxWithdrawV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetMarginRepayLoanV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetPortfolioInterestHistoryV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetRateLimitOrderV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetRepayFuturesSwitchV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmAccountConfigV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmAccountV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmAccountV2Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmApiTradingStatusV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmCommissionRateV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmIncomeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmIncomeAsynV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmIncomeV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmLeverageBracketV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmOrderAsynIdV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmOrderAsynV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmPositionRiskV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmSymbolConfigV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmTradeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmTradeAsynV1Resp } from '../model';
/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transfers specific asset from Futures Account to Margin account
         * @summary Fund Collection by Asset(TRADE)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateAssetCollectionV1: async (asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pmarginCreateAssetCollectionV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateAssetCollectionV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/asset-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fund collection for Portfolio Margin
         * @summary Fund Auto-collection(TRADE)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateAutoCollectionV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateAutoCollectionV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/auto-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer BNB in and out of UM
         * @summary BNB transfer (TRADE)
         * @param {string} amount 
         * @param {number} timestamp 
         * @param {string} transferSide 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateBnbTransferV1: async (amount: string, timestamp: number, transferSide: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('pmarginCreateBnbTransferV1', 'amount', amount)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateBnbTransferV1', 'timestamp', timestamp)
            // verify required parameter 'transferSide' is not null or undefined
            assertParamExists('pmarginCreateBnbTransferV1', 'transferSide', transferSide)
            const localVarPath = `/papi/v1/bnb-transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (transferSide !== undefined) { 
                localVarFormParams.set('transferSide', transferSide as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage of specific symbol in CM.
         * @summary Change CM Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateCmLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('pmarginCreateCmLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginCreateCmLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateCmLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Change CM Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateCmPositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('pmarginCreateCmPositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateCmPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Repay futures Negative Balance
         * @summary Repay futures Negative Balance(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateRepayFuturesNegativeBalanceV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateRepayFuturesNegativeBalanceV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/repay-futures-negative-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change Auto-repay-futures Status
         * @summary Change Auto-repay-futures Status(TRADE)
         * @param {string} autoRepay 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateRepayFuturesSwitchV1: async (autoRepay: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoRepay' is not null or undefined
            assertParamExists('pmarginCreateRepayFuturesSwitchV1', 'autoRepay', autoRepay)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateRepayFuturesSwitchV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/repay-futures-switch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (autoRepay !== undefined) { 
                localVarFormParams.set('autoRepay', autoRepay as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage of specific symbol in UM.
         * @summary Change UM Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('pmarginCreateUmLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginCreateUmLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateUmLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Change UM Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmPositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('pmarginCreateUmPositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateUmPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account information
         * @summary Account Information(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetAccountV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account balance
         * @summary Account Balance(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetBalanceV1: async (timestamp: number, asset?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetBalanceV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current CM account asset and position information.
         * @summary Get CM Account Detail(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmAccountV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Commission Rate for CM
         * @summary Get User Commission Rate for CM(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmCommissionRateV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetCmCommissionRateV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmCommissionRateV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/commissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CM Income History
         * @summary Get CM Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmIncomeV1: async (timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmIncomeV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/income`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (incomeType !== undefined) {
                localVarQueryParameter['incomeType'] = incomeType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query CM notional and leverage brackets
         * @summary CM Notional and Leverage Brackets(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmLeverageBracketV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmLeverageBracketV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current CM position information.
         * @summary Query CM Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmPositionRiskV1: async (timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmPositionRiskV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (marginAsset !== undefined) {
                localVarQueryParameter['marginAsset'] = marginAsset;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Get CM Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmPositionSideDualV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Margin Borrow/Loan Interest History
         * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMarginInterestHistoryV1: async (timestamp: number, asset?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginMarginInterestHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/marginInterestHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query margin loan record
         * @summary Query Margin Loan Record(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [txId] the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMarginLoanV1: async (asset: string, timestamp: number, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pmarginGetMarginMarginLoanV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginMarginLoanV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/marginLoan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (txId !== undefined) {
                localVarQueryParameter['txId'] = txId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query margin max borrow
         * @summary Margin Max Borrow(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMaxBorrowableV1: async (asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pmarginGetMarginMaxBorrowableV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginMaxBorrowableV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/maxBorrowable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Max Withdraw
         * @summary Query Margin Max Withdraw(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMaxWithdrawV1: async (asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pmarginGetMarginMaxWithdrawV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginMaxWithdrawV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/maxWithdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query margin repay record.
         * @summary Query Margin repay Record(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [txId] the tranId in &#x60;POST/papi/v1/repayLoan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginRepayLoanV1: async (asset: string, timestamp: number, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pmarginGetMarginRepayLoanV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginRepayLoanV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/repayLoan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (txId !== undefined) {
                localVarQueryParameter['txId'] = txId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query interest history of negative balance for portfolio margin.
         * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetPortfolioInterestHistoryV1: async (timestamp: number, asset?: string, startTime?: number, endTime?: number, size?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetPortfolioInterestHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/portfolio/interest-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user negative balance auto exchange record
         * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
         * @param {number} startTime 
         * @param {number} endTime 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetPortfolioNegativeBalanceExchangeRecordV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('pmarginGetPortfolioNegativeBalanceExchangeRecordV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('pmarginGetPortfolioNegativeBalanceExchangeRecordV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetPortfolioNegativeBalanceExchangeRecordV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/portfolio/negative-balance-exchange-record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetRateLimitOrderV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetRateLimitOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/rateLimit/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Auto-repay-futures Status
         * @summary Get Auto-repay-futures Status(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetRepayFuturesSwitchV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetRepayFuturesSwitchV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/repay-futures-switch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query UM Futures account configuration
         * @summary UM Futures Account Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAccountConfigV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmAccountConfigV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/accountConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmAccountV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail V2(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAccountV2: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmAccountV2', 'timestamp', timestamp)
            const localVarPath = `/papi/v2/um/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Portfolio Margin UM Trading Quantitative Rules Indicators
         * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmApiTradingStatusV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmApiTradingStatusV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/apiTradingStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Commission Rate for UM
         * @summary Get User Commission Rate for UM(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmCommissionRateV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetUmCommissionRateV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmCommissionRateV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/commissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UM futures Transaction download link by Id
         * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmIncomeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('pmarginGetUmIncomeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmIncomeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/income/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for UM futures transaction history
         * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmIncomeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('pmarginGetUmIncomeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('pmarginGetUmIncomeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmIncomeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/income/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UM Income History
         * @summary Get UM Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmIncomeV1: async (timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmIncomeV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/income`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (incomeType !== undefined) {
                localVarQueryParameter['incomeType'] = incomeType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query UM notional and leverage brackets
         * @summary UM Notional and Leverage Brackets (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmLeverageBracketV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmLeverageBracketV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UM futures order download link by Id
         * @summary Get UM Futures Order Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOrderAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('pmarginGetUmOrderAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmOrderAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for UM futures order history
         * @summary Get Download Id For UM Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOrderAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('pmarginGetUmOrderAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('pmarginGetUmOrderAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmOrderAsynV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current UM position information.
         * @summary Query UM Position Information(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmPositionRiskV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/um/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Get UM Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmPositionSideDualV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current UM account symbol configuration.
         * @summary UM Futures Symbol Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmSymbolConfigV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmSymbolConfigV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/symbolConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UM futures trade download link by Id
         * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmTradeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('pmarginGetUmTradeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmTradeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/trade/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for UM futures trade history
         * @summary Get Download Id For UM Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmTradeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('pmarginGetUmTradeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('pmarginGetUmTradeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmTradeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/trade/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Transfers specific asset from Futures Account to Margin account
         * @summary Fund Collection by Asset(TRADE)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateAssetCollectionV1(asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateAssetCollectionV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateAssetCollectionV1(asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateAssetCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fund collection for Portfolio Margin
         * @summary Fund Auto-collection(TRADE)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateAutoCollectionV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateAutoCollectionV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateAutoCollectionV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateAutoCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transfer BNB in and out of UM
         * @summary BNB transfer (TRADE)
         * @param {string} amount 
         * @param {number} timestamp 
         * @param {string} transferSide 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateBnbTransferV1(amount: string, timestamp: number, transferSide: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateBnbTransferV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateBnbTransferV1(amount, timestamp, transferSide, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateBnbTransferV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage of specific symbol in CM.
         * @summary Change CM Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateCmLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateCmLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateCmLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateCmLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Change CM Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateCmPositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateCmPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateCmPositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateCmPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Repay futures Negative Balance
         * @summary Repay futures Negative Balance(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateRepayFuturesNegativeBalanceV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateRepayFuturesNegativeBalanceV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateRepayFuturesNegativeBalanceV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateRepayFuturesNegativeBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change Auto-repay-futures Status
         * @summary Change Auto-repay-futures Status(TRADE)
         * @param {string} autoRepay 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateRepayFuturesSwitchV1(autoRepay: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateRepayFuturesSwitchV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateRepayFuturesSwitchV1(autoRepay, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateRepayFuturesSwitchV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage of specific symbol in UM.
         * @summary Change UM Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateUmLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateUmLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateUmLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateUmLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Change UM Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateUmPositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateUmPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateUmPositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginCreateUmPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account information
         * @summary Account Information(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account balance
         * @summary Account Balance(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetBalanceV1(timestamp: number, asset?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetBalanceV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetBalanceV1(timestamp, asset, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current CM account asset and position information.
         * @summary Get CM Account Detail(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetCmAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetCmAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User Commission Rate for CM
         * @summary Get User Commission Rate for CM(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmCommissionRateV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetCmCommissionRateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmCommissionRateV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetCmCommissionRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CM Income History
         * @summary Get CM Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmIncomeV1(timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmIncomeV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmIncomeV1(timestamp, symbol, incomeType, startTime, endTime, page, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetCmIncomeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query CM notional and leverage brackets
         * @summary CM Notional and Leverage Brackets(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmLeverageBracketV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmLeverageBracketV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmLeverageBracketV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetCmLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current CM position information.
         * @summary Query CM Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmPositionRiskV1(timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmPositionRiskV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmPositionRiskV1(timestamp, marginAsset, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetCmPositionRiskV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Get CM Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmPositionSideDualV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetCmPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmPositionSideDualV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetCmPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Margin Borrow/Loan Interest History
         * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginMarginInterestHistoryV1(timestamp: number, asset?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetMarginMarginInterestHistoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginMarginInterestHistoryV1(timestamp, asset, startTime, endTime, current, size, archived, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetMarginMarginInterestHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query margin loan record
         * @summary Query Margin Loan Record(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [txId] the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginMarginLoanV1(asset: string, timestamp: number, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetMarginMarginLoanV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginMarginLoanV1(asset, timestamp, txId, startTime, endTime, current, size, archived, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetMarginMarginLoanV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query margin max borrow
         * @summary Margin Max Borrow(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginMaxBorrowableV1(asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetMarginMaxBorrowableV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginMaxBorrowableV1(asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetMarginMaxBorrowableV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Max Withdraw
         * @summary Query Margin Max Withdraw(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginMaxWithdrawV1(asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetMarginMaxWithdrawV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginMaxWithdrawV1(asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetMarginMaxWithdrawV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query margin repay record.
         * @summary Query Margin repay Record(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [txId] the tranId in &#x60;POST/papi/v1/repayLoan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginRepayLoanV1(asset: string, timestamp: number, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetMarginRepayLoanV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginRepayLoanV1(asset, timestamp, txId, startTime, endTime, current, size, archived, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetMarginRepayLoanV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query interest history of negative balance for portfolio margin.
         * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetPortfolioInterestHistoryV1(timestamp: number, asset?: string, startTime?: number, endTime?: number, size?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetPortfolioInterestHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetPortfolioInterestHistoryV1(timestamp, asset, startTime, endTime, size, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetPortfolioInterestHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user negative balance auto exchange record
         * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
         * @param {number} startTime 
         * @param {number} endTime 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetPortfolioNegativeBalanceExchangeRecordV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetPortfolioNegativeBalanceExchangeRecordV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetPortfolioNegativeBalanceExchangeRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetRateLimitOrderV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetRateLimitOrderV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetRateLimitOrderV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetRateLimitOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Auto-repay-futures Status
         * @summary Get Auto-repay-futures Status(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetRepayFuturesSwitchV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetRepayFuturesSwitchV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetRepayFuturesSwitchV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetRepayFuturesSwitchV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query UM Futures account configuration
         * @summary UM Futures Account Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmAccountConfigV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmAccountConfigV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmAccountConfigV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmAccountConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail V2(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmAccountV2(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmAccountV2Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmAccountV2(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmAccountV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Portfolio Margin UM Trading Quantitative Rules Indicators
         * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmApiTradingStatusV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmApiTradingStatusV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmApiTradingStatusV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmApiTradingStatusV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User Commission Rate for UM
         * @summary Get User Commission Rate for UM(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmCommissionRateV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmCommissionRateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmCommissionRateV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmCommissionRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UM futures Transaction download link by Id
         * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmIncomeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmIncomeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmIncomeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmIncomeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for UM futures transaction history
         * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmIncomeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmIncomeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmIncomeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmIncomeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UM Income History
         * @summary Get UM Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmIncomeV1(timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmIncomeV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmIncomeV1(timestamp, symbol, incomeType, startTime, endTime, page, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmIncomeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query UM notional and leverage brackets
         * @summary UM Notional and Leverage Brackets (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmLeverageBracketV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmLeverageBracketV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmLeverageBracketV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UM futures order download link by Id
         * @summary Get UM Futures Order Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmOrderAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmOrderAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmOrderAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmOrderAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for UM futures order history
         * @summary Get Download Id For UM Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmOrderAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmOrderAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmOrderAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmOrderAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current UM position information.
         * @summary Query UM Position Information(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmPositionRiskV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmPositionRiskV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmPositionRiskV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmPositionRiskV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Get UM Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmPositionSideDualV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmPositionSideDualV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current UM account symbol configuration.
         * @summary UM Futures Symbol Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmSymbolConfigV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmSymbolConfigV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmSymbolConfigV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmSymbolConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UM futures trade download link by Id
         * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmTradeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmTradeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmTradeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmTradeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for UM futures trade history
         * @summary Get Download Id For UM Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmTradeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmTradeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmTradeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pmarginGetUmTradeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Transfers specific asset from Futures Account to Margin account
         * @summary Fund Collection by Asset(TRADE)
         * @param {AccountApiPmarginCreateAssetCollectionV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateAssetCollectionV1(requestParameters: AccountApiPmarginCreateAssetCollectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateAssetCollectionV1Resp> {
            return localVarFp.pmarginCreateAssetCollectionV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fund collection for Portfolio Margin
         * @summary Fund Auto-collection(TRADE)
         * @param {AccountApiPmarginCreateAutoCollectionV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateAutoCollectionV1(requestParameters: AccountApiPmarginCreateAutoCollectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateAutoCollectionV1Resp> {
            return localVarFp.pmarginCreateAutoCollectionV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfer BNB in and out of UM
         * @summary BNB transfer (TRADE)
         * @param {AccountApiPmarginCreateBnbTransferV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateBnbTransferV1(requestParameters: AccountApiPmarginCreateBnbTransferV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateBnbTransferV1Resp> {
            return localVarFp.pmarginCreateBnbTransferV1(requestParameters.amount, requestParameters.timestamp, requestParameters.transferSide, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage of specific symbol in CM.
         * @summary Change CM Initial Leverage (TRADE)
         * @param {AccountApiPmarginCreateCmLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateCmLeverageV1(requestParameters: AccountApiPmarginCreateCmLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateCmLeverageV1Resp> {
            return localVarFp.pmarginCreateCmLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Change CM Position Mode(TRADE)
         * @param {AccountApiPmarginCreateCmPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateCmPositionSideDualV1(requestParameters: AccountApiPmarginCreateCmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateCmPositionSideDualV1Resp> {
            return localVarFp.pmarginCreateCmPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Repay futures Negative Balance
         * @summary Repay futures Negative Balance(USER_DATA)
         * @param {AccountApiPmarginCreateRepayFuturesNegativeBalanceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateRepayFuturesNegativeBalanceV1(requestParameters: AccountApiPmarginCreateRepayFuturesNegativeBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateRepayFuturesNegativeBalanceV1Resp> {
            return localVarFp.pmarginCreateRepayFuturesNegativeBalanceV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change Auto-repay-futures Status
         * @summary Change Auto-repay-futures Status(TRADE)
         * @param {AccountApiPmarginCreateRepayFuturesSwitchV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateRepayFuturesSwitchV1(requestParameters: AccountApiPmarginCreateRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateRepayFuturesSwitchV1Resp> {
            return localVarFp.pmarginCreateRepayFuturesSwitchV1(requestParameters.autoRepay, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage of specific symbol in UM.
         * @summary Change UM Initial Leverage(TRADE)
         * @param {AccountApiPmarginCreateUmLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmLeverageV1(requestParameters: AccountApiPmarginCreateUmLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmLeverageV1Resp> {
            return localVarFp.pmarginCreateUmLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Change UM Position Mode(TRADE)
         * @param {AccountApiPmarginCreateUmPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmPositionSideDualV1(requestParameters: AccountApiPmarginCreateUmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmPositionSideDualV1Resp> {
            return localVarFp.pmarginCreateUmPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account information
         * @summary Account Information(USER_DATA)
         * @param {AccountApiPmarginGetAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetAccountV1(requestParameters: AccountApiPmarginGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetAccountV1Resp> {
            return localVarFp.pmarginGetAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account balance
         * @summary Account Balance(USER_DATA)
         * @param {AccountApiPmarginGetBalanceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetBalanceV1(requestParameters: AccountApiPmarginGetBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetBalanceV1Resp> {
            return localVarFp.pmarginGetBalanceV1(requestParameters.timestamp, requestParameters.asset, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current CM account asset and position information.
         * @summary Get CM Account Detail(USER_DATA)
         * @param {AccountApiPmarginGetCmAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmAccountV1(requestParameters: AccountApiPmarginGetCmAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmAccountV1Resp> {
            return localVarFp.pmarginGetCmAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User Commission Rate for CM
         * @summary Get User Commission Rate for CM(USER_DATA)
         * @param {AccountApiPmarginGetCmCommissionRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmCommissionRateV1(requestParameters: AccountApiPmarginGetCmCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmCommissionRateV1Resp> {
            return localVarFp.pmarginGetCmCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CM Income History
         * @summary Get CM Income History(USER_DATA)
         * @param {AccountApiPmarginGetCmIncomeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmIncomeV1(requestParameters: AccountApiPmarginGetCmIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmIncomeV1RespItem>> {
            return localVarFp.pmarginGetCmIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query CM notional and leverage brackets
         * @summary CM Notional and Leverage Brackets(USER_DATA)
         * @param {AccountApiPmarginGetCmLeverageBracketV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmLeverageBracketV1(requestParameters: AccountApiPmarginGetCmLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmLeverageBracketV1RespItem>> {
            return localVarFp.pmarginGetCmLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current CM position information.
         * @summary Query CM Position Information(USER_DATA)
         * @param {AccountApiPmarginGetCmPositionRiskV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmPositionRiskV1(requestParameters: AccountApiPmarginGetCmPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmPositionRiskV1RespItem>> {
            return localVarFp.pmarginGetCmPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Get CM Current Position Mode(USER_DATA)
         * @param {AccountApiPmarginGetCmPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmPositionSideDualV1(requestParameters: AccountApiPmarginGetCmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmPositionSideDualV1Resp> {
            return localVarFp.pmarginGetCmPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Margin Borrow/Loan Interest History
         * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
         * @param {AccountApiPmarginGetMarginMarginInterestHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMarginInterestHistoryV1(requestParameters: AccountApiPmarginGetMarginMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginMarginInterestHistoryV1Resp> {
            return localVarFp.pmarginGetMarginMarginInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query margin loan record
         * @summary Query Margin Loan Record(USER_DATA)
         * @param {AccountApiPmarginGetMarginMarginLoanV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMarginLoanV1(requestParameters: AccountApiPmarginGetMarginMarginLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginMarginLoanV1Resp> {
            return localVarFp.pmarginGetMarginMarginLoanV1(requestParameters.asset, requestParameters.timestamp, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query margin max borrow
         * @summary Margin Max Borrow(USER_DATA)
         * @param {AccountApiPmarginGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMaxBorrowableV1(requestParameters: AccountApiPmarginGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginMaxBorrowableV1Resp> {
            return localVarFp.pmarginGetMarginMaxBorrowableV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Max Withdraw
         * @summary Query Margin Max Withdraw(USER_DATA)
         * @param {AccountApiPmarginGetMarginMaxWithdrawV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMaxWithdrawV1(requestParameters: AccountApiPmarginGetMarginMaxWithdrawV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginMaxWithdrawV1Resp> {
            return localVarFp.pmarginGetMarginMaxWithdrawV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query margin repay record.
         * @summary Query Margin repay Record(USER_DATA)
         * @param {AccountApiPmarginGetMarginRepayLoanV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginRepayLoanV1(requestParameters: AccountApiPmarginGetMarginRepayLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginRepayLoanV1Resp> {
            return localVarFp.pmarginGetMarginRepayLoanV1(requestParameters.asset, requestParameters.timestamp, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query interest history of negative balance for portfolio margin.
         * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
         * @param {AccountApiPmarginGetPortfolioInterestHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetPortfolioInterestHistoryV1(requestParameters: AccountApiPmarginGetPortfolioInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetPortfolioInterestHistoryV1RespItem>> {
            return localVarFp.pmarginGetPortfolioInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.startTime, requestParameters.endTime, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user negative balance auto exchange record
         * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
         * @param {AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetPortfolioNegativeBalanceExchangeRecordV1(requestParameters: AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp> {
            return localVarFp.pmarginGetPortfolioNegativeBalanceExchangeRecordV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {AccountApiPmarginGetRateLimitOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetRateLimitOrderV1(requestParameters: AccountApiPmarginGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetRateLimitOrderV1RespItem>> {
            return localVarFp.pmarginGetRateLimitOrderV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Auto-repay-futures Status
         * @summary Get Auto-repay-futures Status(USER_DATA)
         * @param {AccountApiPmarginGetRepayFuturesSwitchV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetRepayFuturesSwitchV1(requestParameters: AccountApiPmarginGetRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetRepayFuturesSwitchV1Resp> {
            return localVarFp.pmarginGetRepayFuturesSwitchV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query UM Futures account configuration
         * @summary UM Futures Account Configuration(USER_DATA)
         * @param {AccountApiPmarginGetUmAccountConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAccountConfigV1(requestParameters: AccountApiPmarginGetUmAccountConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmAccountConfigV1Resp> {
            return localVarFp.pmarginGetUmAccountConfigV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail(USER_DATA)
         * @param {AccountApiPmarginGetUmAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAccountV1(requestParameters: AccountApiPmarginGetUmAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmAccountV1Resp> {
            return localVarFp.pmarginGetUmAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail V2(USER_DATA)
         * @param {AccountApiPmarginGetUmAccountV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAccountV2(requestParameters: AccountApiPmarginGetUmAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmAccountV2Resp> {
            return localVarFp.pmarginGetUmAccountV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Portfolio Margin UM Trading Quantitative Rules Indicators
         * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
         * @param {AccountApiPmarginGetUmApiTradingStatusV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmApiTradingStatusV1(requestParameters: AccountApiPmarginGetUmApiTradingStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmApiTradingStatusV1Resp> {
            return localVarFp.pmarginGetUmApiTradingStatusV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User Commission Rate for UM
         * @summary Get User Commission Rate for UM(USER_DATA)
         * @param {AccountApiPmarginGetUmCommissionRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmCommissionRateV1(requestParameters: AccountApiPmarginGetUmCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmCommissionRateV1Resp> {
            return localVarFp.pmarginGetUmCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UM futures Transaction download link by Id
         * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
         * @param {AccountApiPmarginGetUmIncomeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmIncomeAsynIdV1(requestParameters: AccountApiPmarginGetUmIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmIncomeAsynIdV1Resp> {
            return localVarFp.pmarginGetUmIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for UM futures transaction history
         * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
         * @param {AccountApiPmarginGetUmIncomeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmIncomeAsynV1(requestParameters: AccountApiPmarginGetUmIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmIncomeAsynV1Resp> {
            return localVarFp.pmarginGetUmIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UM Income History
         * @summary Get UM Income History(USER_DATA)
         * @param {AccountApiPmarginGetUmIncomeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmIncomeV1(requestParameters: AccountApiPmarginGetUmIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmIncomeV1RespItem>> {
            return localVarFp.pmarginGetUmIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query UM notional and leverage brackets
         * @summary UM Notional and Leverage Brackets (USER_DATA)
         * @param {AccountApiPmarginGetUmLeverageBracketV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmLeverageBracketV1(requestParameters: AccountApiPmarginGetUmLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmLeverageBracketV1RespItem>> {
            return localVarFp.pmarginGetUmLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UM futures order download link by Id
         * @summary Get UM Futures Order Download Link by Id(USER_DATA)
         * @param {AccountApiPmarginGetUmOrderAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOrderAsynIdV1(requestParameters: AccountApiPmarginGetUmOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmOrderAsynIdV1Resp> {
            return localVarFp.pmarginGetUmOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for UM futures order history
         * @summary Get Download Id For UM Futures Order History (USER_DATA)
         * @param {AccountApiPmarginGetUmOrderAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOrderAsynV1(requestParameters: AccountApiPmarginGetUmOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmOrderAsynV1Resp> {
            return localVarFp.pmarginGetUmOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current UM position information.
         * @summary Query UM Position Information(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmPositionRiskV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmPositionRiskV1RespItem>> {
            return localVarFp.pmarginGetUmPositionRiskV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Get UM Current Position Mode(USER_DATA)
         * @param {AccountApiPmarginGetUmPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmPositionSideDualV1(requestParameters: AccountApiPmarginGetUmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmPositionSideDualV1Resp> {
            return localVarFp.pmarginGetUmPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current UM account symbol configuration.
         * @summary UM Futures Symbol Configuration(USER_DATA)
         * @param {AccountApiPmarginGetUmSymbolConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmSymbolConfigV1(requestParameters: AccountApiPmarginGetUmSymbolConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmSymbolConfigV1RespItem>> {
            return localVarFp.pmarginGetUmSymbolConfigV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UM futures trade download link by Id
         * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
         * @param {AccountApiPmarginGetUmTradeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmTradeAsynIdV1(requestParameters: AccountApiPmarginGetUmTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmTradeAsynIdV1Resp> {
            return localVarFp.pmarginGetUmTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for UM futures trade history
         * @summary Get Download Id For UM Futures Trade History (USER_DATA)
         * @param {AccountApiPmarginGetUmTradeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmTradeAsynV1(requestParameters: AccountApiPmarginGetUmTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmTradeAsynV1Resp> {
            return localVarFp.pmarginGetUmTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
    /**
     * Transfers specific asset from Futures Account to Margin account
     * @summary Fund Collection by Asset(TRADE)
     * @param {AccountApiPmarginCreateAssetCollectionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateAssetCollectionV1(requestParameters: AccountApiPmarginCreateAssetCollectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateAssetCollectionV1Resp>;

    /**
     * Fund collection for Portfolio Margin
     * @summary Fund Auto-collection(TRADE)
     * @param {AccountApiPmarginCreateAutoCollectionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateAutoCollectionV1(requestParameters: AccountApiPmarginCreateAutoCollectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateAutoCollectionV1Resp>;

    /**
     * Transfer BNB in and out of UM
     * @summary BNB transfer (TRADE)
     * @param {AccountApiPmarginCreateBnbTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateBnbTransferV1(requestParameters: AccountApiPmarginCreateBnbTransferV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateBnbTransferV1Resp>;

    /**
     * Change user\'s initial leverage of specific symbol in CM.
     * @summary Change CM Initial Leverage (TRADE)
     * @param {AccountApiPmarginCreateCmLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateCmLeverageV1(requestParameters: AccountApiPmarginCreateCmLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateCmLeverageV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * @summary Change CM Position Mode(TRADE)
     * @param {AccountApiPmarginCreateCmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateCmPositionSideDualV1(requestParameters: AccountApiPmarginCreateCmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateCmPositionSideDualV1Resp>;

    /**
     * Repay futures Negative Balance
     * @summary Repay futures Negative Balance(USER_DATA)
     * @param {AccountApiPmarginCreateRepayFuturesNegativeBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateRepayFuturesNegativeBalanceV1(requestParameters: AccountApiPmarginCreateRepayFuturesNegativeBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateRepayFuturesNegativeBalanceV1Resp>;

    /**
     * Change Auto-repay-futures Status
     * @summary Change Auto-repay-futures Status(TRADE)
     * @param {AccountApiPmarginCreateRepayFuturesSwitchV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateRepayFuturesSwitchV1(requestParameters: AccountApiPmarginCreateRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateRepayFuturesSwitchV1Resp>;

    /**
     * Change user\'s initial leverage of specific symbol in UM.
     * @summary Change UM Initial Leverage(TRADE)
     * @param {AccountApiPmarginCreateUmLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateUmLeverageV1(requestParameters: AccountApiPmarginCreateUmLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmLeverageV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * @summary Change UM Position Mode(TRADE)
     * @param {AccountApiPmarginCreateUmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginCreateUmPositionSideDualV1(requestParameters: AccountApiPmarginCreateUmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmPositionSideDualV1Resp>;

    /**
     * Query account information
     * @summary Account Information(USER_DATA)
     * @param {AccountApiPmarginGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetAccountV1(requestParameters: AccountApiPmarginGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetAccountV1Resp>;

    /**
     * Query account balance
     * @summary Account Balance(USER_DATA)
     * @param {AccountApiPmarginGetBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetBalanceV1(requestParameters: AccountApiPmarginGetBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetBalanceV1Resp>;

    /**
     * Get current CM account asset and position information.
     * @summary Get CM Account Detail(USER_DATA)
     * @param {AccountApiPmarginGetCmAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetCmAccountV1(requestParameters: AccountApiPmarginGetCmAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmAccountV1Resp>;

    /**
     * Get User Commission Rate for CM
     * @summary Get User Commission Rate for CM(USER_DATA)
     * @param {AccountApiPmarginGetCmCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetCmCommissionRateV1(requestParameters: AccountApiPmarginGetCmCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmCommissionRateV1Resp>;

    /**
     * Get CM Income History
     * @summary Get CM Income History(USER_DATA)
     * @param {AccountApiPmarginGetCmIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetCmIncomeV1(requestParameters: AccountApiPmarginGetCmIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmIncomeV1RespItem>>;

    /**
     * Query CM notional and leverage brackets
     * @summary CM Notional and Leverage Brackets(USER_DATA)
     * @param {AccountApiPmarginGetCmLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetCmLeverageBracketV1(requestParameters: AccountApiPmarginGetCmLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmLeverageBracketV1RespItem>>;

    /**
     * Get current CM position information.
     * @summary Query CM Position Information(USER_DATA)
     * @param {AccountApiPmarginGetCmPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetCmPositionRiskV1(requestParameters: AccountApiPmarginGetCmPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmPositionRiskV1RespItem>>;

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * @summary Get CM Current Position Mode(USER_DATA)
     * @param {AccountApiPmarginGetCmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetCmPositionSideDualV1(requestParameters: AccountApiPmarginGetCmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmPositionSideDualV1Resp>;

    /**
     * Get Margin Borrow/Loan Interest History
     * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
     * @param {AccountApiPmarginGetMarginMarginInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetMarginMarginInterestHistoryV1(requestParameters: AccountApiPmarginGetMarginMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginMarginInterestHistoryV1Resp>;

    /**
     * Query margin loan record
     * @summary Query Margin Loan Record(USER_DATA)
     * @param {AccountApiPmarginGetMarginMarginLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetMarginMarginLoanV1(requestParameters: AccountApiPmarginGetMarginMarginLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginMarginLoanV1Resp>;

    /**
     * Query margin max borrow
     * @summary Margin Max Borrow(USER_DATA)
     * @param {AccountApiPmarginGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetMarginMaxBorrowableV1(requestParameters: AccountApiPmarginGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginMaxBorrowableV1Resp>;

    /**
     * Query Margin Max Withdraw
     * @summary Query Margin Max Withdraw(USER_DATA)
     * @param {AccountApiPmarginGetMarginMaxWithdrawV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetMarginMaxWithdrawV1(requestParameters: AccountApiPmarginGetMarginMaxWithdrawV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginMaxWithdrawV1Resp>;

    /**
     * Query margin repay record.
     * @summary Query Margin repay Record(USER_DATA)
     * @param {AccountApiPmarginGetMarginRepayLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetMarginRepayLoanV1(requestParameters: AccountApiPmarginGetMarginRepayLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginRepayLoanV1Resp>;

    /**
     * Query interest history of negative balance for portfolio margin.
     * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     * @param {AccountApiPmarginGetPortfolioInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetPortfolioInterestHistoryV1(requestParameters: AccountApiPmarginGetPortfolioInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetPortfolioInterestHistoryV1RespItem>>;

    /**
     * Query user negative balance auto exchange record
     * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
     * @param {AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetPortfolioNegativeBalanceExchangeRecordV1(requestParameters: AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp>;

    /**
     * Query User Rate Limit
     * @summary Query User Rate Limit (USER_DATA)
     * @param {AccountApiPmarginGetRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetRateLimitOrderV1(requestParameters: AccountApiPmarginGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetRateLimitOrderV1RespItem>>;

    /**
     * Query Auto-repay-futures Status
     * @summary Get Auto-repay-futures Status(USER_DATA)
     * @param {AccountApiPmarginGetRepayFuturesSwitchV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetRepayFuturesSwitchV1(requestParameters: AccountApiPmarginGetRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetRepayFuturesSwitchV1Resp>;

    /**
     * Query UM Futures account configuration
     * @summary UM Futures Account Configuration(USER_DATA)
     * @param {AccountApiPmarginGetUmAccountConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmAccountConfigV1(requestParameters: AccountApiPmarginGetUmAccountConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmAccountConfigV1Resp>;

    /**
     * Get current UM account asset and position information.
     * @summary Get UM Account Detail(USER_DATA)
     * @param {AccountApiPmarginGetUmAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmAccountV1(requestParameters: AccountApiPmarginGetUmAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmAccountV1Resp>;

    /**
     * Get current UM account asset and position information.
     * @summary Get UM Account Detail V2(USER_DATA)
     * @param {AccountApiPmarginGetUmAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmAccountV2(requestParameters: AccountApiPmarginGetUmAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmAccountV2Resp>;

    /**
     * Portfolio Margin UM Trading Quantitative Rules Indicators
     * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     * @param {AccountApiPmarginGetUmApiTradingStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmApiTradingStatusV1(requestParameters: AccountApiPmarginGetUmApiTradingStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmApiTradingStatusV1Resp>;

    /**
     * Get User Commission Rate for UM
     * @summary Get User Commission Rate for UM(USER_DATA)
     * @param {AccountApiPmarginGetUmCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmCommissionRateV1(requestParameters: AccountApiPmarginGetUmCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmCommissionRateV1Resp>;

    /**
     * Get UM futures Transaction download link by Id
     * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
     * @param {AccountApiPmarginGetUmIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmIncomeAsynIdV1(requestParameters: AccountApiPmarginGetUmIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmIncomeAsynIdV1Resp>;

    /**
     * Get download id for UM futures transaction history
     * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
     * @param {AccountApiPmarginGetUmIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmIncomeAsynV1(requestParameters: AccountApiPmarginGetUmIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmIncomeAsynV1Resp>;

    /**
     * Get UM Income History
     * @summary Get UM Income History(USER_DATA)
     * @param {AccountApiPmarginGetUmIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmIncomeV1(requestParameters: AccountApiPmarginGetUmIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmIncomeV1RespItem>>;

    /**
     * Query UM notional and leverage brackets
     * @summary UM Notional and Leverage Brackets (USER_DATA)
     * @param {AccountApiPmarginGetUmLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmLeverageBracketV1(requestParameters: AccountApiPmarginGetUmLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmLeverageBracketV1RespItem>>;

    /**
     * Get UM futures order download link by Id
     * @summary Get UM Futures Order Download Link by Id(USER_DATA)
     * @param {AccountApiPmarginGetUmOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmOrderAsynIdV1(requestParameters: AccountApiPmarginGetUmOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmOrderAsynIdV1Resp>;

    /**
     * Get download id for UM futures order history
     * @summary Get Download Id For UM Futures Order History (USER_DATA)
     * @param {AccountApiPmarginGetUmOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmOrderAsynV1(requestParameters: AccountApiPmarginGetUmOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmOrderAsynV1Resp>;

    /**
     * Get current UM position information.
     * @summary Query UM Position Information(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmPositionRiskV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmPositionRiskV1RespItem>>;

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * @summary Get UM Current Position Mode(USER_DATA)
     * @param {AccountApiPmarginGetUmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmPositionSideDualV1(requestParameters: AccountApiPmarginGetUmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmPositionSideDualV1Resp>;

    /**
     * Get current UM account symbol configuration.
     * @summary UM Futures Symbol Configuration(USER_DATA)
     * @param {AccountApiPmarginGetUmSymbolConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmSymbolConfigV1(requestParameters: AccountApiPmarginGetUmSymbolConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmSymbolConfigV1RespItem>>;

    /**
     * Get UM futures trade download link by Id
     * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
     * @param {AccountApiPmarginGetUmTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmTradeAsynIdV1(requestParameters: AccountApiPmarginGetUmTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmTradeAsynIdV1Resp>;

    /**
     * Get download id for UM futures trade history
     * @summary Get Download Id For UM Futures Trade History (USER_DATA)
     * @param {AccountApiPmarginGetUmTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    pmarginGetUmTradeAsynV1(requestParameters: AccountApiPmarginGetUmTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmTradeAsynV1Resp>;

}

/**
 * Request parameters for pmarginCreateAssetCollectionV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateAssetCollectionV1Request
 */
export interface AccountApiPmarginCreateAssetCollectionV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginCreateAssetCollectionV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateAssetCollectionV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateAssetCollectionV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateAutoCollectionV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateAutoCollectionV1Request
 */
export interface AccountApiPmarginCreateAutoCollectionV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateAutoCollectionV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateAutoCollectionV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateBnbTransferV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateBnbTransferV1Request
 */
export interface AccountApiPmarginCreateBnbTransferV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginCreateBnbTransferV1
     */
    readonly amount: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateBnbTransferV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginCreateBnbTransferV1
     */
    readonly transferSide: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateBnbTransferV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateCmLeverageV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateCmLeverageV1Request
 */
export interface AccountApiPmarginCreateCmLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateCmLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginCreateCmLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateCmLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateCmLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateCmPositionSideDualV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateCmPositionSideDualV1Request
 */
export interface AccountApiPmarginCreateCmPositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginCreateCmPositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateCmPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateCmPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateRepayFuturesNegativeBalanceV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateRepayFuturesNegativeBalanceV1Request
 */
export interface AccountApiPmarginCreateRepayFuturesNegativeBalanceV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateRepayFuturesNegativeBalanceV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateRepayFuturesNegativeBalanceV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateRepayFuturesSwitchV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateRepayFuturesSwitchV1Request
 */
export interface AccountApiPmarginCreateRepayFuturesSwitchV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginCreateRepayFuturesSwitchV1
     */
    readonly autoRepay: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateRepayFuturesSwitchV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateRepayFuturesSwitchV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateUmLeverageV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateUmLeverageV1Request
 */
export interface AccountApiPmarginCreateUmLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateUmLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginCreateUmLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateUmLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateUmLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateUmPositionSideDualV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginCreateUmPositionSideDualV1Request
 */
export interface AccountApiPmarginCreateUmPositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginCreateUmPositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateUmPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginCreateUmPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetAccountV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetAccountV1Request
 */
export interface AccountApiPmarginGetAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetBalanceV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetBalanceV1Request
 */
export interface AccountApiPmarginGetBalanceV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetBalanceV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetBalanceV1
     */
    readonly asset?: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetBalanceV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmAccountV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetCmAccountV1Request
 */
export interface AccountApiPmarginGetCmAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmCommissionRateV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetCmCommissionRateV1Request
 */
export interface AccountApiPmarginGetCmCommissionRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetCmCommissionRateV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmCommissionRateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmCommissionRateV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmIncomeV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetCmIncomeV1Request
 */
export interface AccountApiPmarginGetCmIncomeV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmIncomeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetCmIncomeV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
     * @type {string}
     * @memberof AccountApiPmarginGetCmIncomeV1
     */
    readonly incomeType?: string

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number}
     * @memberof AccountApiPmarginGetCmIncomeV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number}
     * @memberof AccountApiPmarginGetCmIncomeV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmIncomeV1
     */
    readonly page?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof AccountApiPmarginGetCmIncomeV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmIncomeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmLeverageBracketV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetCmLeverageBracketV1Request
 */
export interface AccountApiPmarginGetCmLeverageBracketV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmLeverageBracketV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetCmLeverageBracketV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmLeverageBracketV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmPositionRiskV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetCmPositionRiskV1Request
 */
export interface AccountApiPmarginGetCmPositionRiskV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmPositionRiskV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetCmPositionRiskV1
     */
    readonly marginAsset?: string

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetCmPositionRiskV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmPositionRiskV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmPositionSideDualV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetCmPositionSideDualV1Request
 */
export interface AccountApiPmarginGetCmPositionSideDualV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetCmPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginMarginInterestHistoryV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetMarginMarginInterestHistoryV1Request
 */
export interface AccountApiPmarginGetMarginMarginInterestHistoryV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginInterestHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetMarginMarginInterestHistoryV1
     */
    readonly asset?: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginInterestHistoryV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginInterestHistoryV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginInterestHistoryV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginInterestHistoryV1
     */
    readonly size?: number

    /**
     * Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
     * @type {string}
     * @memberof AccountApiPmarginGetMarginMarginInterestHistoryV1
     */
    readonly archived?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginInterestHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginMarginLoanV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetMarginMarginLoanV1Request
 */
export interface AccountApiPmarginGetMarginMarginLoanV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly timestamp: number

    /**
     * the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60;
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly txId?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly size?: number

    /**
     * Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
     * @type {string}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly archived?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMarginLoanV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginMaxBorrowableV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetMarginMaxBorrowableV1Request
 */
export interface AccountApiPmarginGetMarginMaxBorrowableV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetMarginMaxBorrowableV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMaxBorrowableV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMaxBorrowableV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginMaxWithdrawV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetMarginMaxWithdrawV1Request
 */
export interface AccountApiPmarginGetMarginMaxWithdrawV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetMarginMaxWithdrawV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMaxWithdrawV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof AccountApiPmarginGetMarginMaxWithdrawV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginRepayLoanV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetMarginRepayLoanV1Request
 */
export interface AccountApiPmarginGetMarginRepayLoanV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly timestamp: number

    /**
     * the tranId in &#x60;POST/papi/v1/repayLoan&#x60;
     * @type {number}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly txId?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly size?: number

    /**
     * Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
     * @type {string}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly archived?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof AccountApiPmarginGetMarginRepayLoanV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetPortfolioInterestHistoryV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetPortfolioInterestHistoryV1Request
 */
export interface AccountApiPmarginGetPortfolioInterestHistoryV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioInterestHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetPortfolioInterestHistoryV1
     */
    readonly asset?: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioInterestHistoryV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioInterestHistoryV1
     */
    readonly endTime?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioInterestHistoryV1
     */
    readonly size?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioInterestHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetPortfolioNegativeBalanceExchangeRecordV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request
 */
export interface AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1
     */
    readonly startTime: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetRateLimitOrderV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetRateLimitOrderV1Request
 */
export interface AccountApiPmarginGetRateLimitOrderV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetRateLimitOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetRateLimitOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetRepayFuturesSwitchV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetRepayFuturesSwitchV1Request
 */
export interface AccountApiPmarginGetRepayFuturesSwitchV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetRepayFuturesSwitchV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetRepayFuturesSwitchV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmAccountConfigV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmAccountConfigV1Request
 */
export interface AccountApiPmarginGetUmAccountConfigV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmAccountConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmAccountConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmAccountV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmAccountV1Request
 */
export interface AccountApiPmarginGetUmAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmAccountV2 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmAccountV2Request
 */
export interface AccountApiPmarginGetUmAccountV2Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmAccountV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmAccountV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmApiTradingStatusV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmApiTradingStatusV1Request
 */
export interface AccountApiPmarginGetUmApiTradingStatusV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmApiTradingStatusV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetUmApiTradingStatusV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmApiTradingStatusV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmCommissionRateV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmCommissionRateV1Request
 */
export interface AccountApiPmarginGetUmCommissionRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetUmCommissionRateV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmCommissionRateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmCommissionRateV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmIncomeAsynIdV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmIncomeAsynIdV1Request
 */
export interface AccountApiPmarginGetUmIncomeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof AccountApiPmarginGetUmIncomeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmIncomeAsynV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmIncomeAsynV1Request
 */
export interface AccountApiPmarginGetUmIncomeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmIncomeV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmIncomeV1Request
 */
export interface AccountApiPmarginGetUmIncomeV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetUmIncomeV1
     */
    readonly symbol?: string

    /**
     * TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
     * @type {string}
     * @memberof AccountApiPmarginGetUmIncomeV1
     */
    readonly incomeType?: string

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeV1
     */
    readonly page?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmIncomeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmLeverageBracketV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmLeverageBracketV1Request
 */
export interface AccountApiPmarginGetUmLeverageBracketV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmLeverageBracketV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetUmLeverageBracketV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmLeverageBracketV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmOrderAsynIdV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmOrderAsynIdV1Request
 */
export interface AccountApiPmarginGetUmOrderAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof AccountApiPmarginGetUmOrderAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmOrderAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmOrderAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmOrderAsynV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmOrderAsynV1Request
 */
export interface AccountApiPmarginGetUmOrderAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof AccountApiPmarginGetUmOrderAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof AccountApiPmarginGetUmOrderAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmOrderAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmOrderAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmPositionSideDualV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmPositionSideDualV1Request
 */
export interface AccountApiPmarginGetUmPositionSideDualV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmSymbolConfigV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmSymbolConfigV1Request
 */
export interface AccountApiPmarginGetUmSymbolConfigV1Request {
    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmSymbolConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof AccountApiPmarginGetUmSymbolConfigV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmSymbolConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmTradeAsynIdV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmTradeAsynIdV1Request
 */
export interface AccountApiPmarginGetUmTradeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof AccountApiPmarginGetUmTradeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmTradeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmTradeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmTradeAsynV1 operation in AccountApi.
 * @export
 * @interface AccountApiPmarginGetUmTradeAsynV1Request
 */
export interface AccountApiPmarginGetUmTradeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof AccountApiPmarginGetUmTradeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof AccountApiPmarginGetUmTradeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmTradeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiPmarginGetUmTradeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
    /**
     * Transfers specific asset from Futures Account to Margin account
     * @summary Fund Collection by Asset(TRADE)
     * @param {AccountApiPmarginCreateAssetCollectionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateAssetCollectionV1(requestParameters: AccountApiPmarginCreateAssetCollectionV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateAssetCollectionV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fund collection for Portfolio Margin
     * @summary Fund Auto-collection(TRADE)
     * @param {AccountApiPmarginCreateAutoCollectionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateAutoCollectionV1(requestParameters: AccountApiPmarginCreateAutoCollectionV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateAutoCollectionV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfer BNB in and out of UM
     * @summary BNB transfer (TRADE)
     * @param {AccountApiPmarginCreateBnbTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateBnbTransferV1(requestParameters: AccountApiPmarginCreateBnbTransferV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateBnbTransferV1(requestParameters.amount, requestParameters.timestamp, requestParameters.transferSide, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage of specific symbol in CM.
     * @summary Change CM Initial Leverage (TRADE)
     * @param {AccountApiPmarginCreateCmLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateCmLeverageV1(requestParameters: AccountApiPmarginCreateCmLeverageV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateCmLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * @summary Change CM Position Mode(TRADE)
     * @param {AccountApiPmarginCreateCmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateCmPositionSideDualV1(requestParameters: AccountApiPmarginCreateCmPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateCmPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Repay futures Negative Balance
     * @summary Repay futures Negative Balance(USER_DATA)
     * @param {AccountApiPmarginCreateRepayFuturesNegativeBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateRepayFuturesNegativeBalanceV1(requestParameters: AccountApiPmarginCreateRepayFuturesNegativeBalanceV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateRepayFuturesNegativeBalanceV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change Auto-repay-futures Status
     * @summary Change Auto-repay-futures Status(TRADE)
     * @param {AccountApiPmarginCreateRepayFuturesSwitchV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateRepayFuturesSwitchV1(requestParameters: AccountApiPmarginCreateRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateRepayFuturesSwitchV1(requestParameters.autoRepay, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage of specific symbol in UM.
     * @summary Change UM Initial Leverage(TRADE)
     * @param {AccountApiPmarginCreateUmLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateUmLeverageV1(requestParameters: AccountApiPmarginCreateUmLeverageV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateUmLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * @summary Change UM Position Mode(TRADE)
     * @param {AccountApiPmarginCreateUmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginCreateUmPositionSideDualV1(requestParameters: AccountApiPmarginCreateUmPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginCreateUmPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account information
     * @summary Account Information(USER_DATA)
     * @param {AccountApiPmarginGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetAccountV1(requestParameters: AccountApiPmarginGetAccountV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account balance
     * @summary Account Balance(USER_DATA)
     * @param {AccountApiPmarginGetBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetBalanceV1(requestParameters: AccountApiPmarginGetBalanceV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetBalanceV1(requestParameters.timestamp, requestParameters.asset, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current CM account asset and position information.
     * @summary Get CM Account Detail(USER_DATA)
     * @param {AccountApiPmarginGetCmAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetCmAccountV1(requestParameters: AccountApiPmarginGetCmAccountV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetCmAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get User Commission Rate for CM
     * @summary Get User Commission Rate for CM(USER_DATA)
     * @param {AccountApiPmarginGetCmCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetCmCommissionRateV1(requestParameters: AccountApiPmarginGetCmCommissionRateV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetCmCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CM Income History
     * @summary Get CM Income History(USER_DATA)
     * @param {AccountApiPmarginGetCmIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetCmIncomeV1(requestParameters: AccountApiPmarginGetCmIncomeV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetCmIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query CM notional and leverage brackets
     * @summary CM Notional and Leverage Brackets(USER_DATA)
     * @param {AccountApiPmarginGetCmLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetCmLeverageBracketV1(requestParameters: AccountApiPmarginGetCmLeverageBracketV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetCmLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current CM position information.
     * @summary Query CM Position Information(USER_DATA)
     * @param {AccountApiPmarginGetCmPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetCmPositionRiskV1(requestParameters: AccountApiPmarginGetCmPositionRiskV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetCmPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * @summary Get CM Current Position Mode(USER_DATA)
     * @param {AccountApiPmarginGetCmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetCmPositionSideDualV1(requestParameters: AccountApiPmarginGetCmPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetCmPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Margin Borrow/Loan Interest History
     * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
     * @param {AccountApiPmarginGetMarginMarginInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetMarginMarginInterestHistoryV1(requestParameters: AccountApiPmarginGetMarginMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetMarginMarginInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query margin loan record
     * @summary Query Margin Loan Record(USER_DATA)
     * @param {AccountApiPmarginGetMarginMarginLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetMarginMarginLoanV1(requestParameters: AccountApiPmarginGetMarginMarginLoanV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetMarginMarginLoanV1(requestParameters.asset, requestParameters.timestamp, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query margin max borrow
     * @summary Margin Max Borrow(USER_DATA)
     * @param {AccountApiPmarginGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetMarginMaxBorrowableV1(requestParameters: AccountApiPmarginGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetMarginMaxBorrowableV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Max Withdraw
     * @summary Query Margin Max Withdraw(USER_DATA)
     * @param {AccountApiPmarginGetMarginMaxWithdrawV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetMarginMaxWithdrawV1(requestParameters: AccountApiPmarginGetMarginMaxWithdrawV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetMarginMaxWithdrawV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query margin repay record.
     * @summary Query Margin repay Record(USER_DATA)
     * @param {AccountApiPmarginGetMarginRepayLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetMarginRepayLoanV1(requestParameters: AccountApiPmarginGetMarginRepayLoanV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetMarginRepayLoanV1(requestParameters.asset, requestParameters.timestamp, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query interest history of negative balance for portfolio margin.
     * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     * @param {AccountApiPmarginGetPortfolioInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetPortfolioInterestHistoryV1(requestParameters: AccountApiPmarginGetPortfolioInterestHistoryV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetPortfolioInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.startTime, requestParameters.endTime, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user negative balance auto exchange record
     * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
     * @param {AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetPortfolioNegativeBalanceExchangeRecordV1(requestParameters: AccountApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetPortfolioNegativeBalanceExchangeRecordV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query User Rate Limit
     * @summary Query User Rate Limit (USER_DATA)
     * @param {AccountApiPmarginGetRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetRateLimitOrderV1(requestParameters: AccountApiPmarginGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetRateLimitOrderV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Auto-repay-futures Status
     * @summary Get Auto-repay-futures Status(USER_DATA)
     * @param {AccountApiPmarginGetRepayFuturesSwitchV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetRepayFuturesSwitchV1(requestParameters: AccountApiPmarginGetRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetRepayFuturesSwitchV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query UM Futures account configuration
     * @summary UM Futures Account Configuration(USER_DATA)
     * @param {AccountApiPmarginGetUmAccountConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmAccountConfigV1(requestParameters: AccountApiPmarginGetUmAccountConfigV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmAccountConfigV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current UM account asset and position information.
     * @summary Get UM Account Detail(USER_DATA)
     * @param {AccountApiPmarginGetUmAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmAccountV1(requestParameters: AccountApiPmarginGetUmAccountV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current UM account asset and position information.
     * @summary Get UM Account Detail V2(USER_DATA)
     * @param {AccountApiPmarginGetUmAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmAccountV2(requestParameters: AccountApiPmarginGetUmAccountV2Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmAccountV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Portfolio Margin UM Trading Quantitative Rules Indicators
     * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     * @param {AccountApiPmarginGetUmApiTradingStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmApiTradingStatusV1(requestParameters: AccountApiPmarginGetUmApiTradingStatusV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmApiTradingStatusV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get User Commission Rate for UM
     * @summary Get User Commission Rate for UM(USER_DATA)
     * @param {AccountApiPmarginGetUmCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmCommissionRateV1(requestParameters: AccountApiPmarginGetUmCommissionRateV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UM futures Transaction download link by Id
     * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
     * @param {AccountApiPmarginGetUmIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmIncomeAsynIdV1(requestParameters: AccountApiPmarginGetUmIncomeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for UM futures transaction history
     * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
     * @param {AccountApiPmarginGetUmIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmIncomeAsynV1(requestParameters: AccountApiPmarginGetUmIncomeAsynV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UM Income History
     * @summary Get UM Income History(USER_DATA)
     * @param {AccountApiPmarginGetUmIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmIncomeV1(requestParameters: AccountApiPmarginGetUmIncomeV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query UM notional and leverage brackets
     * @summary UM Notional and Leverage Brackets (USER_DATA)
     * @param {AccountApiPmarginGetUmLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmLeverageBracketV1(requestParameters: AccountApiPmarginGetUmLeverageBracketV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UM futures order download link by Id
     * @summary Get UM Futures Order Download Link by Id(USER_DATA)
     * @param {AccountApiPmarginGetUmOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmOrderAsynIdV1(requestParameters: AccountApiPmarginGetUmOrderAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for UM futures order history
     * @summary Get Download Id For UM Futures Order History (USER_DATA)
     * @param {AccountApiPmarginGetUmOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmOrderAsynV1(requestParameters: AccountApiPmarginGetUmOrderAsynV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current UM position information.
     * @summary Query UM Position Information(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmPositionRiskV1(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmPositionRiskV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * @summary Get UM Current Position Mode(USER_DATA)
     * @param {AccountApiPmarginGetUmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmPositionSideDualV1(requestParameters: AccountApiPmarginGetUmPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current UM account symbol configuration.
     * @summary UM Futures Symbol Configuration(USER_DATA)
     * @param {AccountApiPmarginGetUmSymbolConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmSymbolConfigV1(requestParameters: AccountApiPmarginGetUmSymbolConfigV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmSymbolConfigV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UM futures trade download link by Id
     * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
     * @param {AccountApiPmarginGetUmTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmTradeAsynIdV1(requestParameters: AccountApiPmarginGetUmTradeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for UM futures trade history
     * @summary Get Download Id For UM Futures Trade History (USER_DATA)
     * @param {AccountApiPmarginGetUmTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public pmarginGetUmTradeAsynV1(requestParameters: AccountApiPmarginGetUmTradeAsynV1Request, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pmarginGetUmTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

