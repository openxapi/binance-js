/* tslint:disable */
/* eslint-disable */
/**
 * Binance Portfolio Margin API
 * OpenAPI specification for Binance exchange - Pmargin API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { PmarginCreateCmConditionalOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateCmOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateMarginLoanV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateMarginOrderOcoV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateMarginRepayDebtV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateRepayLoanV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateUmConditionalOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateUmFeeBurnV1Resp } from '../model';
// @ts-ignore
import type { PmarginCreateUmOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteCmAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteCmConditionalAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteCmConditionalOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteCmOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteMarginAllOpenOrdersV1RespInner } from '../model';
// @ts-ignore
import type { PmarginDeleteMarginOrderListV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteUmAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteUmConditionalAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteUmConditionalOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginDeleteUmOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetCmAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmConditionalAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmConditionalOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetCmConditionalOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmConditionalOrderHistoryV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetCmForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetCmOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetCmOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetCmUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetMarginAllOrderListV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetMarginAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetMarginForceOrdersV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetMarginMyTradesV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetMarginOpenOrderListV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetMarginOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetMarginOrderListV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmConditionalAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmConditionalOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmConditionalOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmConditionalOrderHistoryV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmFeeBurnV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { PmarginGetUmOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginGetUmUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { PmarginUpdateCmOrderV1Resp } from '../model';
// @ts-ignore
import type { PmarginUpdateUmOrderV1Resp } from '../model';
/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * New CM Conditional Order
         * @summary New CM Conditional Order(TRADE)
         * @param {string} side 
         * @param {string} strategyType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [newClientStrategyId] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateCmConditionalOrderV1: async (side: string, strategyType: string, symbol: string, timestamp: number, activationPrice?: string, callbackRate?: string, newClientStrategyId?: string, positionSide?: string, price?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('pmarginCreateCmConditionalOrderV1', 'side', side)
            // verify required parameter 'strategyType' is not null or undefined
            assertParamExists('pmarginCreateCmConditionalOrderV1', 'strategyType', strategyType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginCreateCmConditionalOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateCmConditionalOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (newClientStrategyId !== undefined) { 
                localVarFormParams.set('newClientStrategyId', newClientStrategyId as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place new CM order
         * @summary New CM Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateCmOrderV1: async (side: string, symbol: string, timestamp: number, type: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('pmarginCreateCmOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginCreateCmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateCmOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('pmarginCreateCmOrderV1', 'type', type)
            const localVarPath = `/papi/v1/cm/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply for a margin loan.
         * @summary Margin Account Borrow(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateMarginLoanV1: async (amount: string, asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('pmarginCreateMarginLoanV1', 'amount', amount)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pmarginCreateMarginLoanV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateMarginLoanV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/marginLoan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateMarginOrderOcoV1: async (price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, limitClientOrderId?: string, limitIcebergQty?: string, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, sideEffectType?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderOcoV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderOcoV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderOcoV1', 'side', side)
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderOcoV1', 'stopPrice', stopPrice)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderOcoV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderOcoV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/order/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (limitClientOrderId !== undefined) { 
                localVarFormParams.set('limitClientOrderId', limitClientOrderId as any);
            }
    
            if (limitIcebergQty !== undefined) { 
                localVarFormParams.set('limitIcebergQty', limitIcebergQty as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (sideEffectType !== undefined) { 
                localVarFormParams.set('sideEffectType', sideEffectType as any);
            }
    
            if (stopClientOrderId !== undefined) { 
                localVarFormParams.set('stopClientOrderId', stopClientOrderId as any);
            }
    
            if (stopIcebergQty !== undefined) { 
                localVarFormParams.set('stopIcebergQty', stopIcebergQty as any);
            }
    
            if (stopLimitPrice !== undefined) { 
                localVarFormParams.set('stopLimitPrice', stopLimitPrice as any);
            }
    
            if (stopLimitTimeInForce !== undefined) { 
                localVarFormParams.set('stopLimitTimeInForce', stopLimitTimeInForce as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * New Margin Order
         * @summary New Margin Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateMarginOrderV1: async (side: string, symbol: string, timestamp: number, type: string, autoRepayAtCancel?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, sideEffectType?: string, stopPrice?: string, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('pmarginCreateMarginOrderV1', 'type', type)
            const localVarPath = `/papi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (autoRepayAtCancel !== undefined) { 
                localVarFormParams.set('autoRepayAtCancel', autoRepayAtCancel as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (sideEffectType !== undefined) { 
                localVarFormParams.set('sideEffectType', sideEffectType as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Repay debt for a margin loan.
         * @summary Margin Account Repay Debt(TRADE)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {string} [amount] 
         * @param {number} [recvWindow] 
         * @param {string} [specifyRepayAssets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateMarginRepayDebtV1: async (asset: string, timestamp: number, amount?: string, recvWindow?: number, specifyRepayAssets?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pmarginCreateMarginRepayDebtV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateMarginRepayDebtV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/repay-debt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (specifyRepayAssets !== undefined) { 
                localVarFormParams.set('specifyRepayAssets', specifyRepayAssets as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Repay for a margin loan.
         * @summary Margin Account Repay(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateRepayLoanV1: async (amount: string, asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('pmarginCreateRepayLoanV1', 'amount', amount)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pmarginCreateRepayLoanV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateRepayLoanV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/repayLoan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place new UM conditional order
         * @summary New UM Conditional Order (TRADE)
         * @param {string} side 
         * @param {string} strategyType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientStrategyId] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmConditionalOrderV1: async (side: string, strategyType: string, symbol: string, timestamp: number, activationPrice?: string, callbackRate?: string, goodTillDate?: number, newClientStrategyId?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('pmarginCreateUmConditionalOrderV1', 'side', side)
            // verify required parameter 'strategyType' is not null or undefined
            assertParamExists('pmarginCreateUmConditionalOrderV1', 'strategyType', strategyType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginCreateUmConditionalOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateUmConditionalOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientStrategyId !== undefined) { 
                localVarFormParams.set('newClientStrategyId', newClientStrategyId as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
         * @param {string} feeBurn 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmFeeBurnV1: async (feeBurn: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feeBurn' is not null or undefined
            assertParamExists('pmarginCreateUmFeeBurnV1', 'feeBurn', feeBurn)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateUmFeeBurnV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/feeBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (feeBurn !== undefined) { 
                localVarFormParams.set('feeBurn', feeBurn as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place new UM order
         * @summary New UM Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmOrderV1: async (side: string, symbol: string, timestamp: number, type: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('pmarginCreateUmOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginCreateUmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginCreateUmOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('pmarginCreateUmOrderV1', 'type', type)
            const localVarPath = `/papi/v1/um/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All CM Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteCmAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteCmAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteCmAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All CM Open Conditional Orders
         * @summary Cancel All CM Open Conditional Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteCmConditionalAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteCmConditionalAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteCmConditionalAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel CM Conditional Order
         * @summary Cancel CM Conditional Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteCmConditionalOrderV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteCmConditionalOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteCmConditionalOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active LIMIT order
         * @summary Cancel CM Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteCmOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteCmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteCmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Margin Account All Open Orders on a Symbol
         * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteMarginAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteMarginAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteMarginAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Margin Account OCO Orders
         * @summary Cancel Margin Account OCO Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteMarginOrderListV1: async (symbol: string, timestamp: number, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteMarginOrderListV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteMarginOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (listClientOrderId !== undefined) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Margin Account Order
         * @summary Cancel Margin Account Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteMarginOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteMarginOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All UM Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteUmAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteUmAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteUmAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All UM Open Conditional Orders
         * @summary Cancel All UM Open Conditional Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteUmConditionalAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteUmConditionalAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteUmConditionalAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel UM Conditional Order
         * @summary Cancel UM Conditional Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteUmConditionalOrderV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteUmConditionalOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteUmConditionalOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active UM LIMIT order
         * @summary Cancel UM Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteUmOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginDeleteUmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginDeleteUmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query CM Position ADL Quantile Estimation
         * @summary CM Position ADL Quantile Estimation(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmAdlQuantileV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/cm/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account CM orders; active, canceled, or filled.
         * @summary Query All CM Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmAllOrdersV1: async (symbol: string, timestamp: number, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetCmAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query All CM Conditional Orders
         * @summary Query All CM Conditional Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [strategyId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmConditionalAllOrdersV1: async (timestamp: number, symbol?: string, strategyId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmConditionalAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current CM Open Conditional Order
         * @summary Query Current CM Open Conditional Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmConditionalOpenOrderV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetCmConditionalOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmConditionalOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
         * @summary Query All Current CM Open Conditional Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmConditionalOpenOrdersV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmConditionalOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query CM Conditional Order History
         * @summary Query CM Conditional Order History(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmConditionalOrderHistoryV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetCmConditionalOrderHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmConditionalOrderHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/orderHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User\'s CM Force Orders
         * @summary Query User\'s CM Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query current CM open order
         * @summary Query Current CM Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetCmOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current CM Open Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmOpenOrdersV1: async (timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Query CM Modify Order History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50, max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetCmOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an CM order\'s status.
         * @summary Query CM Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetCmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and CM symbol.
         * @summary CM Account Trade List(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmUserTradesV1: async (timestamp: number, symbol?: string, pair?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetCmUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [fromId] If supplied, neither startTime or endTime can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginAllOrderListV1: async (timestamp: number, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginAllOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/allOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query All Margin Account Orders
         * @summary Query All Margin Account Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginAllOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetMarginAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user\'s margin force orders
         * @summary Query User\'s Margin Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginForceOrdersV1: async (timestamp: number, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Margin Account Trade List
         * @summary Margin Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMyTradesV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetMarginMyTradesV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginMyTradesV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/myTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginOpenOrderListV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginOpenOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/openOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current Margin Open Order
         * @summary Query Current Margin Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetMarginOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [orderListId] Either orderListId or origClientOrderId must be provided
         * @param {string} [origClientOrderId] Either orderListId or origClientOrderId must be provided
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginOrderListV1: async (timestamp: number, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account Order
         * @summary Query Margin Account Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetMarginOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query UM Position ADL Quantile Estimation
         * @summary UM Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAdlQuantileV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmAdlQuantileV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account UM orders; active, canceled, or filled.
         * @summary Query All UM Orders(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAllOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetUmAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query All UM Conditional Orders
         * @summary Query All UM Conditional Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [strategyId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmConditionalAllOrdersV1: async (timestamp: number, symbol?: string, strategyId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmConditionalAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current UM Open Conditional Order
         * @summary Query Current UM Open Conditional Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmConditionalOpenOrderV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetUmConditionalOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmConditionalOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open conditional orders on a symbol.
         * @summary Query All Current UM Open Conditional Orders(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmConditionalOpenOrdersV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/um/conditional/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query UM Conditional Order History
         * @summary Query UM Conditional Order History(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmConditionalOrderHistoryV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetUmConditionalOrderHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmConditionalOrderHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/orderHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
         * @summary Get UM Futures BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmFeeBurnV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmFeeBurnV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/feeBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User\'s UM Force Orders
         * @summary Query User\'s UM Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query current UM open order
         * @summary Query Current UM Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetUmOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current UM Open Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOpenOrdersV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Query UM Modify Order History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 500, max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetUmOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an UM order\'s status.
         * @summary Query UM Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetUmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and UM symbol.
         * @summary UM Account Trade List(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmUserTradesV1: async (symbol: string, timestamp: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginGetUmUserTradesV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginGetUmUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify CM Order(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginUpdateCmOrderV1: async (price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('pmarginUpdateCmOrderV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('pmarginUpdateCmOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('pmarginUpdateCmOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginUpdateCmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginUpdateCmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify UM Order(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginUpdateUmOrderV1: async (price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('pmarginUpdateUmOrderV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('pmarginUpdateUmOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('pmarginUpdateUmOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('pmarginUpdateUmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('pmarginUpdateUmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration)
    return {
        /**
         * New CM Conditional Order
         * @summary New CM Conditional Order(TRADE)
         * @param {string} side 
         * @param {string} strategyType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [newClientStrategyId] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateCmConditionalOrderV1(side: string, strategyType: string, symbol: string, timestamp: number, activationPrice?: string, callbackRate?: string, newClientStrategyId?: string, positionSide?: string, price?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateCmConditionalOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateCmConditionalOrderV1(side, strategyType, symbol, timestamp, activationPrice, callbackRate, newClientStrategyId, positionSide, price, priceProtect, quantity, recvWindow, reduceOnly, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateCmConditionalOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Place new CM order
         * @summary New CM Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateCmOrderV1(side: string, symbol: string, timestamp: number, type: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateCmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateCmOrderV1(side, symbol, timestamp, type, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, quantity, recvWindow, reduceOnly, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateCmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Apply for a margin loan.
         * @summary Margin Account Borrow(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateMarginLoanV1(amount: string, asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateMarginLoanV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateMarginLoanV1(amount, asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateMarginLoanV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateMarginOrderOcoV1(price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, limitClientOrderId?: string, limitIcebergQty?: string, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, sideEffectType?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateMarginOrderOcoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateMarginOrderOcoV1(price, quantity, side, stopPrice, symbol, timestamp, limitClientOrderId, limitIcebergQty, listClientOrderId, newOrderRespType, recvWindow, sideEffectType, stopClientOrderId, stopIcebergQty, stopLimitPrice, stopLimitTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateMarginOrderOcoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * New Margin Order
         * @summary New Margin Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateMarginOrderV1(side: string, symbol: string, timestamp: number, type: string, autoRepayAtCancel?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, sideEffectType?: string, stopPrice?: string, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateMarginOrderV1(side, symbol, timestamp, type, autoRepayAtCancel, icebergQty, newClientOrderId, newOrderRespType, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, sideEffectType, stopPrice, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Repay debt for a margin loan.
         * @summary Margin Account Repay Debt(TRADE)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {string} [amount] 
         * @param {number} [recvWindow] 
         * @param {string} [specifyRepayAssets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateMarginRepayDebtV1(asset: string, timestamp: number, amount?: string, recvWindow?: number, specifyRepayAssets?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateMarginRepayDebtV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateMarginRepayDebtV1(asset, timestamp, amount, recvWindow, specifyRepayAssets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateMarginRepayDebtV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Repay for a margin loan.
         * @summary Margin Account Repay(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateRepayLoanV1(amount: string, asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateRepayLoanV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateRepayLoanV1(amount, asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateRepayLoanV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Place new UM conditional order
         * @summary New UM Conditional Order (TRADE)
         * @param {string} side 
         * @param {string} strategyType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientStrategyId] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateUmConditionalOrderV1(side: string, strategyType: string, symbol: string, timestamp: number, activationPrice?: string, callbackRate?: string, goodTillDate?: number, newClientStrategyId?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateUmConditionalOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateUmConditionalOrderV1(side, strategyType, symbol, timestamp, activationPrice, callbackRate, goodTillDate, newClientStrategyId, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateUmConditionalOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
         * @param {string} feeBurn 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateUmFeeBurnV1(feeBurn: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateUmFeeBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateUmFeeBurnV1(feeBurn, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateUmFeeBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Place new UM order
         * @summary New UM Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginCreateUmOrderV1(side: string, symbol: string, timestamp: number, type: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginCreateUmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginCreateUmOrderV1(side, symbol, timestamp, type, goodTillDate, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, quantity, recvWindow, reduceOnly, selfTradePreventionMode, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginCreateUmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All CM Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteCmAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteCmAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteCmAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteCmAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All CM Open Conditional Orders
         * @summary Cancel All CM Open Conditional Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteCmConditionalAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteCmConditionalAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteCmConditionalAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteCmConditionalAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel CM Conditional Order
         * @summary Cancel CM Conditional Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteCmConditionalOrderV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteCmConditionalOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteCmConditionalOrderV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteCmConditionalOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active LIMIT order
         * @summary Cancel CM Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteCmOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteCmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteCmOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteCmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Margin Account All Open Orders on a Symbol
         * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteMarginAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginDeleteMarginAllOpenOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteMarginAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteMarginAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Margin Account OCO Orders
         * @summary Cancel Margin Account OCO Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteMarginOrderListV1(symbol: string, timestamp: number, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteMarginOrderListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteMarginOrderListV1(symbol, timestamp, orderListId, listClientOrderId, newClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteMarginOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Margin Account Order
         * @summary Cancel Margin Account Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteMarginOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteMarginOrderV1(symbol, timestamp, orderId, origClientOrderId, newClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All UM Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteUmAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteUmAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteUmAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteUmAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All UM Open Conditional Orders
         * @summary Cancel All UM Open Conditional Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteUmConditionalAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteUmConditionalAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteUmConditionalAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteUmConditionalAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel UM Conditional Order
         * @summary Cancel UM Conditional Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteUmConditionalOrderV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteUmConditionalOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteUmConditionalOrderV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteUmConditionalOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active UM LIMIT order
         * @summary Cancel UM Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginDeleteUmOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginDeleteUmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginDeleteUmOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginDeleteUmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query CM Position ADL Quantile Estimation
         * @summary CM Position ADL Quantile Estimation(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmAdlQuantileV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmAdlQuantileV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account CM orders; active, canceled, or filled.
         * @summary Query All CM Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmAllOrdersV1(symbol: string, timestamp: number, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmAllOrdersV1(symbol, timestamp, pair, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query All CM Conditional Orders
         * @summary Query All CM Conditional Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [strategyId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmConditionalAllOrdersV1(timestamp: number, symbol?: string, strategyId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmConditionalAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmConditionalAllOrdersV1(timestamp, symbol, strategyId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmConditionalAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current CM Open Conditional Order
         * @summary Query Current CM Open Conditional Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmConditionalOpenOrderV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetCmConditionalOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmConditionalOpenOrderV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmConditionalOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
         * @summary Query All Current CM Open Conditional Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmConditionalOpenOrdersV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmConditionalOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmConditionalOpenOrdersV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmConditionalOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query CM Conditional Order History
         * @summary Query CM Conditional Order History(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmConditionalOrderHistoryV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetCmConditionalOrderHistoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmConditionalOrderHistoryV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmConditionalOrderHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query User\'s CM Force Orders
         * @summary Query User\'s CM Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmForceOrdersV1(timestamp, symbol, autoCloseType, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query current CM open order
         * @summary Query Current CM Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetCmOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current CM Open Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmOpenOrdersV1(timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmOpenOrdersV1(timestamp, symbol, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Query CM Modify Order History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50, max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an CM order\'s status.
         * @summary Query CM Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetCmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and CM symbol.
         * @summary CM Account Trade List(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetCmUserTradesV1(timestamp: number, symbol?: string, pair?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetCmUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetCmUserTradesV1(timestamp, symbol, pair, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetCmUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [fromId] If supplied, neither startTime or endTime can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginAllOrderListV1(timestamp: number, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetMarginAllOrderListV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginAllOrderListV1(timestamp, fromId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetMarginAllOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query All Margin Account Orders
         * @summary Query All Margin Account Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginAllOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetMarginAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginAllOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetMarginAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user\'s margin force orders
         * @summary Query User\'s Margin Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginForceOrdersV1(timestamp: number, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetMarginForceOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginForceOrdersV1(timestamp, startTime, endTime, current, size, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetMarginForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Margin Account Trade List
         * @summary Margin Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginMyTradesV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetMarginMyTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginMyTradesV1(symbol, timestamp, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetMarginMyTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginOpenOrderListV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetMarginOpenOrderListV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginOpenOrderListV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetMarginOpenOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current Margin Open Order
         * @summary Query Current Margin Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetMarginOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetMarginOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [orderListId] Either orderListId or origClientOrderId must be provided
         * @param {string} [origClientOrderId] Either orderListId or origClientOrderId must be provided
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginOrderListV1(timestamp: number, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetMarginOrderListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginOrderListV1(timestamp, orderListId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetMarginOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account Order
         * @summary Query Margin Account Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetMarginOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetMarginOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query UM Position ADL Quantile Estimation
         * @summary UM Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmAdlQuantileV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmAdlQuantileV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account UM orders; active, canceled, or filled.
         * @summary Query All UM Orders(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmAllOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmAllOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query All UM Conditional Orders
         * @summary Query All UM Conditional Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [strategyId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmConditionalAllOrdersV1(timestamp: number, symbol?: string, strategyId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmConditionalAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmConditionalAllOrdersV1(timestamp, symbol, strategyId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmConditionalAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current UM Open Conditional Order
         * @summary Query Current UM Open Conditional Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmConditionalOpenOrderV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmConditionalOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmConditionalOpenOrderV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmConditionalOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open conditional orders on a symbol.
         * @summary Query All Current UM Open Conditional Orders(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmConditionalOpenOrdersV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmConditionalOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmConditionalOpenOrdersV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmConditionalOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query UM Conditional Order History
         * @summary Query UM Conditional Order History(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmConditionalOrderHistoryV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmConditionalOrderHistoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmConditionalOrderHistoryV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmConditionalOrderHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
         * @summary Get UM Futures BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmFeeBurnV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmFeeBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmFeeBurnV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmFeeBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query User\'s UM Force Orders
         * @summary Query User\'s UM Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmForceOrdersV1(timestamp, symbol, autoCloseType, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query current UM open order
         * @summary Query Current UM Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current UM Open Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmOpenOrdersV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmOpenOrdersV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Query UM Modify Order History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 500, max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an UM order\'s status.
         * @summary Query UM Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetUmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and UM symbol.
         * @summary UM Account Trade List(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginGetUmUserTradesV1(symbol: string, timestamp: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginGetUmUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginGetUmUserTradesV1(symbol, timestamp, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginGetUmUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify CM Order(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginUpdateCmOrderV1(price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginUpdateCmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginUpdateCmOrderV1(price, quantity, side, symbol, timestamp, orderId, origClientOrderId, priceMatch, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginUpdateCmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify UM Order(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pmarginUpdateUmOrderV1(price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginUpdateUmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pmarginUpdateUmOrderV1(price, quantity, side, symbol, timestamp, orderId, origClientOrderId, priceMatch, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.pmarginUpdateUmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeApiFp(configuration)
    return {
        /**
         * New CM Conditional Order
         * @summary New CM Conditional Order(TRADE)
         * @param {TradeApiPmarginCreateCmConditionalOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateCmConditionalOrderV1(requestParameters: TradeApiPmarginCreateCmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateCmConditionalOrderV1Resp> {
            return localVarFp.pmarginCreateCmConditionalOrderV1(requestParameters.side, requestParameters.strategyType, requestParameters.symbol, requestParameters.timestamp, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.newClientStrategyId, requestParameters.positionSide, requestParameters.price, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Place new CM order
         * @summary New CM Order(TRADE)
         * @param {TradeApiPmarginCreateCmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateCmOrderV1(requestParameters: TradeApiPmarginCreateCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateCmOrderV1Resp> {
            return localVarFp.pmarginCreateCmOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply for a margin loan.
         * @summary Margin Account Borrow(MARGIN)
         * @param {TradeApiPmarginCreateMarginLoanV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateMarginLoanV1(requestParameters: TradeApiPmarginCreateMarginLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateMarginLoanV1Resp> {
            return localVarFp.pmarginCreateMarginLoanV1(requestParameters.amount, requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO(TRADE)
         * @param {TradeApiPmarginCreateMarginOrderOcoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateMarginOrderOcoV1(requestParameters: TradeApiPmarginCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateMarginOrderOcoV1Resp> {
            return localVarFp.pmarginCreateMarginOrderOcoV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.sideEffectType, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * New Margin Order
         * @summary New Margin Order(TRADE)
         * @param {TradeApiPmarginCreateMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateMarginOrderV1(requestParameters: TradeApiPmarginCreateMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateMarginOrderV1Resp> {
            return localVarFp.pmarginCreateMarginOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.autoRepayAtCancel, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.stopPrice, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Repay debt for a margin loan.
         * @summary Margin Account Repay Debt(TRADE)
         * @param {TradeApiPmarginCreateMarginRepayDebtV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateMarginRepayDebtV1(requestParameters: TradeApiPmarginCreateMarginRepayDebtV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateMarginRepayDebtV1Resp> {
            return localVarFp.pmarginCreateMarginRepayDebtV1(requestParameters.asset, requestParameters.timestamp, requestParameters.amount, requestParameters.recvWindow, requestParameters.specifyRepayAssets, options).then((request) => request(axios, basePath));
        },
        /**
         * Repay for a margin loan.
         * @summary Margin Account Repay(MARGIN)
         * @param {TradeApiPmarginCreateRepayLoanV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateRepayLoanV1(requestParameters: TradeApiPmarginCreateRepayLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateRepayLoanV1Resp> {
            return localVarFp.pmarginCreateRepayLoanV1(requestParameters.amount, requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Place new UM conditional order
         * @summary New UM Conditional Order (TRADE)
         * @param {TradeApiPmarginCreateUmConditionalOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmConditionalOrderV1(requestParameters: TradeApiPmarginCreateUmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmConditionalOrderV1Resp> {
            return localVarFp.pmarginCreateUmConditionalOrderV1(requestParameters.side, requestParameters.strategyType, requestParameters.symbol, requestParameters.timestamp, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.goodTillDate, requestParameters.newClientStrategyId, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
         * @param {TradeApiPmarginCreateUmFeeBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmFeeBurnV1(requestParameters: TradeApiPmarginCreateUmFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmFeeBurnV1Resp> {
            return localVarFp.pmarginCreateUmFeeBurnV1(requestParameters.feeBurn, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Place new UM order
         * @summary New UM Order (TRADE)
         * @param {TradeApiPmarginCreateUmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginCreateUmOrderV1(requestParameters: TradeApiPmarginCreateUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmOrderV1Resp> {
            return localVarFp.pmarginCreateUmOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All CM Open Orders(TRADE)
         * @param {TradeApiPmarginDeleteCmAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteCmAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteCmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteCmAllOpenOrdersV1Resp> {
            return localVarFp.pmarginDeleteCmAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All CM Open Conditional Orders
         * @summary Cancel All CM Open Conditional Orders(TRADE)
         * @param {TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteCmConditionalAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteCmConditionalAllOpenOrdersV1Resp> {
            return localVarFp.pmarginDeleteCmConditionalAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel CM Conditional Order
         * @summary Cancel CM Conditional Order(TRADE)
         * @param {TradeApiPmarginDeleteCmConditionalOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteCmConditionalOrderV1(requestParameters: TradeApiPmarginDeleteCmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteCmConditionalOrderV1Resp> {
            return localVarFp.pmarginDeleteCmConditionalOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active LIMIT order
         * @summary Cancel CM Order(TRADE)
         * @param {TradeApiPmarginDeleteCmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteCmOrderV1(requestParameters: TradeApiPmarginDeleteCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteCmOrderV1Resp> {
            return localVarFp.pmarginDeleteCmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Margin Account All Open Orders on a Symbol
         * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
         * @param {TradeApiPmarginDeleteMarginAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteMarginAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteMarginAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginDeleteMarginAllOpenOrdersV1RespInner>> {
            return localVarFp.pmarginDeleteMarginAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Margin Account OCO Orders
         * @summary Cancel Margin Account OCO Orders(TRADE)
         * @param {TradeApiPmarginDeleteMarginOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteMarginOrderListV1(requestParameters: TradeApiPmarginDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteMarginOrderListV1Resp> {
            return localVarFp.pmarginDeleteMarginOrderListV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Margin Account Order
         * @summary Cancel Margin Account Order(TRADE)
         * @param {TradeApiPmarginDeleteMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteMarginOrderV1(requestParameters: TradeApiPmarginDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteMarginOrderV1Resp> {
            return localVarFp.pmarginDeleteMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All UM Open Orders(TRADE)
         * @param {TradeApiPmarginDeleteUmAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteUmAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteUmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteUmAllOpenOrdersV1Resp> {
            return localVarFp.pmarginDeleteUmAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All UM Open Conditional Orders
         * @summary Cancel All UM Open Conditional Orders (TRADE)
         * @param {TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteUmConditionalAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteUmConditionalAllOpenOrdersV1Resp> {
            return localVarFp.pmarginDeleteUmConditionalAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel UM Conditional Order
         * @summary Cancel UM Conditional Order(TRADE)
         * @param {TradeApiPmarginDeleteUmConditionalOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteUmConditionalOrderV1(requestParameters: TradeApiPmarginDeleteUmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteUmConditionalOrderV1Resp> {
            return localVarFp.pmarginDeleteUmConditionalOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active UM LIMIT order
         * @summary Cancel UM Order(TRADE)
         * @param {TradeApiPmarginDeleteUmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginDeleteUmOrderV1(requestParameters: TradeApiPmarginDeleteUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteUmOrderV1Resp> {
            return localVarFp.pmarginDeleteUmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query CM Position ADL Quantile Estimation
         * @summary CM Position ADL Quantile Estimation(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmAdlQuantileV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmAdlQuantileV1RespItem>> {
            return localVarFp.pmarginGetCmAdlQuantileV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account CM orders; active, canceled, or filled.
         * @summary Query All CM Orders (USER_DATA)
         * @param {TradeApiPmarginGetCmAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmAllOrdersV1(requestParameters: TradeApiPmarginGetCmAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmAllOrdersV1RespItem>> {
            return localVarFp.pmarginGetCmAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query All CM Conditional Orders
         * @summary Query All CM Conditional Orders(USER_DATA)
         * @param {TradeApiPmarginGetCmConditionalAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmConditionalAllOrdersV1(requestParameters: TradeApiPmarginGetCmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmConditionalAllOrdersV1RespItem>> {
            return localVarFp.pmarginGetCmConditionalAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.strategyId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current CM Open Conditional Order
         * @summary Query Current CM Open Conditional Order(USER_DATA)
         * @param {TradeApiPmarginGetCmConditionalOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmConditionalOpenOrderV1(requestParameters: TradeApiPmarginGetCmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmConditionalOpenOrderV1Resp> {
            return localVarFp.pmarginGetCmConditionalOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
         * @summary Query All Current CM Open Conditional Orders (USER_DATA)
         * @param {TradeApiPmarginGetCmConditionalOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmConditionalOpenOrdersV1(requestParameters: TradeApiPmarginGetCmConditionalOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmConditionalOpenOrdersV1RespItem>> {
            return localVarFp.pmarginGetCmConditionalOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query CM Conditional Order History
         * @summary Query CM Conditional Order History(USER_DATA)
         * @param {TradeApiPmarginGetCmConditionalOrderHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmConditionalOrderHistoryV1(requestParameters: TradeApiPmarginGetCmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmConditionalOrderHistoryV1Resp> {
            return localVarFp.pmarginGetCmConditionalOrderHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User\'s CM Force Orders
         * @summary Query User\'s CM Force Orders(USER_DATA)
         * @param {TradeApiPmarginGetCmForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmForceOrdersV1(requestParameters: TradeApiPmarginGetCmForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmForceOrdersV1RespItem>> {
            return localVarFp.pmarginGetCmForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query current CM open order
         * @summary Query Current CM Open Order (USER_DATA)
         * @param {TradeApiPmarginGetCmOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmOpenOrderV1(requestParameters: TradeApiPmarginGetCmOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmOpenOrderV1Resp> {
            return localVarFp.pmarginGetCmOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current CM Open Orders(USER_DATA)
         * @param {TradeApiPmarginGetCmOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmOpenOrdersV1(requestParameters: TradeApiPmarginGetCmOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmOpenOrdersV1RespItem>> {
            return localVarFp.pmarginGetCmOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Query CM Modify Order History(TRADE)
         * @param {TradeApiPmarginGetCmOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmOrderAmendmentV1(requestParameters: TradeApiPmarginGetCmOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmOrderAmendmentV1RespItem>> {
            return localVarFp.pmarginGetCmOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an CM order\'s status.
         * @summary Query CM Order(USER_DATA)
         * @param {TradeApiPmarginGetCmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmOrderV1(requestParameters: TradeApiPmarginGetCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmOrderV1Resp> {
            return localVarFp.pmarginGetCmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and CM symbol.
         * @summary CM Account Trade List(USER_DATA)
         * @param {TradeApiPmarginGetCmUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetCmUserTradesV1(requestParameters: TradeApiPmarginGetCmUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmUserTradesV1RespItem>> {
            return localVarFp.pmarginGetCmUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {TradeApiPmarginGetMarginAllOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginAllOrderListV1(requestParameters: TradeApiPmarginGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginAllOrderListV1RespItem>> {
            return localVarFp.pmarginGetMarginAllOrderListV1(requestParameters.timestamp, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query All Margin Account Orders
         * @summary Query All Margin Account Orders (USER_DATA)
         * @param {TradeApiPmarginGetMarginAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginAllOrdersV1(requestParameters: TradeApiPmarginGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginAllOrdersV1RespItem>> {
            return localVarFp.pmarginGetMarginAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user\'s margin force orders
         * @summary Query User\'s Margin Force Orders(USER_DATA)
         * @param {TradeApiPmarginGetMarginForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginForceOrdersV1(requestParameters: TradeApiPmarginGetMarginForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginForceOrdersV1Resp> {
            return localVarFp.pmarginGetMarginForceOrdersV1(requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Margin Account Trade List
         * @summary Margin Account Trade List (USER_DATA)
         * @param {TradeApiPmarginGetMarginMyTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginMyTradesV1(requestParameters: TradeApiPmarginGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginMyTradesV1RespItem>> {
            return localVarFp.pmarginGetMarginMyTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {TradeApiPmarginGetMarginOpenOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginOpenOrderListV1(requestParameters: TradeApiPmarginGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginOpenOrderListV1RespItem>> {
            return localVarFp.pmarginGetMarginOpenOrderListV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current Margin Open Order
         * @summary Query Current Margin Open Order (USER_DATA)
         * @param {TradeApiPmarginGetMarginOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginOpenOrdersV1(requestParameters: TradeApiPmarginGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginOpenOrdersV1RespItem>> {
            return localVarFp.pmarginGetMarginOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {TradeApiPmarginGetMarginOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginOrderListV1(requestParameters: TradeApiPmarginGetMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginOrderListV1Resp> {
            return localVarFp.pmarginGetMarginOrderListV1(requestParameters.timestamp, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account Order
         * @summary Query Margin Account Order (USER_DATA)
         * @param {TradeApiPmarginGetMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetMarginOrderV1(requestParameters: TradeApiPmarginGetMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginOrderV1Resp> {
            return localVarFp.pmarginGetMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query UM Position ADL Quantile Estimation
         * @summary UM Position ADL Quantile Estimation(USER_DATA)
         * @param {TradeApiPmarginGetUmAdlQuantileV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAdlQuantileV1(requestParameters: TradeApiPmarginGetUmAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmAdlQuantileV1RespItem>> {
            return localVarFp.pmarginGetUmAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account UM orders; active, canceled, or filled.
         * @summary Query All UM Orders(USER_DATA)
         * @param {TradeApiPmarginGetUmAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmAllOrdersV1(requestParameters: TradeApiPmarginGetUmAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmAllOrdersV1RespItem>> {
            return localVarFp.pmarginGetUmAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query All UM Conditional Orders
         * @summary Query All UM Conditional Orders(USER_DATA)
         * @param {TradeApiPmarginGetUmConditionalAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmConditionalAllOrdersV1(requestParameters: TradeApiPmarginGetUmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmConditionalAllOrdersV1RespItem>> {
            return localVarFp.pmarginGetUmConditionalAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.strategyId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current UM Open Conditional Order
         * @summary Query Current UM Open Conditional Order(USER_DATA)
         * @param {TradeApiPmarginGetUmConditionalOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmConditionalOpenOrderV1(requestParameters: TradeApiPmarginGetUmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmConditionalOpenOrderV1Resp> {
            return localVarFp.pmarginGetUmConditionalOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open conditional orders on a symbol.
         * @summary Query All Current UM Open Conditional Orders(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmConditionalOpenOrdersV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmConditionalOpenOrdersV1RespItem>> {
            return localVarFp.pmarginGetUmConditionalOpenOrdersV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Query UM Conditional Order History
         * @summary Query UM Conditional Order History(USER_DATA)
         * @param {TradeApiPmarginGetUmConditionalOrderHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmConditionalOrderHistoryV1(requestParameters: TradeApiPmarginGetUmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmConditionalOrderHistoryV1Resp> {
            return localVarFp.pmarginGetUmConditionalOrderHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
         * @summary Get UM Futures BNB Burn Status (USER_DATA)
         * @param {TradeApiPmarginGetUmFeeBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmFeeBurnV1(requestParameters: TradeApiPmarginGetUmFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmFeeBurnV1Resp> {
            return localVarFp.pmarginGetUmFeeBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User\'s UM Force Orders
         * @summary Query User\'s UM Force Orders (USER_DATA)
         * @param {TradeApiPmarginGetUmForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmForceOrdersV1(requestParameters: TradeApiPmarginGetUmForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmForceOrdersV1RespItem>> {
            return localVarFp.pmarginGetUmForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query current UM open order
         * @summary Query Current UM Open Order(USER_DATA)
         * @param {TradeApiPmarginGetUmOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOpenOrderV1(requestParameters: TradeApiPmarginGetUmOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmOpenOrderV1Resp> {
            return localVarFp.pmarginGetUmOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current UM Open Orders(USER_DATA)
         * @param {TradeApiPmarginGetUmOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOpenOrdersV1(requestParameters: TradeApiPmarginGetUmOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmOpenOrdersV1RespItem>> {
            return localVarFp.pmarginGetUmOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Query UM Modify Order History(TRADE)
         * @param {TradeApiPmarginGetUmOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOrderAmendmentV1(requestParameters: TradeApiPmarginGetUmOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmOrderAmendmentV1RespItem>> {
            return localVarFp.pmarginGetUmOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an UM order\'s status.
         * @summary Query UM Order (USER_DATA)
         * @param {TradeApiPmarginGetUmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmOrderV1(requestParameters: TradeApiPmarginGetUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmOrderV1Resp> {
            return localVarFp.pmarginGetUmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and UM symbol.
         * @summary UM Account Trade List(USER_DATA)
         * @param {TradeApiPmarginGetUmUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginGetUmUserTradesV1(requestParameters: TradeApiPmarginGetUmUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmUserTradesV1RespItem>> {
            return localVarFp.pmarginGetUmUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify CM Order(TRADE)
         * @param {TradeApiPmarginUpdateCmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginUpdateCmOrderV1(requestParameters: TradeApiPmarginUpdateCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginUpdateCmOrderV1Resp> {
            return localVarFp.pmarginUpdateCmOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify UM Order(TRADE)
         * @param {TradeApiPmarginUpdateUmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pmarginUpdateUmOrderV1(requestParameters: TradeApiPmarginUpdateUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginUpdateUmOrderV1Resp> {
            return localVarFp.pmarginUpdateUmOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeApi - interface
 * @export
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * New CM Conditional Order
     * @summary New CM Conditional Order(TRADE)
     * @param {TradeApiPmarginCreateCmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateCmConditionalOrderV1(requestParameters: TradeApiPmarginCreateCmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateCmConditionalOrderV1Resp>;

    /**
     * Place new CM order
     * @summary New CM Order(TRADE)
     * @param {TradeApiPmarginCreateCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateCmOrderV1(requestParameters: TradeApiPmarginCreateCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateCmOrderV1Resp>;

    /**
     * Apply for a margin loan.
     * @summary Margin Account Borrow(MARGIN)
     * @param {TradeApiPmarginCreateMarginLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateMarginLoanV1(requestParameters: TradeApiPmarginCreateMarginLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateMarginLoanV1Resp>;

    /**
     * Send in a new OCO for a margin account
     * @summary Margin Account New OCO(TRADE)
     * @param {TradeApiPmarginCreateMarginOrderOcoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateMarginOrderOcoV1(requestParameters: TradeApiPmarginCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateMarginOrderOcoV1Resp>;

    /**
     * New Margin Order
     * @summary New Margin Order(TRADE)
     * @param {TradeApiPmarginCreateMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateMarginOrderV1(requestParameters: TradeApiPmarginCreateMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateMarginOrderV1Resp>;

    /**
     * Repay debt for a margin loan.
     * @summary Margin Account Repay Debt(TRADE)
     * @param {TradeApiPmarginCreateMarginRepayDebtV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateMarginRepayDebtV1(requestParameters: TradeApiPmarginCreateMarginRepayDebtV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateMarginRepayDebtV1Resp>;

    /**
     * Repay for a margin loan.
     * @summary Margin Account Repay(MARGIN)
     * @param {TradeApiPmarginCreateRepayLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateRepayLoanV1(requestParameters: TradeApiPmarginCreateRepayLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateRepayLoanV1Resp>;

    /**
     * Place new UM conditional order
     * @summary New UM Conditional Order (TRADE)
     * @param {TradeApiPmarginCreateUmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateUmConditionalOrderV1(requestParameters: TradeApiPmarginCreateUmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmConditionalOrderV1Resp>;

    /**
     * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
     * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
     * @param {TradeApiPmarginCreateUmFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateUmFeeBurnV1(requestParameters: TradeApiPmarginCreateUmFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmFeeBurnV1Resp>;

    /**
     * Place new UM order
     * @summary New UM Order (TRADE)
     * @param {TradeApiPmarginCreateUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginCreateUmOrderV1(requestParameters: TradeApiPmarginCreateUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginCreateUmOrderV1Resp>;

    /**
     * Cancel all active LIMIT orders on specific symbol
     * @summary Cancel All CM Open Orders(TRADE)
     * @param {TradeApiPmarginDeleteCmAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteCmAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteCmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteCmAllOpenOrdersV1Resp>;

    /**
     * Cancel All CM Open Conditional Orders
     * @summary Cancel All CM Open Conditional Orders(TRADE)
     * @param {TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteCmConditionalAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteCmConditionalAllOpenOrdersV1Resp>;

    /**
     * Cancel CM Conditional Order
     * @summary Cancel CM Conditional Order(TRADE)
     * @param {TradeApiPmarginDeleteCmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteCmConditionalOrderV1(requestParameters: TradeApiPmarginDeleteCmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteCmConditionalOrderV1Resp>;

    /**
     * Cancel an active LIMIT order
     * @summary Cancel CM Order(TRADE)
     * @param {TradeApiPmarginDeleteCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteCmOrderV1(requestParameters: TradeApiPmarginDeleteCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteCmOrderV1Resp>;

    /**
     * Cancel Margin Account All Open Orders on a Symbol
     * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
     * @param {TradeApiPmarginDeleteMarginAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteMarginAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteMarginAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginDeleteMarginAllOpenOrdersV1RespInner>>;

    /**
     * Cancel Margin Account OCO Orders
     * @summary Cancel Margin Account OCO Orders(TRADE)
     * @param {TradeApiPmarginDeleteMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteMarginOrderListV1(requestParameters: TradeApiPmarginDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteMarginOrderListV1Resp>;

    /**
     * Cancel Margin Account Order
     * @summary Cancel Margin Account Order(TRADE)
     * @param {TradeApiPmarginDeleteMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteMarginOrderV1(requestParameters: TradeApiPmarginDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteMarginOrderV1Resp>;

    /**
     * Cancel all active LIMIT orders on specific symbol
     * @summary Cancel All UM Open Orders(TRADE)
     * @param {TradeApiPmarginDeleteUmAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteUmAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteUmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteUmAllOpenOrdersV1Resp>;

    /**
     * Cancel All UM Open Conditional Orders
     * @summary Cancel All UM Open Conditional Orders (TRADE)
     * @param {TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteUmConditionalAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteUmConditionalAllOpenOrdersV1Resp>;

    /**
     * Cancel UM Conditional Order
     * @summary Cancel UM Conditional Order(TRADE)
     * @param {TradeApiPmarginDeleteUmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteUmConditionalOrderV1(requestParameters: TradeApiPmarginDeleteUmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteUmConditionalOrderV1Resp>;

    /**
     * Cancel an active UM LIMIT order
     * @summary Cancel UM Order(TRADE)
     * @param {TradeApiPmarginDeleteUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginDeleteUmOrderV1(requestParameters: TradeApiPmarginDeleteUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginDeleteUmOrderV1Resp>;

    /**
     * Query CM Position ADL Quantile Estimation
     * @summary CM Position ADL Quantile Estimation(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmAdlQuantileV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmAdlQuantileV1RespItem>>;

    /**
     * Get all account CM orders; active, canceled, or filled.
     * @summary Query All CM Orders (USER_DATA)
     * @param {TradeApiPmarginGetCmAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmAllOrdersV1(requestParameters: TradeApiPmarginGetCmAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmAllOrdersV1RespItem>>;

    /**
     * Query All CM Conditional Orders
     * @summary Query All CM Conditional Orders(USER_DATA)
     * @param {TradeApiPmarginGetCmConditionalAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmConditionalAllOrdersV1(requestParameters: TradeApiPmarginGetCmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmConditionalAllOrdersV1RespItem>>;

    /**
     * Query Current CM Open Conditional Order
     * @summary Query Current CM Open Conditional Order(USER_DATA)
     * @param {TradeApiPmarginGetCmConditionalOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmConditionalOpenOrderV1(requestParameters: TradeApiPmarginGetCmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmConditionalOpenOrderV1Resp>;

    /**
     * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
     * @summary Query All Current CM Open Conditional Orders (USER_DATA)
     * @param {TradeApiPmarginGetCmConditionalOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmConditionalOpenOrdersV1(requestParameters: TradeApiPmarginGetCmConditionalOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmConditionalOpenOrdersV1RespItem>>;

    /**
     * Query CM Conditional Order History
     * @summary Query CM Conditional Order History(USER_DATA)
     * @param {TradeApiPmarginGetCmConditionalOrderHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmConditionalOrderHistoryV1(requestParameters: TradeApiPmarginGetCmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmConditionalOrderHistoryV1Resp>;

    /**
     * Query User\'s CM Force Orders
     * @summary Query User\'s CM Force Orders(USER_DATA)
     * @param {TradeApiPmarginGetCmForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmForceOrdersV1(requestParameters: TradeApiPmarginGetCmForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmForceOrdersV1RespItem>>;

    /**
     * Query current CM open order
     * @summary Query Current CM Open Order (USER_DATA)
     * @param {TradeApiPmarginGetCmOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmOpenOrderV1(requestParameters: TradeApiPmarginGetCmOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol.
     * @summary Query All Current CM Open Orders(USER_DATA)
     * @param {TradeApiPmarginGetCmOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmOpenOrdersV1(requestParameters: TradeApiPmarginGetCmOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Query CM Modify Order History(TRADE)
     * @param {TradeApiPmarginGetCmOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmOrderAmendmentV1(requestParameters: TradeApiPmarginGetCmOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmOrderAmendmentV1RespItem>>;

    /**
     * Check an CM order\'s status.
     * @summary Query CM Order(USER_DATA)
     * @param {TradeApiPmarginGetCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmOrderV1(requestParameters: TradeApiPmarginGetCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetCmOrderV1Resp>;

    /**
     * Get trades for a specific account and CM symbol.
     * @summary CM Account Trade List(USER_DATA)
     * @param {TradeApiPmarginGetCmUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetCmUserTradesV1(requestParameters: TradeApiPmarginGetCmUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetCmUserTradesV1RespItem>>;

    /**
     * Query all OCO for a specific margin account based on provided optional parameters
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {TradeApiPmarginGetMarginAllOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetMarginAllOrderListV1(requestParameters: TradeApiPmarginGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginAllOrderListV1RespItem>>;

    /**
     * Query All Margin Account Orders
     * @summary Query All Margin Account Orders (USER_DATA)
     * @param {TradeApiPmarginGetMarginAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetMarginAllOrdersV1(requestParameters: TradeApiPmarginGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginAllOrdersV1RespItem>>;

    /**
     * Query user\'s margin force orders
     * @summary Query User\'s Margin Force Orders(USER_DATA)
     * @param {TradeApiPmarginGetMarginForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetMarginForceOrdersV1(requestParameters: TradeApiPmarginGetMarginForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginForceOrdersV1Resp>;

    /**
     * Margin Account Trade List
     * @summary Margin Account Trade List (USER_DATA)
     * @param {TradeApiPmarginGetMarginMyTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetMarginMyTradesV1(requestParameters: TradeApiPmarginGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginMyTradesV1RespItem>>;

    /**
     * Query Margin Account\'s Open OCO
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {TradeApiPmarginGetMarginOpenOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetMarginOpenOrderListV1(requestParameters: TradeApiPmarginGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginOpenOrderListV1RespItem>>;

    /**
     * Query Current Margin Open Order
     * @summary Query Current Margin Open Order (USER_DATA)
     * @param {TradeApiPmarginGetMarginOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetMarginOpenOrdersV1(requestParameters: TradeApiPmarginGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetMarginOpenOrdersV1RespItem>>;

    /**
     * Retrieves a specific OCO based on provided optional parameters
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {TradeApiPmarginGetMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetMarginOrderListV1(requestParameters: TradeApiPmarginGetMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginOrderListV1Resp>;

    /**
     * Query Margin Account Order
     * @summary Query Margin Account Order (USER_DATA)
     * @param {TradeApiPmarginGetMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetMarginOrderV1(requestParameters: TradeApiPmarginGetMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetMarginOrderV1Resp>;

    /**
     * Query UM Position ADL Quantile Estimation
     * @summary UM Position ADL Quantile Estimation(USER_DATA)
     * @param {TradeApiPmarginGetUmAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmAdlQuantileV1(requestParameters: TradeApiPmarginGetUmAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmAdlQuantileV1RespItem>>;

    /**
     * Get all account UM orders; active, canceled, or filled.
     * @summary Query All UM Orders(USER_DATA)
     * @param {TradeApiPmarginGetUmAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmAllOrdersV1(requestParameters: TradeApiPmarginGetUmAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmAllOrdersV1RespItem>>;

    /**
     * Query All UM Conditional Orders
     * @summary Query All UM Conditional Orders(USER_DATA)
     * @param {TradeApiPmarginGetUmConditionalAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmConditionalAllOrdersV1(requestParameters: TradeApiPmarginGetUmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmConditionalAllOrdersV1RespItem>>;

    /**
     * Query Current UM Open Conditional Order
     * @summary Query Current UM Open Conditional Order(USER_DATA)
     * @param {TradeApiPmarginGetUmConditionalOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmConditionalOpenOrderV1(requestParameters: TradeApiPmarginGetUmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmConditionalOpenOrderV1Resp>;

    /**
     * Get all open conditional orders on a symbol.
     * @summary Query All Current UM Open Conditional Orders(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmConditionalOpenOrdersV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmConditionalOpenOrdersV1RespItem>>;

    /**
     * Query UM Conditional Order History
     * @summary Query UM Conditional Order History(USER_DATA)
     * @param {TradeApiPmarginGetUmConditionalOrderHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmConditionalOrderHistoryV1(requestParameters: TradeApiPmarginGetUmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmConditionalOrderHistoryV1Resp>;

    /**
     * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
     * @summary Get UM Futures BNB Burn Status (USER_DATA)
     * @param {TradeApiPmarginGetUmFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmFeeBurnV1(requestParameters: TradeApiPmarginGetUmFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmFeeBurnV1Resp>;

    /**
     * Query User\'s UM Force Orders
     * @summary Query User\'s UM Force Orders (USER_DATA)
     * @param {TradeApiPmarginGetUmForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmForceOrdersV1(requestParameters: TradeApiPmarginGetUmForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmForceOrdersV1RespItem>>;

    /**
     * Query current UM open order
     * @summary Query Current UM Open Order(USER_DATA)
     * @param {TradeApiPmarginGetUmOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmOpenOrderV1(requestParameters: TradeApiPmarginGetUmOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol.
     * @summary Query All Current UM Open Orders(USER_DATA)
     * @param {TradeApiPmarginGetUmOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmOpenOrdersV1(requestParameters: TradeApiPmarginGetUmOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Query UM Modify Order History(TRADE)
     * @param {TradeApiPmarginGetUmOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmOrderAmendmentV1(requestParameters: TradeApiPmarginGetUmOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmOrderAmendmentV1RespItem>>;

    /**
     * Check an UM order\'s status.
     * @summary Query UM Order (USER_DATA)
     * @param {TradeApiPmarginGetUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmOrderV1(requestParameters: TradeApiPmarginGetUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetUmOrderV1Resp>;

    /**
     * Get trades for a specific account and UM symbol.
     * @summary UM Account Trade List(USER_DATA)
     * @param {TradeApiPmarginGetUmUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginGetUmUserTradesV1(requestParameters: TradeApiPmarginGetUmUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginGetUmUserTradesV1RespItem>>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify CM Order(TRADE)
     * @param {TradeApiPmarginUpdateCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginUpdateCmOrderV1(requestParameters: TradeApiPmarginUpdateCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginUpdateCmOrderV1Resp>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify UM Order(TRADE)
     * @param {TradeApiPmarginUpdateUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    pmarginUpdateUmOrderV1(requestParameters: TradeApiPmarginUpdateUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginUpdateUmOrderV1Resp>;

}

/**
 * Request parameters for pmarginCreateCmConditionalOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateCmConditionalOrderV1Request
 */
export interface TradeApiPmarginCreateCmConditionalOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly strategyType: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmConditionalOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for pmarginCreateCmOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateCmOrderV1Request
 */
export interface TradeApiPmarginCreateCmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateCmOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for pmarginCreateMarginLoanV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateMarginLoanV1Request
 */
export interface TradeApiPmarginCreateMarginLoanV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginLoanV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginLoanV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateMarginLoanV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateMarginLoanV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateMarginOrderOcoV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateMarginOrderOcoV1Request
 */
export interface TradeApiPmarginCreateMarginOrderOcoV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly stopPrice: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly limitClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly limitIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly sideEffectType?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly stopClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly stopIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly stopLimitPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderOcoV1
     */
    readonly stopLimitTimeInForce?: string
}

/**
 * Request parameters for pmarginCreateMarginOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateMarginOrderV1Request
 */
export interface TradeApiPmarginCreateMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {boolean}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly autoRepayAtCancel?: boolean

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly sideEffectType?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for pmarginCreateMarginRepayDebtV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateMarginRepayDebtV1Request
 */
export interface TradeApiPmarginCreateMarginRepayDebtV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginRepayDebtV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateMarginRepayDebtV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginRepayDebtV1
     */
    readonly amount?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateMarginRepayDebtV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateMarginRepayDebtV1
     */
    readonly specifyRepayAssets?: string
}

/**
 * Request parameters for pmarginCreateRepayLoanV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateRepayLoanV1Request
 */
export interface TradeApiPmarginCreateRepayLoanV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateRepayLoanV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateRepayLoanV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateRepayLoanV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateRepayLoanV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateUmConditionalOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateUmConditionalOrderV1Request
 */
export interface TradeApiPmarginCreateUmConditionalOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly strategyType: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmConditionalOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for pmarginCreateUmFeeBurnV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateUmFeeBurnV1Request
 */
export interface TradeApiPmarginCreateUmFeeBurnV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmFeeBurnV1
     */
    readonly feeBurn: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateUmFeeBurnV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateUmFeeBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginCreateUmOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginCreateUmOrderV1Request
 */
export interface TradeApiPmarginCreateUmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginCreateUmOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for pmarginDeleteCmAllOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteCmAllOpenOrdersV1Request
 */
export interface TradeApiPmarginDeleteCmAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteCmAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteCmConditionalAllOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1Request
 */
export interface TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteCmConditionalOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteCmConditionalOrderV1Request
 */
export interface TradeApiPmarginDeleteCmConditionalOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteCmConditionalOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmConditionalOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmConditionalOrderV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteCmConditionalOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmConditionalOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteCmOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteCmOrderV1Request
 */
export interface TradeApiPmarginDeleteCmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteCmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteCmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteCmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteMarginAllOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteMarginAllOpenOrdersV1Request
 */
export interface TradeApiPmarginDeleteMarginAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteMarginAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteMarginAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginDeleteMarginAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteMarginOrderListV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteMarginOrderListV1Request
 */
export interface TradeApiPmarginDeleteMarginOrderListV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteMarginOrderListV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteMarginOrderListV1
     */
    readonly timestamp: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {number}
     * @memberof TradeApiPmarginDeleteMarginOrderListV1
     */
    readonly orderListId?: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {string}
     * @memberof TradeApiPmarginDeleteMarginOrderListV1
     */
    readonly listClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiPmarginDeleteMarginOrderListV1
     */
    readonly newClientOrderId?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginDeleteMarginOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteMarginOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteMarginOrderV1Request
 */
export interface TradeApiPmarginDeleteMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteMarginOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteMarginOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteMarginOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default.
     * @type {string}
     * @memberof TradeApiPmarginDeleteMarginOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradeApiPmarginDeleteMarginOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteUmAllOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteUmAllOpenOrdersV1Request
 */
export interface TradeApiPmarginDeleteUmAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteUmAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteUmConditionalAllOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1Request
 */
export interface TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteUmConditionalOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteUmConditionalOrderV1Request
 */
export interface TradeApiPmarginDeleteUmConditionalOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteUmConditionalOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmConditionalOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmConditionalOrderV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteUmConditionalOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmConditionalOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginDeleteUmOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginDeleteUmOrderV1Request
 */
export interface TradeApiPmarginDeleteUmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteUmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginDeleteUmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginDeleteUmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmAllOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmAllOrdersV1Request
 */
export interface TradeApiPmarginGetCmAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmAllOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof TradeApiPmarginGetCmAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmConditionalAllOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmConditionalAllOrdersV1Request
 */
export interface TradeApiPmarginGetCmConditionalAllOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmConditionalAllOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalAllOrdersV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmConditionalOpenOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmConditionalOpenOrderV1Request
 */
export interface TradeApiPmarginGetCmConditionalOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmConditionalOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalOpenOrderV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmConditionalOpenOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmConditionalOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmConditionalOpenOrdersV1Request
 */
export interface TradeApiPmarginGetCmConditionalOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmConditionalOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmConditionalOrderHistoryV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmConditionalOrderHistoryV1Request
 */
export interface TradeApiPmarginGetCmConditionalOrderHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmConditionalOrderHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalOrderHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalOrderHistoryV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmConditionalOrderHistoryV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmConditionalOrderHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmForceOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmForceOrdersV1Request
 */
export interface TradeApiPmarginGetCmForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmForceOrdersV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
     * @type {string}
     * @memberof TradeApiPmarginGetCmForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof TradeApiPmarginGetCmForceOrdersV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetCmForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmOpenOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmOpenOrderV1Request
 */
export interface TradeApiPmarginGetCmOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmOpenOrdersV1Request
 */
export interface TradeApiPmarginGetCmOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmOpenOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmOrderAmendmentV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmOrderAmendmentV1Request
 */
export interface TradeApiPmarginGetCmOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 50, max 100
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmOrderV1Request
 */
export interface TradeApiPmarginGetCmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetCmUserTradesV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetCmUserTradesV1Request
 */
export interface TradeApiPmarginGetCmUserTradesV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmUserTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmUserTradesV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetCmUserTradesV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof TradeApiPmarginGetCmUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 50; max 1000.
     * @type {number}
     * @memberof TradeApiPmarginGetCmUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetCmUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginAllOrderListV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetMarginAllOrderListV1Request
 */
export interface TradeApiPmarginGetMarginAllOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrderListV1
     */
    readonly timestamp: number

    /**
     * If supplied, neither startTime or endTime can be provided
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrderListV1
     */
    readonly fromId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrderListV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrderListV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 500.
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrderListV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginAllOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetMarginAllOrdersV1Request
 */
export interface TradeApiPmarginGetMarginAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetMarginAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 500.
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrdersV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetMarginAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginForceOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetMarginForceOrdersV1Request
 */
export interface TradeApiPmarginGetMarginForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof TradeApiPmarginGetMarginForceOrdersV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof TradeApiPmarginGetMarginForceOrdersV1
     */
    readonly size?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetMarginForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginMyTradesV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetMarginMyTradesV1Request
 */
export interface TradeApiPmarginGetMarginMyTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetMarginMyTradesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginMyTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginMyTradesV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginMyTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginMyTradesV1
     */
    readonly endTime?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof TradeApiPmarginGetMarginMyTradesV1
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiPmarginGetMarginMyTradesV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetMarginMyTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginOpenOrderListV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetMarginOpenOrderListV1Request
 */
export interface TradeApiPmarginGetMarginOpenOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOpenOrderListV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOpenOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetMarginOpenOrdersV1Request
 */
export interface TradeApiPmarginGetMarginOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetMarginOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginOrderListV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetMarginOrderListV1Request
 */
export interface TradeApiPmarginGetMarginOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOrderListV1
     */
    readonly timestamp: number

    /**
     * Either orderListId or origClientOrderId must be provided
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOrderListV1
     */
    readonly orderListId?: number

    /**
     * Either orderListId or origClientOrderId must be provided
     * @type {string}
     * @memberof TradeApiPmarginGetMarginOrderListV1
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetMarginOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetMarginOrderV1Request
 */
export interface TradeApiPmarginGetMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetMarginOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetMarginOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmAdlQuantileV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmAdlQuantileV1Request
 */
export interface TradeApiPmarginGetUmAdlQuantileV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmAdlQuantileV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmAdlQuantileV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmAdlQuantileV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmAllOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmAllOrdersV1Request
 */
export interface TradeApiPmarginGetUmAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiPmarginGetUmAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmConditionalAllOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmConditionalAllOrdersV1Request
 */
export interface TradeApiPmarginGetUmConditionalAllOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmConditionalAllOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalAllOrdersV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmConditionalOpenOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmConditionalOpenOrderV1Request
 */
export interface TradeApiPmarginGetUmConditionalOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmConditionalOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalOpenOrderV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmConditionalOpenOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmConditionalOrderHistoryV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmConditionalOrderHistoryV1Request
 */
export interface TradeApiPmarginGetUmConditionalOrderHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmConditionalOrderHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalOrderHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalOrderHistoryV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmConditionalOrderHistoryV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmConditionalOrderHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmFeeBurnV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmFeeBurnV1Request
 */
export interface TradeApiPmarginGetUmFeeBurnV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmFeeBurnV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmFeeBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmForceOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmForceOrdersV1Request
 */
export interface TradeApiPmarginGetUmForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmForceOrdersV1
     */
    readonly symbol?: string

    /**
     * &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders.
     * @type {string}
     * @memberof TradeApiPmarginGetUmForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof TradeApiPmarginGetUmForceOrdersV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof TradeApiPmarginGetUmForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmOpenOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmOpenOrderV1Request
 */
export interface TradeApiPmarginGetUmOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmOpenOrdersV1Request
 */
export interface TradeApiPmarginGetUmOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmOrderAmendmentV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmOrderAmendmentV1Request
 */
export interface TradeApiPmarginGetUmOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 500, max 1000
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmOrderV1Request
 */
export interface TradeApiPmarginGetUmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginGetUmUserTradesV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginGetUmUserTradesV1Request
 */
export interface TradeApiPmarginGetUmUserTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginGetUmUserTradesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmUserTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof TradeApiPmarginGetUmUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiPmarginGetUmUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginGetUmUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginUpdateCmOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginUpdateCmOrderV1Request
 */
export interface TradeApiPmarginUpdateCmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginUpdateCmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for pmarginUpdateUmOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiPmarginUpdateUmOrderV1Request
 */
export interface TradeApiPmarginUpdateUmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiPmarginUpdateUmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI implements TradeApiInterface {
    /**
     * New CM Conditional Order
     * @summary New CM Conditional Order(TRADE)
     * @param {TradeApiPmarginCreateCmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateCmConditionalOrderV1(requestParameters: TradeApiPmarginCreateCmConditionalOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateCmConditionalOrderV1(requestParameters.side, requestParameters.strategyType, requestParameters.symbol, requestParameters.timestamp, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.newClientStrategyId, requestParameters.positionSide, requestParameters.price, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place new CM order
     * @summary New CM Order(TRADE)
     * @param {TradeApiPmarginCreateCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateCmOrderV1(requestParameters: TradeApiPmarginCreateCmOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateCmOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply for a margin loan.
     * @summary Margin Account Borrow(MARGIN)
     * @param {TradeApiPmarginCreateMarginLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateMarginLoanV1(requestParameters: TradeApiPmarginCreateMarginLoanV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateMarginLoanV1(requestParameters.amount, requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new OCO for a margin account
     * @summary Margin Account New OCO(TRADE)
     * @param {TradeApiPmarginCreateMarginOrderOcoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateMarginOrderOcoV1(requestParameters: TradeApiPmarginCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateMarginOrderOcoV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.sideEffectType, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * New Margin Order
     * @summary New Margin Order(TRADE)
     * @param {TradeApiPmarginCreateMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateMarginOrderV1(requestParameters: TradeApiPmarginCreateMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateMarginOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.autoRepayAtCancel, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.stopPrice, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Repay debt for a margin loan.
     * @summary Margin Account Repay Debt(TRADE)
     * @param {TradeApiPmarginCreateMarginRepayDebtV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateMarginRepayDebtV1(requestParameters: TradeApiPmarginCreateMarginRepayDebtV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateMarginRepayDebtV1(requestParameters.asset, requestParameters.timestamp, requestParameters.amount, requestParameters.recvWindow, requestParameters.specifyRepayAssets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Repay for a margin loan.
     * @summary Margin Account Repay(MARGIN)
     * @param {TradeApiPmarginCreateRepayLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateRepayLoanV1(requestParameters: TradeApiPmarginCreateRepayLoanV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateRepayLoanV1(requestParameters.amount, requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place new UM conditional order
     * @summary New UM Conditional Order (TRADE)
     * @param {TradeApiPmarginCreateUmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateUmConditionalOrderV1(requestParameters: TradeApiPmarginCreateUmConditionalOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateUmConditionalOrderV1(requestParameters.side, requestParameters.strategyType, requestParameters.symbol, requestParameters.timestamp, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.goodTillDate, requestParameters.newClientStrategyId, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
     * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
     * @param {TradeApiPmarginCreateUmFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateUmFeeBurnV1(requestParameters: TradeApiPmarginCreateUmFeeBurnV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateUmFeeBurnV1(requestParameters.feeBurn, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place new UM order
     * @summary New UM Order (TRADE)
     * @param {TradeApiPmarginCreateUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginCreateUmOrderV1(requestParameters: TradeApiPmarginCreateUmOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginCreateUmOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all active LIMIT orders on specific symbol
     * @summary Cancel All CM Open Orders(TRADE)
     * @param {TradeApiPmarginDeleteCmAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteCmAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteCmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteCmAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All CM Open Conditional Orders
     * @summary Cancel All CM Open Conditional Orders(TRADE)
     * @param {TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteCmConditionalAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteCmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteCmConditionalAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel CM Conditional Order
     * @summary Cancel CM Conditional Order(TRADE)
     * @param {TradeApiPmarginDeleteCmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteCmConditionalOrderV1(requestParameters: TradeApiPmarginDeleteCmConditionalOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteCmConditionalOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active LIMIT order
     * @summary Cancel CM Order(TRADE)
     * @param {TradeApiPmarginDeleteCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteCmOrderV1(requestParameters: TradeApiPmarginDeleteCmOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteCmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Margin Account All Open Orders on a Symbol
     * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
     * @param {TradeApiPmarginDeleteMarginAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteMarginAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteMarginAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteMarginAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Margin Account OCO Orders
     * @summary Cancel Margin Account OCO Orders(TRADE)
     * @param {TradeApiPmarginDeleteMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteMarginOrderListV1(requestParameters: TradeApiPmarginDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteMarginOrderListV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Margin Account Order
     * @summary Cancel Margin Account Order(TRADE)
     * @param {TradeApiPmarginDeleteMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteMarginOrderV1(requestParameters: TradeApiPmarginDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all active LIMIT orders on specific symbol
     * @summary Cancel All UM Open Orders(TRADE)
     * @param {TradeApiPmarginDeleteUmAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteUmAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteUmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteUmAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All UM Open Conditional Orders
     * @summary Cancel All UM Open Conditional Orders (TRADE)
     * @param {TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteUmConditionalAllOpenOrdersV1(requestParameters: TradeApiPmarginDeleteUmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteUmConditionalAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel UM Conditional Order
     * @summary Cancel UM Conditional Order(TRADE)
     * @param {TradeApiPmarginDeleteUmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteUmConditionalOrderV1(requestParameters: TradeApiPmarginDeleteUmConditionalOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteUmConditionalOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active UM LIMIT order
     * @summary Cancel UM Order(TRADE)
     * @param {TradeApiPmarginDeleteUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginDeleteUmOrderV1(requestParameters: TradeApiPmarginDeleteUmOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginDeleteUmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query CM Position ADL Quantile Estimation
     * @summary CM Position ADL Quantile Estimation(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmAdlQuantileV1(options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmAdlQuantileV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account CM orders; active, canceled, or filled.
     * @summary Query All CM Orders (USER_DATA)
     * @param {TradeApiPmarginGetCmAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmAllOrdersV1(requestParameters: TradeApiPmarginGetCmAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query All CM Conditional Orders
     * @summary Query All CM Conditional Orders(USER_DATA)
     * @param {TradeApiPmarginGetCmConditionalAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmConditionalAllOrdersV1(requestParameters: TradeApiPmarginGetCmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmConditionalAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.strategyId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current CM Open Conditional Order
     * @summary Query Current CM Open Conditional Order(USER_DATA)
     * @param {TradeApiPmarginGetCmConditionalOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmConditionalOpenOrderV1(requestParameters: TradeApiPmarginGetCmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmConditionalOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
     * @summary Query All Current CM Open Conditional Orders (USER_DATA)
     * @param {TradeApiPmarginGetCmConditionalOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmConditionalOpenOrdersV1(requestParameters: TradeApiPmarginGetCmConditionalOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmConditionalOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query CM Conditional Order History
     * @summary Query CM Conditional Order History(USER_DATA)
     * @param {TradeApiPmarginGetCmConditionalOrderHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmConditionalOrderHistoryV1(requestParameters: TradeApiPmarginGetCmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmConditionalOrderHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query User\'s CM Force Orders
     * @summary Query User\'s CM Force Orders(USER_DATA)
     * @param {TradeApiPmarginGetCmForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmForceOrdersV1(requestParameters: TradeApiPmarginGetCmForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query current CM open order
     * @summary Query Current CM Open Order (USER_DATA)
     * @param {TradeApiPmarginGetCmOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmOpenOrderV1(requestParameters: TradeApiPmarginGetCmOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol.
     * @summary Query All Current CM Open Orders(USER_DATA)
     * @param {TradeApiPmarginGetCmOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmOpenOrdersV1(requestParameters: TradeApiPmarginGetCmOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Query CM Modify Order History(TRADE)
     * @param {TradeApiPmarginGetCmOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmOrderAmendmentV1(requestParameters: TradeApiPmarginGetCmOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an CM order\'s status.
     * @summary Query CM Order(USER_DATA)
     * @param {TradeApiPmarginGetCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmOrderV1(requestParameters: TradeApiPmarginGetCmOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and CM symbol.
     * @summary CM Account Trade List(USER_DATA)
     * @param {TradeApiPmarginGetCmUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetCmUserTradesV1(requestParameters: TradeApiPmarginGetCmUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetCmUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query all OCO for a specific margin account based on provided optional parameters
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {TradeApiPmarginGetMarginAllOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetMarginAllOrderListV1(requestParameters: TradeApiPmarginGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetMarginAllOrderListV1(requestParameters.timestamp, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query All Margin Account Orders
     * @summary Query All Margin Account Orders (USER_DATA)
     * @param {TradeApiPmarginGetMarginAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetMarginAllOrdersV1(requestParameters: TradeApiPmarginGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetMarginAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user\'s margin force orders
     * @summary Query User\'s Margin Force Orders(USER_DATA)
     * @param {TradeApiPmarginGetMarginForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetMarginForceOrdersV1(requestParameters: TradeApiPmarginGetMarginForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetMarginForceOrdersV1(requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Margin Account Trade List
     * @summary Margin Account Trade List (USER_DATA)
     * @param {TradeApiPmarginGetMarginMyTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetMarginMyTradesV1(requestParameters: TradeApiPmarginGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetMarginMyTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account\'s Open OCO
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {TradeApiPmarginGetMarginOpenOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetMarginOpenOrderListV1(requestParameters: TradeApiPmarginGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetMarginOpenOrderListV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current Margin Open Order
     * @summary Query Current Margin Open Order (USER_DATA)
     * @param {TradeApiPmarginGetMarginOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetMarginOpenOrdersV1(requestParameters: TradeApiPmarginGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetMarginOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific OCO based on provided optional parameters
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {TradeApiPmarginGetMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetMarginOrderListV1(requestParameters: TradeApiPmarginGetMarginOrderListV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetMarginOrderListV1(requestParameters.timestamp, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account Order
     * @summary Query Margin Account Order (USER_DATA)
     * @param {TradeApiPmarginGetMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetMarginOrderV1(requestParameters: TradeApiPmarginGetMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query UM Position ADL Quantile Estimation
     * @summary UM Position ADL Quantile Estimation(USER_DATA)
     * @param {TradeApiPmarginGetUmAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmAdlQuantileV1(requestParameters: TradeApiPmarginGetUmAdlQuantileV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account UM orders; active, canceled, or filled.
     * @summary Query All UM Orders(USER_DATA)
     * @param {TradeApiPmarginGetUmAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmAllOrdersV1(requestParameters: TradeApiPmarginGetUmAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query All UM Conditional Orders
     * @summary Query All UM Conditional Orders(USER_DATA)
     * @param {TradeApiPmarginGetUmConditionalAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmConditionalAllOrdersV1(requestParameters: TradeApiPmarginGetUmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmConditionalAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.strategyId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current UM Open Conditional Order
     * @summary Query Current UM Open Conditional Order(USER_DATA)
     * @param {TradeApiPmarginGetUmConditionalOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmConditionalOpenOrderV1(requestParameters: TradeApiPmarginGetUmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmConditionalOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open conditional orders on a symbol.
     * @summary Query All Current UM Open Conditional Orders(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmConditionalOpenOrdersV1(options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmConditionalOpenOrdersV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query UM Conditional Order History
     * @summary Query UM Conditional Order History(USER_DATA)
     * @param {TradeApiPmarginGetUmConditionalOrderHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmConditionalOrderHistoryV1(requestParameters: TradeApiPmarginGetUmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmConditionalOrderHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
     * @summary Get UM Futures BNB Burn Status (USER_DATA)
     * @param {TradeApiPmarginGetUmFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmFeeBurnV1(requestParameters: TradeApiPmarginGetUmFeeBurnV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmFeeBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query User\'s UM Force Orders
     * @summary Query User\'s UM Force Orders (USER_DATA)
     * @param {TradeApiPmarginGetUmForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmForceOrdersV1(requestParameters: TradeApiPmarginGetUmForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query current UM open order
     * @summary Query Current UM Open Order(USER_DATA)
     * @param {TradeApiPmarginGetUmOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmOpenOrderV1(requestParameters: TradeApiPmarginGetUmOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol.
     * @summary Query All Current UM Open Orders(USER_DATA)
     * @param {TradeApiPmarginGetUmOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmOpenOrdersV1(requestParameters: TradeApiPmarginGetUmOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Query UM Modify Order History(TRADE)
     * @param {TradeApiPmarginGetUmOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmOrderAmendmentV1(requestParameters: TradeApiPmarginGetUmOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an UM order\'s status.
     * @summary Query UM Order (USER_DATA)
     * @param {TradeApiPmarginGetUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmOrderV1(requestParameters: TradeApiPmarginGetUmOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and UM symbol.
     * @summary UM Account Trade List(USER_DATA)
     * @param {TradeApiPmarginGetUmUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginGetUmUserTradesV1(requestParameters: TradeApiPmarginGetUmUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginGetUmUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify CM Order(TRADE)
     * @param {TradeApiPmarginUpdateCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginUpdateCmOrderV1(requestParameters: TradeApiPmarginUpdateCmOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginUpdateCmOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify UM Order(TRADE)
     * @param {TradeApiPmarginUpdateUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public pmarginUpdateUmOrderV1(requestParameters: TradeApiPmarginUpdateUmOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).pmarginUpdateUmOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

