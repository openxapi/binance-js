/* tslint:disable */
/* eslint-disable */
/**
 * Binance Options API
 * OpenAPI specification for Binance exchange - Options API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { OptionsCreateBatchOrdersV1ReqOrdersItem } from '../model';
// @ts-ignore
import type { OptionsCreateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { OptionsCreateOrderV1Resp } from '../model';
// @ts-ignore
import type { OptionsDeleteAllOpenOrdersByUnderlyingV1Resp } from '../model';
// @ts-ignore
import type { OptionsDeleteAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { OptionsDeleteBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { OptionsDeleteOrderV1Resp } from '../model';
// @ts-ignore
import type { OptionsGetExerciseRecordV1RespItem } from '../model';
// @ts-ignore
import type { OptionsGetHistoryOrdersV1RespItem } from '../model';
// @ts-ignore
import type { OptionsGetOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { OptionsGetOrderV1Resp } from '../model';
// @ts-ignore
import type { OptionsGetPositionV1RespItem } from '../model';
// @ts-ignore
import type { OptionsGetUserTradesV1RespItem } from '../model';
/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send multiple option orders.
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<OptionsCreateBatchOrdersV1ReqOrdersItem>} orders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsCreateBatchOrdersV1: async (orders: Array<OptionsCreateBatchOrdersV1ReqOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orders' is not null or undefined
            assertParamExists('optionsCreateBatchOrdersV1', 'orders', orders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsCreateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (orders) {
                localVarFormParams.set('orders', orders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a new order.
         * @summary New Order (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [clientOrderId] 
         * @param {boolean} [isMmp] 
         * @param {string} [newOrderRespType] 
         * @param {boolean} [postOnly] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {boolean} [reduceOnly] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsCreateOrderV1: async (quantity: string, side: string, symbol: string, timestamp: number, type: string, clientOrderId?: string, isMmp?: boolean, newOrderRespType?: string, postOnly?: boolean, price?: string, recvWindow?: number, reduceOnly?: boolean, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('optionsCreateOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('optionsCreateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('optionsCreateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsCreateOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('optionsCreateOrderV1', 'type', type)
            const localVarPath = `/eapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (clientOrderId !== undefined) { 
                localVarFormParams.set('clientOrderId', clientOrderId as any);
            }
    
            if (isMmp !== undefined) { 
                localVarFormParams.set('isMmp', isMmp as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (postOnly !== undefined) { 
                localVarFormParams.set('postOnly', postOnly as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all active orders on specified underlying.
         * @summary Cancel All Option Orders By Underlying (TRADE)
         * @param {string} underlying Option underlying, e.g BTCUSDT
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsDeleteAllOpenOrdersByUnderlyingV1: async (underlying: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlying' is not null or undefined
            assertParamExists('optionsDeleteAllOpenOrdersByUnderlyingV1', 'underlying', underlying)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsDeleteAllOpenOrdersByUnderlyingV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/allOpenOrdersByUnderlying`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (underlying !== undefined) {
                localVarQueryParameter['underlying'] = underlying;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all active order on a symbol.
         * @summary Cancel all Option orders on specific symbol (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsDeleteAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('optionsDeleteAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsDeleteAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel multiple orders.
         * @summary Cancel Multiple Option Orders (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {Array<number>} [orderIds] Order ID, e.g [4611875134427365377,4611875134427365378]
         * @param {Array<string>} [clientOrderIds] User-defined order ID, e.g [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;]
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsDeleteBatchOrdersV1: async (symbol: string, timestamp: number, orderIds?: Array<number>, clientOrderIds?: Array<string>, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('optionsDeleteBatchOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsDeleteBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds;
            }

            if (clientOrderIds) {
                localVarQueryParameter['clientOrderIds'] = clientOrderIds;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel Option Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [orderId] Order ID, e.g 4611875134427365377
         * @param {string} [clientOrderId] User-defined order ID, e.g 10000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsDeleteOrderV1: async (symbol: string, timestamp: number, orderId?: number, clientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('optionsDeleteOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsDeleteOrderV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (clientOrderId !== undefined) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account exercise records.
         * @summary User Exercise Record (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {number} [limit] default 1000, max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetExerciseRecordV1: async (timestamp: number, symbol?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsGetExerciseRecordV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/exerciseRecord`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
         * @summary Query Option Order History (TRADE)
         * @param {string} symbol Option trading pair
         * @param {number} timestamp 
         * @param {number} [orderId] Returns the orderId and subsequent orders, the most recent order is returned by default
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetHistoryOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('optionsGetHistoryOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsGetHistoryOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/historyOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
         * @summary Query Current Open Option Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] return all orders if don&amp;#39;t pass, Option trading pair, e.g BTC-200730-9000-C,
         * @param {number} [orderId] Returns the orderId and subsequent orders, the most recent order is returned by default
         * @param {number} [startTime] Start Time
         * @param {number} [endTime] End Time
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetOpenOrdersV1: async (timestamp: number, symbol?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsGetOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order status.
         * @summary Query Single Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [orderId] Order id
         * @param {string} [clientOrderId] User-defined order ID cannot be repeated in pending orders
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetOrderV1: async (symbol: string, timestamp: number, orderId?: number, clientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('optionsGetOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsGetOrderV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (clientOrderId !== undefined) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current position information.
         * @summary Option Position Information (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetPositionV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsGetPositionV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/position`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option symbol, e.g BTC-200730-9000-C
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades, e.g 4611875134427365376
         * @param {number} [startTime] Start time, e.g 1593511200000
         * @param {number} [endTime] End time, e.g 1593512200000
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetUserTradesV1: async (timestamp: number, symbol?: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('optionsGetUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/eapi/v1/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration)
    return {
        /**
         * Send multiple option orders.
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<OptionsCreateBatchOrdersV1ReqOrdersItem>} orders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsCreateBatchOrdersV1(orders: Array<OptionsCreateBatchOrdersV1ReqOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsCreateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsCreateBatchOrdersV1(orders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsCreateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a new order.
         * @summary New Order (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [clientOrderId] 
         * @param {boolean} [isMmp] 
         * @param {string} [newOrderRespType] 
         * @param {boolean} [postOnly] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {boolean} [reduceOnly] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsCreateOrderV1(quantity: string, side: string, symbol: string, timestamp: number, type: string, clientOrderId?: string, isMmp?: boolean, newOrderRespType?: string, postOnly?: boolean, price?: string, recvWindow?: number, reduceOnly?: boolean, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsCreateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsCreateOrderV1(quantity, side, symbol, timestamp, type, clientOrderId, isMmp, newOrderRespType, postOnly, price, recvWindow, reduceOnly, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsCreateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all active orders on specified underlying.
         * @summary Cancel All Option Orders By Underlying (TRADE)
         * @param {string} underlying Option underlying, e.g BTCUSDT
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsDeleteAllOpenOrdersByUnderlyingV1(underlying: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsDeleteAllOpenOrdersByUnderlyingV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsDeleteAllOpenOrdersByUnderlyingV1(underlying, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsDeleteAllOpenOrdersByUnderlyingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all active order on a symbol.
         * @summary Cancel all Option orders on specific symbol (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsDeleteAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsDeleteAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsDeleteAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsDeleteAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel multiple orders.
         * @summary Cancel Multiple Option Orders (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {Array<number>} [orderIds] Order ID, e.g [4611875134427365377,4611875134427365378]
         * @param {Array<string>} [clientOrderIds] User-defined order ID, e.g [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;]
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsDeleteBatchOrdersV1(symbol: string, timestamp: number, orderIds?: Array<number>, clientOrderIds?: Array<string>, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsDeleteBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsDeleteBatchOrdersV1(symbol, timestamp, orderIds, clientOrderIds, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsDeleteBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel Option Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [orderId] Order ID, e.g 4611875134427365377
         * @param {string} [clientOrderId] User-defined order ID, e.g 10000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsDeleteOrderV1(symbol: string, timestamp: number, orderId?: number, clientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsDeleteOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsDeleteOrderV1(symbol, timestamp, orderId, clientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsDeleteOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account exercise records.
         * @summary User Exercise Record (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {number} [limit] default 1000, max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsGetExerciseRecordV1(timestamp: number, symbol?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsGetExerciseRecordV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsGetExerciseRecordV1(timestamp, symbol, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsGetExerciseRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
         * @summary Query Option Order History (TRADE)
         * @param {string} symbol Option trading pair
         * @param {number} timestamp 
         * @param {number} [orderId] Returns the orderId and subsequent orders, the most recent order is returned by default
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsGetHistoryOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsGetHistoryOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsGetHistoryOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsGetHistoryOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
         * @summary Query Current Open Option Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] return all orders if don&amp;#39;t pass, Option trading pair, e.g BTC-200730-9000-C,
         * @param {number} [orderId] Returns the orderId and subsequent orders, the most recent order is returned by default
         * @param {number} [startTime] Start Time
         * @param {number} [endTime] End Time
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsGetOpenOrdersV1(timestamp: number, symbol?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsGetOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsGetOpenOrdersV1(timestamp, symbol, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsGetOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order status.
         * @summary Query Single Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} timestamp 
         * @param {number} [orderId] Order id
         * @param {string} [clientOrderId] User-defined order ID cannot be repeated in pending orders
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsGetOrderV1(symbol: string, timestamp: number, orderId?: number, clientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsGetOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsGetOrderV1(symbol, timestamp, orderId, clientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsGetOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current position information.
         * @summary Option Position Information (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsGetPositionV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsGetPositionV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsGetPositionV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsGetPositionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] Option symbol, e.g BTC-200730-9000-C
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades, e.g 4611875134427365376
         * @param {number} [startTime] Start time, e.g 1593511200000
         * @param {number} [endTime] End time, e.g 1593512200000
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsGetUserTradesV1(timestamp: number, symbol?: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionsGetUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsGetUserTradesV1(timestamp, symbol, fromId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.optionsGetUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeApiFp(configuration)
    return {
        /**
         * Send multiple option orders.
         * @summary Place Multiple Orders(TRADE)
         * @param {TradeApiOptionsCreateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsCreateBatchOrdersV1(requestParameters: TradeApiOptionsCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsCreateBatchOrdersV1RespInner>> {
            return localVarFp.optionsCreateBatchOrdersV1(requestParameters.orders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a new order.
         * @summary New Order (TRADE)
         * @param {TradeApiOptionsCreateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsCreateOrderV1(requestParameters: TradeApiOptionsCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsCreateOrderV1Resp> {
            return localVarFp.optionsCreateOrderV1(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.clientOrderId, requestParameters.isMmp, requestParameters.newOrderRespType, requestParameters.postOnly, requestParameters.price, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all active orders on specified underlying.
         * @summary Cancel All Option Orders By Underlying (TRADE)
         * @param {TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsDeleteAllOpenOrdersByUnderlyingV1(requestParameters: TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsDeleteAllOpenOrdersByUnderlyingV1Resp> {
            return localVarFp.optionsDeleteAllOpenOrdersByUnderlyingV1(requestParameters.underlying, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all active order on a symbol.
         * @summary Cancel all Option orders on specific symbol (TRADE)
         * @param {TradeApiOptionsDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsDeleteAllOpenOrdersV1(requestParameters: TradeApiOptionsDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsDeleteAllOpenOrdersV1Resp> {
            return localVarFp.optionsDeleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel multiple orders.
         * @summary Cancel Multiple Option Orders (TRADE)
         * @param {TradeApiOptionsDeleteBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsDeleteBatchOrdersV1(requestParameters: TradeApiOptionsDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsDeleteBatchOrdersV1RespInner>> {
            return localVarFp.optionsDeleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIds, requestParameters.clientOrderIds, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel Option Order (TRADE)
         * @param {TradeApiOptionsDeleteOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsDeleteOrderV1(requestParameters: TradeApiOptionsDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsDeleteOrderV1Resp> {
            return localVarFp.optionsDeleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.clientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account exercise records.
         * @summary User Exercise Record (USER_DATA)
         * @param {TradeApiOptionsGetExerciseRecordV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetExerciseRecordV1(requestParameters: TradeApiOptionsGetExerciseRecordV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetExerciseRecordV1RespItem>> {
            return localVarFp.optionsGetExerciseRecordV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
         * @summary Query Option Order History (TRADE)
         * @param {TradeApiOptionsGetHistoryOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetHistoryOrdersV1(requestParameters: TradeApiOptionsGetHistoryOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetHistoryOrdersV1RespItem>> {
            return localVarFp.optionsGetHistoryOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
         * @summary Query Current Open Option Orders (USER_DATA)
         * @param {TradeApiOptionsGetOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetOpenOrdersV1(requestParameters: TradeApiOptionsGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetOpenOrdersV1RespItem>> {
            return localVarFp.optionsGetOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order status.
         * @summary Query Single Order (TRADE)
         * @param {TradeApiOptionsGetOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetOrderV1(requestParameters: TradeApiOptionsGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsGetOrderV1Resp> {
            return localVarFp.optionsGetOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.clientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current position information.
         * @summary Option Position Information (USER_DATA)
         * @param {TradeApiOptionsGetPositionV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetPositionV1(requestParameters: TradeApiOptionsGetPositionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetPositionV1RespItem>> {
            return localVarFp.optionsGetPositionV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {TradeApiOptionsGetUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsGetUserTradesV1(requestParameters: TradeApiOptionsGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetUserTradesV1RespItem>> {
            return localVarFp.optionsGetUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeApi - interface
 * @export
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Send multiple option orders.
     * @summary Place Multiple Orders(TRADE)
     * @param {TradeApiOptionsCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsCreateBatchOrdersV1(requestParameters: TradeApiOptionsCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsCreateBatchOrdersV1RespInner>>;

    /**
     * Send a new order.
     * @summary New Order (TRADE)
     * @param {TradeApiOptionsCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsCreateOrderV1(requestParameters: TradeApiOptionsCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsCreateOrderV1Resp>;

    /**
     * Cancel all active orders on specified underlying.
     * @summary Cancel All Option Orders By Underlying (TRADE)
     * @param {TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsDeleteAllOpenOrdersByUnderlyingV1(requestParameters: TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsDeleteAllOpenOrdersByUnderlyingV1Resp>;

    /**
     * Cancel all active order on a symbol.
     * @summary Cancel all Option orders on specific symbol (TRADE)
     * @param {TradeApiOptionsDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsDeleteAllOpenOrdersV1(requestParameters: TradeApiOptionsDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsDeleteAllOpenOrdersV1Resp>;

    /**
     * Cancel multiple orders.
     * @summary Cancel Multiple Option Orders (TRADE)
     * @param {TradeApiOptionsDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsDeleteBatchOrdersV1(requestParameters: TradeApiOptionsDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsDeleteBatchOrdersV1RespInner>>;

    /**
     * Cancel an active order.
     * @summary Cancel Option Order (TRADE)
     * @param {TradeApiOptionsDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsDeleteOrderV1(requestParameters: TradeApiOptionsDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsDeleteOrderV1Resp>;

    /**
     * Get account exercise records.
     * @summary User Exercise Record (USER_DATA)
     * @param {TradeApiOptionsGetExerciseRecordV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsGetExerciseRecordV1(requestParameters: TradeApiOptionsGetExerciseRecordV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetExerciseRecordV1RespItem>>;

    /**
     * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
     * @summary Query Option Order History (TRADE)
     * @param {TradeApiOptionsGetHistoryOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsGetHistoryOrdersV1(requestParameters: TradeApiOptionsGetHistoryOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetHistoryOrdersV1RespItem>>;

    /**
     * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
     * @summary Query Current Open Option Orders (USER_DATA)
     * @param {TradeApiOptionsGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsGetOpenOrdersV1(requestParameters: TradeApiOptionsGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetOpenOrdersV1RespItem>>;

    /**
     * Check an order status.
     * @summary Query Single Order (TRADE)
     * @param {TradeApiOptionsGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsGetOrderV1(requestParameters: TradeApiOptionsGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<OptionsGetOrderV1Resp>;

    /**
     * Get current position information.
     * @summary Option Position Information (USER_DATA)
     * @param {TradeApiOptionsGetPositionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsGetPositionV1(requestParameters: TradeApiOptionsGetPositionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetPositionV1RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {TradeApiOptionsGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    optionsGetUserTradesV1(requestParameters: TradeApiOptionsGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<OptionsGetUserTradesV1RespItem>>;

}

/**
 * Request parameters for optionsCreateBatchOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsCreateBatchOrdersV1Request
 */
export interface TradeApiOptionsCreateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<OptionsCreateBatchOrdersV1ReqOrdersItem>}
     * @memberof TradeApiOptionsCreateBatchOrdersV1
     */
    readonly orders: Array<OptionsCreateBatchOrdersV1ReqOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsCreateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsCreateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsCreateOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsCreateOrderV1Request
 */
export interface TradeApiOptionsCreateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly clientOrderId?: string

    /**
     * 
     * @type {boolean}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly isMmp?: boolean

    /**
     * 
     * @type {string}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {boolean}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly postOnly?: boolean

    /**
     * 
     * @type {string}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {boolean}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly reduceOnly?: boolean

    /**
     * 
     * @type {string}
     * @memberof TradeApiOptionsCreateOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for optionsDeleteAllOpenOrdersByUnderlyingV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1Request
 */
export interface TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1Request {
    /**
     * Option underlying, e.g BTCUSDT
     * @type {string}
     * @memberof TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1
     */
    readonly underlying: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsDeleteAllOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsDeleteAllOpenOrdersV1Request
 */
export interface TradeApiOptionsDeleteAllOpenOrdersV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiOptionsDeleteAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsDeleteAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsDeleteAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsDeleteBatchOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsDeleteBatchOrdersV1Request
 */
export interface TradeApiOptionsDeleteBatchOrdersV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiOptionsDeleteBatchOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsDeleteBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * Order ID, e.g [4611875134427365377,4611875134427365378]
     * @type {Array<number>}
     * @memberof TradeApiOptionsDeleteBatchOrdersV1
     */
    readonly orderIds?: Array<number>

    /**
     * User-defined order ID, e.g [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;]
     * @type {Array<string>}
     * @memberof TradeApiOptionsDeleteBatchOrdersV1
     */
    readonly clientOrderIds?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsDeleteBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsDeleteOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsDeleteOrderV1Request
 */
export interface TradeApiOptionsDeleteOrderV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiOptionsDeleteOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsDeleteOrderV1
     */
    readonly timestamp: number

    /**
     * Order ID, e.g 4611875134427365377
     * @type {number}
     * @memberof TradeApiOptionsDeleteOrderV1
     */
    readonly orderId?: number

    /**
     * User-defined order ID, e.g 10000
     * @type {string}
     * @memberof TradeApiOptionsDeleteOrderV1
     */
    readonly clientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsDeleteOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsGetExerciseRecordV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsGetExerciseRecordV1Request
 */
export interface TradeApiOptionsGetExerciseRecordV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetExerciseRecordV1
     */
    readonly timestamp: number

    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiOptionsGetExerciseRecordV1
     */
    readonly symbol?: string

    /**
     * startTime
     * @type {number}
     * @memberof TradeApiOptionsGetExerciseRecordV1
     */
    readonly startTime?: number

    /**
     * endTime
     * @type {number}
     * @memberof TradeApiOptionsGetExerciseRecordV1
     */
    readonly endTime?: number

    /**
     * default 1000, max 1000
     * @type {number}
     * @memberof TradeApiOptionsGetExerciseRecordV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetExerciseRecordV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsGetHistoryOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsGetHistoryOrdersV1Request
 */
export interface TradeApiOptionsGetHistoryOrdersV1Request {
    /**
     * Option trading pair
     * @type {string}
     * @memberof TradeApiOptionsGetHistoryOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetHistoryOrdersV1
     */
    readonly timestamp: number

    /**
     * Returns the orderId and subsequent orders, the most recent order is returned by default
     * @type {number}
     * @memberof TradeApiOptionsGetHistoryOrdersV1
     */
    readonly orderId?: number

    /**
     * Start Time, e.g 1593511200000
     * @type {number}
     * @memberof TradeApiOptionsGetHistoryOrdersV1
     */
    readonly startTime?: number

    /**
     * End Time, e.g 1593512200000
     * @type {number}
     * @memberof TradeApiOptionsGetHistoryOrdersV1
     */
    readonly endTime?: number

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof TradeApiOptionsGetHistoryOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetHistoryOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsGetOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsGetOpenOrdersV1Request
 */
export interface TradeApiOptionsGetOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * return all orders if don&amp;#39;t pass, Option trading pair, e.g BTC-200730-9000-C,
     * @type {string}
     * @memberof TradeApiOptionsGetOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * Returns the orderId and subsequent orders, the most recent order is returned by default
     * @type {number}
     * @memberof TradeApiOptionsGetOpenOrdersV1
     */
    readonly orderId?: number

    /**
     * Start Time
     * @type {number}
     * @memberof TradeApiOptionsGetOpenOrdersV1
     */
    readonly startTime?: number

    /**
     * End Time
     * @type {number}
     * @memberof TradeApiOptionsGetOpenOrdersV1
     */
    readonly endTime?: number

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof TradeApiOptionsGetOpenOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsGetOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsGetOrderV1Request
 */
export interface TradeApiOptionsGetOrderV1Request {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiOptionsGetOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetOrderV1
     */
    readonly timestamp: number

    /**
     * Order id
     * @type {number}
     * @memberof TradeApiOptionsGetOrderV1
     */
    readonly orderId?: number

    /**
     * User-defined order ID cannot be repeated in pending orders
     * @type {string}
     * @memberof TradeApiOptionsGetOrderV1
     */
    readonly clientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsGetPositionV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsGetPositionV1Request
 */
export interface TradeApiOptionsGetPositionV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetPositionV1
     */
    readonly timestamp: number

    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiOptionsGetPositionV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetPositionV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for optionsGetUserTradesV1 operation in TradeApi.
 * @export
 * @interface TradeApiOptionsGetUserTradesV1Request
 */
export interface TradeApiOptionsGetUserTradesV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetUserTradesV1
     */
    readonly timestamp: number

    /**
     * Option symbol, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiOptionsGetUserTradesV1
     */
    readonly symbol?: string

    /**
     * Trade id to fetch from. Default gets most recent trades, e.g 4611875134427365376
     * @type {number}
     * @memberof TradeApiOptionsGetUserTradesV1
     */
    readonly fromId?: number

    /**
     * Start time, e.g 1593511200000
     * @type {number}
     * @memberof TradeApiOptionsGetUserTradesV1
     */
    readonly startTime?: number

    /**
     * End time, e.g 1593512200000
     * @type {number}
     * @memberof TradeApiOptionsGetUserTradesV1
     */
    readonly endTime?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiOptionsGetUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiOptionsGetUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI implements TradeApiInterface {
    /**
     * Send multiple option orders.
     * @summary Place Multiple Orders(TRADE)
     * @param {TradeApiOptionsCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsCreateBatchOrdersV1(requestParameters: TradeApiOptionsCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsCreateBatchOrdersV1(requestParameters.orders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a new order.
     * @summary New Order (TRADE)
     * @param {TradeApiOptionsCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsCreateOrderV1(requestParameters: TradeApiOptionsCreateOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsCreateOrderV1(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.clientOrderId, requestParameters.isMmp, requestParameters.newOrderRespType, requestParameters.postOnly, requestParameters.price, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all active orders on specified underlying.
     * @summary Cancel All Option Orders By Underlying (TRADE)
     * @param {TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsDeleteAllOpenOrdersByUnderlyingV1(requestParameters: TradeApiOptionsDeleteAllOpenOrdersByUnderlyingV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsDeleteAllOpenOrdersByUnderlyingV1(requestParameters.underlying, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all active order on a symbol.
     * @summary Cancel all Option orders on specific symbol (TRADE)
     * @param {TradeApiOptionsDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsDeleteAllOpenOrdersV1(requestParameters: TradeApiOptionsDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsDeleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel multiple orders.
     * @summary Cancel Multiple Option Orders (TRADE)
     * @param {TradeApiOptionsDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsDeleteBatchOrdersV1(requestParameters: TradeApiOptionsDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsDeleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIds, requestParameters.clientOrderIds, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel Option Order (TRADE)
     * @param {TradeApiOptionsDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsDeleteOrderV1(requestParameters: TradeApiOptionsDeleteOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsDeleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.clientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account exercise records.
     * @summary User Exercise Record (USER_DATA)
     * @param {TradeApiOptionsGetExerciseRecordV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsGetExerciseRecordV1(requestParameters: TradeApiOptionsGetExerciseRecordV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsGetExerciseRecordV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
     * @summary Query Option Order History (TRADE)
     * @param {TradeApiOptionsGetHistoryOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsGetHistoryOrdersV1(requestParameters: TradeApiOptionsGetHistoryOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsGetHistoryOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
     * @summary Query Current Open Option Orders (USER_DATA)
     * @param {TradeApiOptionsGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsGetOpenOrdersV1(requestParameters: TradeApiOptionsGetOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsGetOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order status.
     * @summary Query Single Order (TRADE)
     * @param {TradeApiOptionsGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsGetOrderV1(requestParameters: TradeApiOptionsGetOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsGetOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.clientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current position information.
     * @summary Option Position Information (USER_DATA)
     * @param {TradeApiOptionsGetPositionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsGetPositionV1(requestParameters: TradeApiOptionsGetPositionV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsGetPositionV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {TradeApiOptionsGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public optionsGetUserTradesV1(requestParameters: TradeApiOptionsGetUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).optionsGetUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

