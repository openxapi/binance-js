/* tslint:disable */
/* eslint-disable */
/**
 * Binance USD-M Futures API
 * OpenAPI specification for Binance exchange - Umfutures API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { UmfuturesCreateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { UmfuturesCreateCountdownCancelAllV1Req } from '../model';
// @ts-ignore
import type { UmfuturesCreateCountdownCancelAllV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesCreateLeverageV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesCreateMarginTypeV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesCreateMultiAssetsMarginV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesCreateOrderTestV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesCreateOrderV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesCreatePositionMarginV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesCreatePositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesDeleteAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesDeleteBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { UmfuturesDeleteOrderV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetOrderV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetPositionMarginHistoryV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetPositionRiskV2RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetPositionRiskV3RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { UmfuturesUpdateBatchOrdersV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesUpdateOrderV1Resp } from '../model';
/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateBatchOrdersV1: async (batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('umfuturesCreateBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesCreateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {UmfuturesCreateCountdownCancelAllV1Req} [umfuturesCreateCountdownCancelAllV1Req] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateCountdownCancelAllV1: async (umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/countdownCancelAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(umfuturesCreateCountdownCancelAllV1Req, localVarRequestOptions, configuration)
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('umfuturesCreateLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesCreateLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesCreateLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateMarginTypeV1: async (marginType: string, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marginType' is not null or undefined
            assertParamExists('umfuturesCreateMarginTypeV1', 'marginType', marginType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesCreateMarginTypeV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesCreateMarginTypeV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/marginType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (marginType !== undefined) { 
                localVarFormParams.set('marginType', marginType as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {string} multiAssetsMargin 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateMultiAssetsMarginV1: async (multiAssetsMargin: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'multiAssetsMargin' is not null or undefined
            assertParamExists('umfuturesCreateMultiAssetsMarginV1', 'multiAssetsMargin', multiAssetsMargin)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesCreateMultiAssetsMarginV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/multiAssetsMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (multiAssetsMargin !== undefined) { 
                localVarFormParams.set('multiAssetsMargin', multiAssetsMargin as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateOrderTestV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('umfuturesCreateOrderTestV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesCreateOrderTestV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesCreateOrderTestV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('umfuturesCreateOrderTestV1', 'type', type)
            const localVarPath = `/fapi/v1/order/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateOrderV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('umfuturesCreateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesCreateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesCreateOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('umfuturesCreateOrderV1', 'type', type)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreatePositionMarginV1: async (amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('umfuturesCreatePositionMarginV1', 'amount', amount)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesCreatePositionMarginV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesCreatePositionMarginV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('umfuturesCreatePositionMarginV1', 'type', type)
            const localVarPath = `/fapi/v1/positionMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreatePositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('umfuturesCreatePositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesCreatePositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesDeleteAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesDeleteAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesDeleteAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesDeleteBatchOrdersV1: async (symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesDeleteBatchOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesDeleteBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIdList) {
                localVarQueryParameter['orderIdList'] = orderIdList;
            }

            if (origClientOrderIdList) {
                localVarQueryParameter['origClientOrderIdList'] = origClientOrderIdList;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesDeleteOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesDeleteOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesDeleteOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetAdlQuantileV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetAdlQuantileV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetAllOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOpenOrdersV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin，2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] Default current time if not pass
         * @param {number} [limit] Default: 500
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPositionMarginHistoryV1: async (symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetPositionMarginHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetPositionMarginHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/positionMargin/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPositionRiskV2: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetPositionRiskV2', 'timestamp', timestamp)
            const localVarPath = `/fapi/v2/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPositionRiskV3: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetPositionRiskV3', 'timestamp', timestamp)
            const localVarPath = `/fapi/v3/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] This can only be used in combination with &#x60;symbol&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetUserTradesV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetUserTradesV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesGetUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesUpdateBatchOrdersV1: async (batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('umfuturesUpdateBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesUpdateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesUpdateOrderV1: async (price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('umfuturesUpdateOrderV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('umfuturesUpdateOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('umfuturesUpdateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesUpdateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('umfuturesUpdateOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration)
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreateBatchOrdersV1(batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreateBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {UmfuturesCreateCountdownCancelAllV1Req} [umfuturesCreateCountdownCancelAllV1Req] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreateCountdownCancelAllV1(umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreateCountdownCancelAllV1(umfuturesCreateCountdownCancelAllV1Req, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreateCountdownCancelAllV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreateLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreateLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreateLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreateLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreateMarginTypeV1(marginType: string, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreateMarginTypeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreateMarginTypeV1(marginType, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreateMarginTypeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {string} multiAssetsMargin 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreateMultiAssetsMarginV1(multiAssetsMargin: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreateMultiAssetsMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreateMultiAssetsMarginV1(multiAssetsMargin, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreateMultiAssetsMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreateOrderTestV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreateOrderTestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreateOrderTestV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, goodTillDate, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreateOrderTestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreateOrderV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreateOrderV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, goodTillDate, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreatePositionMarginV1(amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreatePositionMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreatePositionMarginV1(amount, symbol, timestamp, type, positionSide, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreatePositionMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesCreatePositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreatePositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesCreatePositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesCreatePositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesDeleteAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesDeleteAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesDeleteAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesDeleteAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesDeleteBatchOrdersV1(symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesDeleteBatchOrdersV1(symbol, timestamp, orderIdList, origClientOrderIdList, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesDeleteBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesDeleteOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesDeleteOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesDeleteOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesDeleteOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetAdlQuantileV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetAdlQuantileV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetAllOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetAllOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetForceOrdersV1(timestamp, symbol, autoCloseType, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetOpenOrdersV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetOpenOrdersV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin，2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] Default current time if not pass
         * @param {number} [limit] Default: 500
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetPositionMarginHistoryV1(symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetPositionMarginHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetPositionMarginHistoryV1(symbol, timestamp, type, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetPositionMarginHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetPositionRiskV2(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetPositionRiskV2RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetPositionRiskV2(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetPositionRiskV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetPositionRiskV3(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetPositionRiskV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetPositionRiskV3(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetPositionRiskV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] This can only be used in combination with &#x60;symbol&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetUserTradesV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetUserTradesV1(symbol, timestamp, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesGetUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesUpdateBatchOrdersV1(batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesUpdateBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesUpdateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesUpdateOrderV1(price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesUpdateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesUpdateOrderV1(price, quantity, side, symbol, timestamp, orderId, origClientOrderId, priceMatch, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.umfuturesUpdateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeApiFp(configuration)
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {TradeApiUmfuturesCreateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateBatchOrdersV1(requestParameters: TradeApiUmfuturesCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>> {
            return localVarFp.umfuturesCreateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {TradeApiUmfuturesCreateCountdownCancelAllV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateCountdownCancelAllV1(requestParameters: TradeApiUmfuturesCreateCountdownCancelAllV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp> {
            return localVarFp.umfuturesCreateCountdownCancelAllV1(requestParameters.umfuturesCreateCountdownCancelAllV1Req, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {TradeApiUmfuturesCreateLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateLeverageV1(requestParameters: TradeApiUmfuturesCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateLeverageV1Resp> {
            return localVarFp.umfuturesCreateLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {TradeApiUmfuturesCreateMarginTypeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateMarginTypeV1(requestParameters: TradeApiUmfuturesCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateMarginTypeV1Resp> {
            return localVarFp.umfuturesCreateMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {TradeApiUmfuturesCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateMultiAssetsMarginV1(requestParameters: TradeApiUmfuturesCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateMultiAssetsMarginV1Resp> {
            return localVarFp.umfuturesCreateMultiAssetsMarginV1(requestParameters.multiAssetsMargin, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {TradeApiUmfuturesCreateOrderTestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateOrderTestV1(requestParameters: TradeApiUmfuturesCreateOrderTestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateOrderTestV1Resp> {
            return localVarFp.umfuturesCreateOrderTestV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {TradeApiUmfuturesCreateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreateOrderV1(requestParameters: TradeApiUmfuturesCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateOrderV1Resp> {
            return localVarFp.umfuturesCreateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {TradeApiUmfuturesCreatePositionMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreatePositionMarginV1(requestParameters: TradeApiUmfuturesCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreatePositionMarginV1Resp> {
            return localVarFp.umfuturesCreatePositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {TradeApiUmfuturesCreatePositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesCreatePositionSideDualV1(requestParameters: TradeApiUmfuturesCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreatePositionSideDualV1Resp> {
            return localVarFp.umfuturesCreatePositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {TradeApiUmfuturesDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesDeleteAllOpenOrdersV1(requestParameters: TradeApiUmfuturesDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesDeleteAllOpenOrdersV1Resp> {
            return localVarFp.umfuturesDeleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {TradeApiUmfuturesDeleteBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesDeleteBatchOrdersV1(requestParameters: TradeApiUmfuturesDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>> {
            return localVarFp.umfuturesDeleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {TradeApiUmfuturesDeleteOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesDeleteOrderV1(requestParameters: TradeApiUmfuturesDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesDeleteOrderV1Resp> {
            return localVarFp.umfuturesDeleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {TradeApiUmfuturesGetAdlQuantileV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetAdlQuantileV1(requestParameters: TradeApiUmfuturesGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAdlQuantileV1RespItem>> {
            return localVarFp.umfuturesGetAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {TradeApiUmfuturesGetAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetAllOrdersV1(requestParameters: TradeApiUmfuturesGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAllOrdersV1RespItem>> {
            return localVarFp.umfuturesGetAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {TradeApiUmfuturesGetForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetForceOrdersV1(requestParameters: TradeApiUmfuturesGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetForceOrdersV1RespItem>> {
            return localVarFp.umfuturesGetForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {TradeApiUmfuturesGetOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOpenOrderV1(requestParameters: TradeApiUmfuturesGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOpenOrderV1Resp> {
            return localVarFp.umfuturesGetOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {TradeApiUmfuturesGetOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOpenOrdersV1(requestParameters: TradeApiUmfuturesGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetOpenOrdersV1RespItem>> {
            return localVarFp.umfuturesGetOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {TradeApiUmfuturesGetOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOrderAmendmentV1(requestParameters: TradeApiUmfuturesGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetOrderAmendmentV1RespItem>> {
            return localVarFp.umfuturesGetOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {TradeApiUmfuturesGetOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOrderV1(requestParameters: TradeApiUmfuturesGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOrderV1Resp> {
            return localVarFp.umfuturesGetOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {TradeApiUmfuturesGetPositionMarginHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPositionMarginHistoryV1(requestParameters: TradeApiUmfuturesGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetPositionMarginHistoryV1RespItem>> {
            return localVarFp.umfuturesGetPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {TradeApiUmfuturesGetPositionRiskV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPositionRiskV2(requestParameters: TradeApiUmfuturesGetPositionRiskV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetPositionRiskV2RespItem>> {
            return localVarFp.umfuturesGetPositionRiskV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {TradeApiUmfuturesGetPositionRiskV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPositionRiskV3(requestParameters: TradeApiUmfuturesGetPositionRiskV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetPositionRiskV3RespItem>> {
            return localVarFp.umfuturesGetPositionRiskV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {TradeApiUmfuturesGetUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetUserTradesV1(requestParameters: TradeApiUmfuturesGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetUserTradesV1RespItem>> {
            return localVarFp.umfuturesGetUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {TradeApiUmfuturesUpdateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesUpdateBatchOrdersV1(requestParameters: TradeApiUmfuturesUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>> {
            return localVarFp.umfuturesUpdateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {TradeApiUmfuturesUpdateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesUpdateOrderV1(requestParameters: TradeApiUmfuturesUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesUpdateOrderV1Resp> {
            return localVarFp.umfuturesUpdateOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeApi - interface
 * @export
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Place Multiple Orders
     * @summary Place Multiple Orders(TRADE)
     * @param {TradeApiUmfuturesCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreateBatchOrdersV1(requestParameters: TradeApiUmfuturesCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>>;

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {TradeApiUmfuturesCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreateCountdownCancelAllV1(requestParameters?: TradeApiUmfuturesCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp>;

    /**
     * Change user\'s initial leverage of specific symbol market.
     * @summary Change Initial Leverage(TRADE)
     * @param {TradeApiUmfuturesCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreateLeverageV1(requestParameters: TradeApiUmfuturesCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateLeverageV1Resp>;

    /**
     * Change symbol level margin type
     * @summary Change Margin Type(TRADE)
     * @param {TradeApiUmfuturesCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreateMarginTypeV1(requestParameters: TradeApiUmfuturesCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateMarginTypeV1Resp>;

    /**
     * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Change Multi-Assets Mode (TRADE)
     * @param {TradeApiUmfuturesCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreateMultiAssetsMarginV1(requestParameters: TradeApiUmfuturesCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateMultiAssetsMarginV1Resp>;

    /**
     * Testing order request, this order will not be submitted to matching engine
     * @summary Test Order(TRADE)
     * @param {TradeApiUmfuturesCreateOrderTestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreateOrderTestV1(requestParameters: TradeApiUmfuturesCreateOrderTestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateOrderTestV1Resp>;

    /**
     * Send in a new order.
     * @summary New Order(TRADE)
     * @param {TradeApiUmfuturesCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreateOrderV1(requestParameters: TradeApiUmfuturesCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateOrderV1Resp>;

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {TradeApiUmfuturesCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreatePositionMarginV1(requestParameters: TradeApiUmfuturesCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreatePositionMarginV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {TradeApiUmfuturesCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesCreatePositionSideDualV1(requestParameters: TradeApiUmfuturesCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreatePositionSideDualV1Resp>;

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders (TRADE)
     * @param {TradeApiUmfuturesDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesDeleteAllOpenOrdersV1(requestParameters: TradeApiUmfuturesDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesDeleteAllOpenOrdersV1Resp>;

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders (TRADE)
     * @param {TradeApiUmfuturesDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesDeleteBatchOrdersV1(requestParameters: TradeApiUmfuturesDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>>;

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {TradeApiUmfuturesDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesDeleteOrderV1(requestParameters: TradeApiUmfuturesDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesDeleteOrderV1Resp>;

    /**
     * Position ADL Quantile Estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {TradeApiUmfuturesGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetAdlQuantileV1(requestParameters: TradeApiUmfuturesGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAdlQuantileV1RespItem>>;

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {TradeApiUmfuturesGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetAllOrdersV1(requestParameters: TradeApiUmfuturesGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAllOrdersV1RespItem>>;

    /**
     * Query user\'s Force Orders
     * @summary User\'s Force Orders (USER_DATA)
     * @param {TradeApiUmfuturesGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetForceOrdersV1(requestParameters: TradeApiUmfuturesGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetForceOrdersV1RespItem>>;

    /**
     * Query open order
     * @summary Query Current Open Order (USER_DATA)
     * @param {TradeApiUmfuturesGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetOpenOrderV1(requestParameters: TradeApiUmfuturesGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {TradeApiUmfuturesGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetOpenOrdersV1(requestParameters: TradeApiUmfuturesGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {TradeApiUmfuturesGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetOrderAmendmentV1(requestParameters: TradeApiUmfuturesGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetOrderAmendmentV1RespItem>>;

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {TradeApiUmfuturesGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetOrderV1(requestParameters: TradeApiUmfuturesGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOrderV1Resp>;

    /**
     * Get Position Margin Change History
     * @summary Get Position Margin Change History (TRADE)
     * @param {TradeApiUmfuturesGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetPositionMarginHistoryV1(requestParameters: TradeApiUmfuturesGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetPositionMarginHistoryV1RespItem>>;

    /**
     * Get current position information.
     * @summary Position Information V2 (USER_DATA)
     * @param {TradeApiUmfuturesGetPositionRiskV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetPositionRiskV2(requestParameters: TradeApiUmfuturesGetPositionRiskV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetPositionRiskV2RespItem>>;

    /**
     * Get current position information(only symbol that has position or open orders will be returned).
     * @summary Position Information V3 (USER_DATA)
     * @param {TradeApiUmfuturesGetPositionRiskV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetPositionRiskV3(requestParameters: TradeApiUmfuturesGetPositionRiskV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetPositionRiskV3RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {TradeApiUmfuturesGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesGetUserTradesV1(requestParameters: TradeApiUmfuturesGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetUserTradesV1RespItem>>;

    /**
     * Modify Multiple Orders (TRADE)
     * @summary Modify Multiple Orders(TRADE)
     * @param {TradeApiUmfuturesUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesUpdateBatchOrdersV1(requestParameters: TradeApiUmfuturesUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {TradeApiUmfuturesUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    umfuturesUpdateOrderV1(requestParameters: TradeApiUmfuturesUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesUpdateOrderV1Resp>;

}

/**
 * Request parameters for umfuturesCreateBatchOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreateBatchOrdersV1Request
 */
export interface TradeApiUmfuturesCreateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>}
     * @memberof TradeApiUmfuturesCreateBatchOrdersV1
     */
    readonly batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesCreateCountdownCancelAllV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreateCountdownCancelAllV1Request
 */
export interface TradeApiUmfuturesCreateCountdownCancelAllV1Request {
    /**
     * 
     * @type {UmfuturesCreateCountdownCancelAllV1Req}
     * @memberof TradeApiUmfuturesCreateCountdownCancelAllV1
     */
    readonly umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req
}

/**
 * Request parameters for umfuturesCreateLeverageV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreateLeverageV1Request
 */
export interface TradeApiUmfuturesCreateLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesCreateMarginTypeV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreateMarginTypeV1Request
 */
export interface TradeApiUmfuturesCreateMarginTypeV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateMarginTypeV1
     */
    readonly marginType: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateMarginTypeV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateMarginTypeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateMarginTypeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesCreateMultiAssetsMarginV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreateMultiAssetsMarginV1Request
 */
export interface TradeApiUmfuturesCreateMultiAssetsMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateMultiAssetsMarginV1
     */
    readonly multiAssetsMargin: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateMultiAssetsMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateMultiAssetsMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesCreateOrderTestV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreateOrderTestV1Request
 */
export interface TradeApiUmfuturesCreateOrderTestV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderTestV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for umfuturesCreateOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreateOrderV1Request
 */
export interface TradeApiUmfuturesCreateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreateOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for umfuturesCreatePositionMarginV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreatePositionMarginV1Request
 */
export interface TradeApiUmfuturesCreatePositionMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreatePositionMarginV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreatePositionMarginV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreatePositionMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreatePositionMarginV1
     */
    readonly type: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreatePositionMarginV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreatePositionMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesCreatePositionSideDualV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesCreatePositionSideDualV1Request
 */
export interface TradeApiUmfuturesCreatePositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesCreatePositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreatePositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesCreatePositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesDeleteAllOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesDeleteAllOpenOrdersV1Request
 */
export interface TradeApiUmfuturesDeleteAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesDeleteAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesDeleteAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesDeleteAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesDeleteBatchOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesDeleteBatchOrdersV1Request
 */
export interface TradeApiUmfuturesDeleteBatchOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesDeleteBatchOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesDeleteBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * max length 10 &lt;br/&gt; e.g. [1234567,2345678]
     * @type {Array<number>}
     * @memberof TradeApiUmfuturesDeleteBatchOrdersV1
     */
    readonly orderIdList?: Array<number>

    /**
     * max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
     * @type {Array<string>}
     * @memberof TradeApiUmfuturesDeleteBatchOrdersV1
     */
    readonly origClientOrderIdList?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesDeleteBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesDeleteOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesDeleteOrderV1Request
 */
export interface TradeApiUmfuturesDeleteOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesDeleteOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesDeleteOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesDeleteOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesDeleteOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesDeleteOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetAdlQuantileV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetAdlQuantileV1Request
 */
export interface TradeApiUmfuturesGetAdlQuantileV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetAdlQuantileV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetAdlQuantileV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetAdlQuantileV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetAllOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetAllOrdersV1Request
 */
export interface TradeApiUmfuturesGetAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiUmfuturesGetAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetForceOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetForceOrdersV1Request
 */
export interface TradeApiUmfuturesGetForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetForceOrdersV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
     * @type {string}
     * @memberof TradeApiUmfuturesGetForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof TradeApiUmfuturesGetForceOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetOpenOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetOpenOrderV1Request
 */
export interface TradeApiUmfuturesGetOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetOpenOrdersV1Request
 */
export interface TradeApiUmfuturesGetOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetOrderAmendmentV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetOrderAmendmentV1Request
 */
export interface TradeApiUmfuturesGetOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetOrderV1Request
 */
export interface TradeApiUmfuturesGetOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetPositionMarginHistoryV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetPositionMarginHistoryV1Request
 */
export interface TradeApiUmfuturesGetPositionMarginHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetPositionMarginHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionMarginHistoryV1
     */
    readonly timestamp: number

    /**
     * 1: Add position margin，2: Reduce position margin
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionMarginHistoryV1
     */
    readonly type?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionMarginHistoryV1
     */
    readonly startTime?: number

    /**
     * Default current time if not pass
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionMarginHistoryV1
     */
    readonly endTime?: number

    /**
     * Default: 500
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionMarginHistoryV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionMarginHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetPositionRiskV2 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetPositionRiskV2Request
 */
export interface TradeApiUmfuturesGetPositionRiskV2Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionRiskV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetPositionRiskV2
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionRiskV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetPositionRiskV3 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetPositionRiskV3Request
 */
export interface TradeApiUmfuturesGetPositionRiskV3Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionRiskV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetPositionRiskV3
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetPositionRiskV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesGetUserTradesV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesGetUserTradesV1Request
 */
export interface TradeApiUmfuturesGetUserTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesGetUserTradesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetUserTradesV1
     */
    readonly timestamp: number

    /**
     * This can only be used in combination with &#x60;symbol&#x60;
     * @type {number}
     * @memberof TradeApiUmfuturesGetUserTradesV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof TradeApiUmfuturesGetUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiUmfuturesGetUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesGetUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesUpdateBatchOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesUpdateBatchOrdersV1Request
 */
export interface TradeApiUmfuturesUpdateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>}
     * @memberof TradeApiUmfuturesUpdateBatchOrdersV1
     */
    readonly batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesUpdateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesUpdateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for umfuturesUpdateOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiUmfuturesUpdateOrderV1Request
 */
export interface TradeApiUmfuturesUpdateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiUmfuturesUpdateOrderV1
     */
    readonly recvWindow?: number
}

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI implements TradeApiInterface {
    /**
     * Place Multiple Orders
     * @summary Place Multiple Orders(TRADE)
     * @param {TradeApiUmfuturesCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreateBatchOrdersV1(requestParameters: TradeApiUmfuturesCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {TradeApiUmfuturesCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreateCountdownCancelAllV1(requestParameters: TradeApiUmfuturesCreateCountdownCancelAllV1Request = {}, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreateCountdownCancelAllV1(requestParameters.umfuturesCreateCountdownCancelAllV1Req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage of specific symbol market.
     * @summary Change Initial Leverage(TRADE)
     * @param {TradeApiUmfuturesCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreateLeverageV1(requestParameters: TradeApiUmfuturesCreateLeverageV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreateLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change symbol level margin type
     * @summary Change Margin Type(TRADE)
     * @param {TradeApiUmfuturesCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreateMarginTypeV1(requestParameters: TradeApiUmfuturesCreateMarginTypeV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreateMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Change Multi-Assets Mode (TRADE)
     * @param {TradeApiUmfuturesCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreateMultiAssetsMarginV1(requestParameters: TradeApiUmfuturesCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreateMultiAssetsMarginV1(requestParameters.multiAssetsMargin, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Testing order request, this order will not be submitted to matching engine
     * @summary Test Order(TRADE)
     * @param {TradeApiUmfuturesCreateOrderTestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreateOrderTestV1(requestParameters: TradeApiUmfuturesCreateOrderTestV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreateOrderTestV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new order.
     * @summary New Order(TRADE)
     * @param {TradeApiUmfuturesCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreateOrderV1(requestParameters: TradeApiUmfuturesCreateOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {TradeApiUmfuturesCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreatePositionMarginV1(requestParameters: TradeApiUmfuturesCreatePositionMarginV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreatePositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {TradeApiUmfuturesCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesCreatePositionSideDualV1(requestParameters: TradeApiUmfuturesCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesCreatePositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders (TRADE)
     * @param {TradeApiUmfuturesDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesDeleteAllOpenOrdersV1(requestParameters: TradeApiUmfuturesDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesDeleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders (TRADE)
     * @param {TradeApiUmfuturesDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesDeleteBatchOrdersV1(requestParameters: TradeApiUmfuturesDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesDeleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {TradeApiUmfuturesDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesDeleteOrderV1(requestParameters: TradeApiUmfuturesDeleteOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesDeleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Position ADL Quantile Estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {TradeApiUmfuturesGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetAdlQuantileV1(requestParameters: TradeApiUmfuturesGetAdlQuantileV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {TradeApiUmfuturesGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetAllOrdersV1(requestParameters: TradeApiUmfuturesGetAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user\'s Force Orders
     * @summary User\'s Force Orders (USER_DATA)
     * @param {TradeApiUmfuturesGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetForceOrdersV1(requestParameters: TradeApiUmfuturesGetForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query open order
     * @summary Query Current Open Order (USER_DATA)
     * @param {TradeApiUmfuturesGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetOpenOrderV1(requestParameters: TradeApiUmfuturesGetOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {TradeApiUmfuturesGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetOpenOrdersV1(requestParameters: TradeApiUmfuturesGetOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {TradeApiUmfuturesGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetOrderAmendmentV1(requestParameters: TradeApiUmfuturesGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {TradeApiUmfuturesGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetOrderV1(requestParameters: TradeApiUmfuturesGetOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Position Margin Change History
     * @summary Get Position Margin Change History (TRADE)
     * @param {TradeApiUmfuturesGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetPositionMarginHistoryV1(requestParameters: TradeApiUmfuturesGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current position information.
     * @summary Position Information V2 (USER_DATA)
     * @param {TradeApiUmfuturesGetPositionRiskV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetPositionRiskV2(requestParameters: TradeApiUmfuturesGetPositionRiskV2Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetPositionRiskV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current position information(only symbol that has position or open orders will be returned).
     * @summary Position Information V3 (USER_DATA)
     * @param {TradeApiUmfuturesGetPositionRiskV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetPositionRiskV3(requestParameters: TradeApiUmfuturesGetPositionRiskV3Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetPositionRiskV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {TradeApiUmfuturesGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesGetUserTradesV1(requestParameters: TradeApiUmfuturesGetUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesGetUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Multiple Orders (TRADE)
     * @summary Modify Multiple Orders(TRADE)
     * @param {TradeApiUmfuturesUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesUpdateBatchOrdersV1(requestParameters: TradeApiUmfuturesUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesUpdateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {TradeApiUmfuturesUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public umfuturesUpdateOrderV1(requestParameters: TradeApiUmfuturesUpdateOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).umfuturesUpdateOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

