/* tslint:disable */
/* eslint-disable */
/**
 * Binance USD-M Futures API
 * OpenAPI specification for Binance exchange - Umfutures API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { UmfuturesGetAggTradesV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetAssetIndexV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetConstituentsV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetContinuousKlinesV1RespInnerInner } from '../model';
// @ts-ignore
import type { UmfuturesGetDepthV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetExchangeInfoV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetFundingInfoV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetFundingRateV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataBasisRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataDeliveryPriceRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataOpenInterestHistRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataTakerlongshortRatioRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataTopLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataTopLongShortPositionRatioRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetHistoricalTradesV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetIndexInfoV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetOpenInterestV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetPremiumIndexV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTicker24hrV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerBookTickerV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerPriceV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerPriceV2Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTimeV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTradesV1RespItem } from '../model';
/**
 * MarketDataApi - axios parameter creator
 * @export
 */
export const MarketDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetAggTradesV1: async (symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetAggTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/aggTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {string} [symbol] Asset pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetAssetIndexV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/assetIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetConstituentsV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetConstituentsV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/constituents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetContinuousKlinesV1: async (pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('umfuturesGetContinuousKlinesV1', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('umfuturesGetContinuousKlinesV1', 'contractType', contractType)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('umfuturesGetContinuousKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/continuousKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetDepthV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetDepthV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetExchangeInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFundingInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/fundingInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {string} [symbol] 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFundingRateV1: async (symbol?: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/fundingRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {string} pair BTCUSDT
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} limit Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataBasis: async (pair: string, contractType: string, period: string, limit: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataBasis', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataBasis', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataBasis', 'period', period)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataBasis', 'limit', limit)
            const localVarPath = `/futures/data/basis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {string} pair e.g BTCUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataDeliveryPrice: async (pair: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataDeliveryPrice', 'pair', pair)
            const localVarPath = `/futures/data/delivery-price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataGlobalLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataGlobalLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataGlobalLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/globalLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataOpenInterestHist: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataOpenInterestHist', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataOpenInterestHist', 'period', period)
            const localVarPath = `/futures/data/openInterestHist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataTakerlongshortRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataTakerlongshortRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataTakerlongshortRatio', 'period', period)
            const localVarPath = `/futures/data/takerlongshortRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataTopLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataTopLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataTopLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataTopLongShortPositionRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataTopLongShortPositionRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('umfuturesGetFuturesDataTopLongShortPositionRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortPositionRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetHistoricalTradesV1: async (symbol: string, limit?: number, fromId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetHistoricalTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetIndexInfoV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/indexInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetIndexPriceKlinesV1: async (pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('umfuturesGetIndexPriceKlinesV1', 'pair', pair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('umfuturesGetIndexPriceKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/indexPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('umfuturesGetKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetMarkPriceKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetMarkPriceKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('umfuturesGetMarkPriceKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/markPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOpenInterestV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetOpenInterestV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/openInterest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPingV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPremiumIndexKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetPremiumIndexKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('umfuturesGetPremiumIndexKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/premiumIndexKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPremiumIndexV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/premiumIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTicker24hrV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/24hr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTickerBookTickerV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/bookTicker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTickerPriceV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTickerPriceV2: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v2/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTimeV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTradesV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umfuturesGetTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketDataApi - functional programming interface
 * @export
 */
export const MarketDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetAggTradesV1(symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetAggTradesV1(symbol, fromId, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetAggTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {string} [symbol] Asset pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetAssetIndexV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetAssetIndexV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetAssetIndexV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetAssetIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetConstituentsV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetConstituentsV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetConstituentsV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetConstituentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetContinuousKlinesV1(pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetContinuousKlinesV1(pair, contractType, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetContinuousKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetDepthV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetDepthV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetDepthV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetDepthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetExchangeInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetExchangeInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetExchangeInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFundingInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFundingInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFundingInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFundingInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {string} [symbol] 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFundingRateV1(symbol?: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFundingRateV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFundingRateV1(symbol, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFundingRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {string} pair BTCUSDT
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} limit Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFuturesDataBasis(pair: string, contractType: string, period: string, limit: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataBasisRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFuturesDataBasis(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFuturesDataBasis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {string} pair e.g BTCUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFuturesDataDeliveryPrice(pair: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFuturesDataDeliveryPrice(pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFuturesDataDeliveryPrice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFuturesDataGlobalLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFuturesDataGlobalLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFuturesDataGlobalLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFuturesDataOpenInterestHist(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataOpenInterestHistRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFuturesDataOpenInterestHist(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFuturesDataOpenInterestHist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFuturesDataTakerlongshortRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataTakerlongshortRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFuturesDataTakerlongshortRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFuturesDataTakerlongshortRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFuturesDataTopLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataTopLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFuturesDataTopLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFuturesDataTopLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetFuturesDataTopLongShortPositionRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataTopLongShortPositionRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetFuturesDataTopLongShortPositionRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetFuturesDataTopLongShortPositionRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetHistoricalTradesV1(symbol: string, limit?: number, fromId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetHistoricalTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetHistoricalTradesV1(symbol, limit, fromId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetHistoricalTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetIndexInfoV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetIndexInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetIndexInfoV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetIndexInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetIndexPriceKlinesV1(pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetIndexPriceKlinesV1(pair, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetIndexPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetMarkPriceKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetMarkPriceKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetMarkPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetOpenInterestV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetOpenInterestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetOpenInterestV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetOpenInterestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetPingV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetPingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetPingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetPremiumIndexKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetPremiumIndexKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetPremiumIndexKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetPremiumIndexV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetPremiumIndexV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetPremiumIndexV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetPremiumIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetTicker24hrV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTicker24hrV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetTicker24hrV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetTicker24hrV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetTickerBookTickerV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerBookTickerV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetTickerBookTickerV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetTickerBookTickerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetTickerPriceV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerPriceV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetTickerPriceV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetTickerPriceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetTickerPriceV2(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerPriceV2Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetTickerPriceV2(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetTickerPriceV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetTimeV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTimeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetTimeV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetTimeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umfuturesGetTradesV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umfuturesGetTradesV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.umfuturesGetTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketDataApi - factory interface
 * @export
 */
export const MarketDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketDataApiFp(configuration)
    return {
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {MarketDataApiUmfuturesGetAggTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetAggTradesV1(requestParameters: MarketDataApiUmfuturesGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>> {
            return localVarFp.umfuturesGetAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {MarketDataApiUmfuturesGetAssetIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetAssetIndexV1(requestParameters: MarketDataApiUmfuturesGetAssetIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetAssetIndexV1Resp> {
            return localVarFp.umfuturesGetAssetIndexV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {MarketDataApiUmfuturesGetConstituentsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetConstituentsV1(requestParameters: MarketDataApiUmfuturesGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetConstituentsV1Resp> {
            return localVarFp.umfuturesGetConstituentsV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {MarketDataApiUmfuturesGetContinuousKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetContinuousKlinesV1(requestParameters: MarketDataApiUmfuturesGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.umfuturesGetContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {MarketDataApiUmfuturesGetDepthV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetDepthV1(requestParameters: MarketDataApiUmfuturesGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetDepthV1Resp> {
            return localVarFp.umfuturesGetDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetExchangeInfoV1Resp> {
            return localVarFp.umfuturesGetExchangeInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFundingInfoV1RespItem>> {
            return localVarFp.umfuturesGetFundingInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {MarketDataApiUmfuturesGetFundingRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFundingRateV1(requestParameters: MarketDataApiUmfuturesGetFundingRateV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFundingRateV1RespItem>> {
            return localVarFp.umfuturesGetFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {MarketDataApiUmfuturesGetFuturesDataBasisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataBasis(requestParameters: MarketDataApiUmfuturesGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataBasisRespItem>> {
            return localVarFp.umfuturesGetFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {MarketDataApiUmfuturesGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataDeliveryPrice(requestParameters: MarketDataApiUmfuturesGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>> {
            return localVarFp.umfuturesGetFuturesDataDeliveryPrice(requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem>> {
            return localVarFp.umfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {MarketDataApiUmfuturesGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataOpenInterestHist(requestParameters: MarketDataApiUmfuturesGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataOpenInterestHistRespItem>> {
            return localVarFp.umfuturesGetFuturesDataOpenInterestHist(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataTakerlongshortRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataTakerlongshortRatioRespItem>> {
            return localVarFp.umfuturesGetFuturesDataTakerlongshortRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataTopLongShortAccountRatioRespItem>> {
            return localVarFp.umfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataTopLongShortPositionRatioRespItem>> {
            return localVarFp.umfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {MarketDataApiUmfuturesGetHistoricalTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetHistoricalTradesV1(requestParameters: MarketDataApiUmfuturesGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetHistoricalTradesV1RespItem>> {
            return localVarFp.umfuturesGetHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {MarketDataApiUmfuturesGetIndexInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetIndexInfoV1(requestParameters: MarketDataApiUmfuturesGetIndexInfoV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetIndexInfoV1RespItem>> {
            return localVarFp.umfuturesGetIndexInfoV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {MarketDataApiUmfuturesGetIndexPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetIndexPriceKlinesV1(requestParameters: MarketDataApiUmfuturesGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.umfuturesGetIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {MarketDataApiUmfuturesGetKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetKlinesV1(requestParameters: MarketDataApiUmfuturesGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.umfuturesGetKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {MarketDataApiUmfuturesGetMarkPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetMarkPriceKlinesV1(requestParameters: MarketDataApiUmfuturesGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.umfuturesGetMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {MarketDataApiUmfuturesGetOpenInterestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetOpenInterestV1(requestParameters: MarketDataApiUmfuturesGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOpenInterestV1Resp> {
            return localVarFp.umfuturesGetOpenInterestV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.umfuturesGetPingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {MarketDataApiUmfuturesGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPremiumIndexKlinesV1(requestParameters: MarketDataApiUmfuturesGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.umfuturesGetPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {MarketDataApiUmfuturesGetPremiumIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetPremiumIndexV1(requestParameters: MarketDataApiUmfuturesGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetPremiumIndexV1Resp> {
            return localVarFp.umfuturesGetPremiumIndexV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {MarketDataApiUmfuturesGetTicker24hrV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTicker24hrV1(requestParameters: MarketDataApiUmfuturesGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTicker24hrV1Resp> {
            return localVarFp.umfuturesGetTicker24hrV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {MarketDataApiUmfuturesGetTickerBookTickerV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTickerBookTickerV1(requestParameters: MarketDataApiUmfuturesGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerBookTickerV1Resp> {
            return localVarFp.umfuturesGetTickerBookTickerV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {MarketDataApiUmfuturesGetTickerPriceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTickerPriceV1(requestParameters: MarketDataApiUmfuturesGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV1Resp> {
            return localVarFp.umfuturesGetTickerPriceV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {MarketDataApiUmfuturesGetTickerPriceV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTickerPriceV2(requestParameters: MarketDataApiUmfuturesGetTickerPriceV2Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV2Resp> {
            return localVarFp.umfuturesGetTickerPriceV2(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTimeV1Resp> {
            return localVarFp.umfuturesGetTimeV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {MarketDataApiUmfuturesGetTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umfuturesGetTradesV1(requestParameters: MarketDataApiUmfuturesGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetTradesV1RespItem>> {
            return localVarFp.umfuturesGetTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketDataApi - interface
 * @export
 * @interface MarketDataApi
 */
export interface MarketDataApiInterface {
    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {MarketDataApiUmfuturesGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetAggTradesV1(requestParameters: MarketDataApiUmfuturesGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>>;

    /**
     * asset index for Multi-Assets mode
     * @summary Multi-Assets Mode Asset Index
     * @param {MarketDataApiUmfuturesGetAssetIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetAssetIndexV1(requestParameters?: MarketDataApiUmfuturesGetAssetIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetAssetIndexV1Resp>;

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {MarketDataApiUmfuturesGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetConstituentsV1(requestParameters: MarketDataApiUmfuturesGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetConstituentsV1Resp>;

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {MarketDataApiUmfuturesGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetContinuousKlinesV1(requestParameters: MarketDataApiUmfuturesGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query symbol orderbook
     * @summary Order Book
     * @param {MarketDataApiUmfuturesGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetDepthV1(requestParameters: MarketDataApiUmfuturesGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetDepthV1Resp>;

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetExchangeInfoV1Resp>;

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFundingInfoV1RespItem>>;

    /**
     * Get Funding Rate History
     * @summary Get Funding Rate History
     * @param {MarketDataApiUmfuturesGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFundingRateV1(requestParameters?: MarketDataApiUmfuturesGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFundingRateV1RespItem>>;

    /**
     * Query future basis
     * @summary Basis
     * @param {MarketDataApiUmfuturesGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFuturesDataBasis(requestParameters: MarketDataApiUmfuturesGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataBasisRespItem>>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Quarterly Contract Settlement Price
     * @param {MarketDataApiUmfuturesGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFuturesDataDeliveryPrice(requestParameters: MarketDataApiUmfuturesGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>>;

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem>>;

    /**
     * Open Interest Statistics
     * @summary Open Interest Statistics
     * @param {MarketDataApiUmfuturesGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFuturesDataOpenInterestHist(requestParameters: MarketDataApiUmfuturesGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataOpenInterestHistRespItem>>;

    /**
     * Taker Buy/Sell Volume
     * @summary Taker Buy/Sell Volume
     * @param {MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFuturesDataTakerlongshortRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataTakerlongshortRatioRespItem>>;

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataTopLongShortAccountRatioRespItem>>;

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataTopLongShortPositionRatioRespItem>>;

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {MarketDataApiUmfuturesGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetHistoricalTradesV1(requestParameters: MarketDataApiUmfuturesGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetHistoricalTradesV1RespItem>>;

    /**
     * Query composite index symbol information
     * @summary Composite Index Symbol Information
     * @param {MarketDataApiUmfuturesGetIndexInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetIndexInfoV1(requestParameters?: MarketDataApiUmfuturesGetIndexInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetIndexInfoV1RespItem>>;

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {MarketDataApiUmfuturesGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetIndexPriceKlinesV1(requestParameters: MarketDataApiUmfuturesGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {MarketDataApiUmfuturesGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetKlinesV1(requestParameters: MarketDataApiUmfuturesGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarketDataApiUmfuturesGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetMarkPriceKlinesV1(requestParameters: MarketDataApiUmfuturesGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {MarketDataApiUmfuturesGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetOpenInterestV1(requestParameters: MarketDataApiUmfuturesGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOpenInterestV1Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {MarketDataApiUmfuturesGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetPremiumIndexKlinesV1(requestParameters: MarketDataApiUmfuturesGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Mark Price and Funding Rate
     * @summary Mark Price
     * @param {MarketDataApiUmfuturesGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetPremiumIndexV1(requestParameters?: MarketDataApiUmfuturesGetPremiumIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetPremiumIndexV1Resp>;

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
     * @summary 24hr Ticker Price Change Statistics
     * @param {MarketDataApiUmfuturesGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetTicker24hrV1(requestParameters?: MarketDataApiUmfuturesGetTicker24hrV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTicker24hrV1Resp>;

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {MarketDataApiUmfuturesGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetTickerBookTickerV1(requestParameters?: MarketDataApiUmfuturesGetTickerBookTickerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerBookTickerV1Resp>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {MarketDataApiUmfuturesGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetTickerPriceV1(requestParameters?: MarketDataApiUmfuturesGetTickerPriceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV1Resp>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker V2
     * @param {MarketDataApiUmfuturesGetTickerPriceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetTickerPriceV2(requestParameters?: MarketDataApiUmfuturesGetTickerPriceV2Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV2Resp>;

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTimeV1Resp>;

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {MarketDataApiUmfuturesGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    umfuturesGetTradesV1(requestParameters: MarketDataApiUmfuturesGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetTradesV1RespItem>>;

}

/**
 * Request parameters for umfuturesGetAggTradesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetAggTradesV1Request
 */
export interface MarketDataApiUmfuturesGetAggTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetAggTradesV1
     */
    readonly symbol: string

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetAggTradesV1
     */
    readonly fromId?: number

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetAggTradesV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetAggTradesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetAggTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for umfuturesGetAssetIndexV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetAssetIndexV1Request
 */
export interface MarketDataApiUmfuturesGetAssetIndexV1Request {
    /**
     * Asset pair
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetAssetIndexV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for umfuturesGetConstituentsV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetConstituentsV1Request
 */
export interface MarketDataApiUmfuturesGetConstituentsV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetConstituentsV1
     */
    readonly symbol: string
}

/**
 * Request parameters for umfuturesGetContinuousKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetContinuousKlinesV1Request
 */
export interface MarketDataApiUmfuturesGetContinuousKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetContinuousKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetContinuousKlinesV1
     */
    readonly contractType: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetContinuousKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetContinuousKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetContinuousKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetContinuousKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for umfuturesGetDepthV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetDepthV1Request
 */
export interface MarketDataApiUmfuturesGetDepthV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetDepthV1
     */
    readonly symbol: string

    /**
     * Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetDepthV1
     */
    readonly limit?: number
}

/**
 * Request parameters for umfuturesGetFundingRateV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetFundingRateV1Request
 */
export interface MarketDataApiUmfuturesGetFundingRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFundingRateV1
     */
    readonly symbol?: string

    /**
     * Timestamp in ms to get funding rate from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFundingRateV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding rate  until INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFundingRateV1
     */
    readonly endTime?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFundingRateV1
     */
    readonly limit?: number
}

/**
 * Request parameters for umfuturesGetFuturesDataBasis operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetFuturesDataBasisRequest
 */
export interface MarketDataApiUmfuturesGetFuturesDataBasisRequest {
    /**
     * BTCUSDT
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataBasis
     */
    readonly pair: string

    /**
     * CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataBasis
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataBasis
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataBasis
     */
    readonly limit: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataBasis
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataBasis
     */
    readonly endTime?: number
}

/**
 * Request parameters for umfuturesGetFuturesDataDeliveryPrice operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetFuturesDataDeliveryPriceRequest
 */
export interface MarketDataApiUmfuturesGetFuturesDataDeliveryPriceRequest {
    /**
     * e.g BTCUSDT
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataDeliveryPrice
     */
    readonly pair: string
}

/**
 * Request parameters for umfuturesGetFuturesDataGlobalLongShortAccountRatio operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest
 */
export interface MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for umfuturesGetFuturesDataOpenInterestHist operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetFuturesDataOpenInterestHistRequest
 */
export interface MarketDataApiUmfuturesGetFuturesDataOpenInterestHistRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataOpenInterestHist
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataOpenInterestHist
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataOpenInterestHist
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataOpenInterestHist
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataOpenInterestHist
     */
    readonly endTime?: number
}

/**
 * Request parameters for umfuturesGetFuturesDataTakerlongshortRatio operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatioRequest
 */
export interface MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for umfuturesGetFuturesDataTopLongShortAccountRatio operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatioRequest
 */
export interface MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for umfuturesGetFuturesDataTopLongShortPositionRatio operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatioRequest
 */
export interface MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for umfuturesGetHistoricalTradesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetHistoricalTradesV1Request
 */
export interface MarketDataApiUmfuturesGetHistoricalTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetHistoricalTradesV1
     */
    readonly symbol: string

    /**
     * Default 100; max 500.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetHistoricalTradesV1
     */
    readonly limit?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetHistoricalTradesV1
     */
    readonly fromId?: number
}

/**
 * Request parameters for umfuturesGetIndexInfoV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetIndexInfoV1Request
 */
export interface MarketDataApiUmfuturesGetIndexInfoV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetIndexInfoV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for umfuturesGetIndexPriceKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetIndexPriceKlinesV1Request
 */
export interface MarketDataApiUmfuturesGetIndexPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetIndexPriceKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetIndexPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetIndexPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetIndexPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetIndexPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for umfuturesGetKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetKlinesV1Request
 */
export interface MarketDataApiUmfuturesGetKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for umfuturesGetMarkPriceKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetMarkPriceKlinesV1Request
 */
export interface MarketDataApiUmfuturesGetMarkPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetMarkPriceKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetMarkPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetMarkPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetMarkPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetMarkPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for umfuturesGetOpenInterestV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetOpenInterestV1Request
 */
export interface MarketDataApiUmfuturesGetOpenInterestV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetOpenInterestV1
     */
    readonly symbol: string
}

/**
 * Request parameters for umfuturesGetPremiumIndexKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetPremiumIndexKlinesV1Request
 */
export interface MarketDataApiUmfuturesGetPremiumIndexKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetPremiumIndexKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetPremiumIndexKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetPremiumIndexKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetPremiumIndexKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetPremiumIndexKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for umfuturesGetPremiumIndexV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetPremiumIndexV1Request
 */
export interface MarketDataApiUmfuturesGetPremiumIndexV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetPremiumIndexV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for umfuturesGetTicker24hrV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetTicker24hrV1Request
 */
export interface MarketDataApiUmfuturesGetTicker24hrV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetTicker24hrV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for umfuturesGetTickerBookTickerV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetTickerBookTickerV1Request
 */
export interface MarketDataApiUmfuturesGetTickerBookTickerV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetTickerBookTickerV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for umfuturesGetTickerPriceV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetTickerPriceV1Request
 */
export interface MarketDataApiUmfuturesGetTickerPriceV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetTickerPriceV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for umfuturesGetTickerPriceV2 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetTickerPriceV2Request
 */
export interface MarketDataApiUmfuturesGetTickerPriceV2Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetTickerPriceV2
     */
    readonly symbol?: string
}

/**
 * Request parameters for umfuturesGetTradesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiUmfuturesGetTradesV1Request
 */
export interface MarketDataApiUmfuturesGetTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiUmfuturesGetTradesV1
     */
    readonly symbol: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof MarketDataApiUmfuturesGetTradesV1
     */
    readonly limit?: number
}

/**
 * MarketDataApi - object-oriented interface
 * @export
 * @class MarketDataApi
 * @extends {BaseAPI}
 */
export class MarketDataApi extends BaseAPI implements MarketDataApiInterface {
    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {MarketDataApiUmfuturesGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetAggTradesV1(requestParameters: MarketDataApiUmfuturesGetAggTradesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * asset index for Multi-Assets mode
     * @summary Multi-Assets Mode Asset Index
     * @param {MarketDataApiUmfuturesGetAssetIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetAssetIndexV1(requestParameters: MarketDataApiUmfuturesGetAssetIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetAssetIndexV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {MarketDataApiUmfuturesGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetConstituentsV1(requestParameters: MarketDataApiUmfuturesGetConstituentsV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetConstituentsV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {MarketDataApiUmfuturesGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetContinuousKlinesV1(requestParameters: MarketDataApiUmfuturesGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol orderbook
     * @summary Order Book
     * @param {MarketDataApiUmfuturesGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetDepthV1(requestParameters: MarketDataApiUmfuturesGetDepthV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetExchangeInfoV1(options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetExchangeInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFundingInfoV1(options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFundingInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Funding Rate History
     * @summary Get Funding Rate History
     * @param {MarketDataApiUmfuturesGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFundingRateV1(requestParameters: MarketDataApiUmfuturesGetFundingRateV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query future basis
     * @summary Basis
     * @param {MarketDataApiUmfuturesGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFuturesDataBasis(requestParameters: MarketDataApiUmfuturesGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Quarterly Contract Settlement Price
     * @param {MarketDataApiUmfuturesGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFuturesDataDeliveryPrice(requestParameters: MarketDataApiUmfuturesGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFuturesDataDeliveryPrice(requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Open Interest Statistics
     * @summary Open Interest Statistics
     * @param {MarketDataApiUmfuturesGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFuturesDataOpenInterestHist(requestParameters: MarketDataApiUmfuturesGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFuturesDataOpenInterestHist(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Taker Buy/Sell Volume
     * @summary Taker Buy/Sell Volume
     * @param {MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFuturesDataTakerlongshortRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFuturesDataTakerlongshortRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters: MarketDataApiUmfuturesGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {MarketDataApiUmfuturesGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetHistoricalTradesV1(requestParameters: MarketDataApiUmfuturesGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query composite index symbol information
     * @summary Composite Index Symbol Information
     * @param {MarketDataApiUmfuturesGetIndexInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetIndexInfoV1(requestParameters: MarketDataApiUmfuturesGetIndexInfoV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetIndexInfoV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {MarketDataApiUmfuturesGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetIndexPriceKlinesV1(requestParameters: MarketDataApiUmfuturesGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {MarketDataApiUmfuturesGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetKlinesV1(requestParameters: MarketDataApiUmfuturesGetKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarketDataApiUmfuturesGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetMarkPriceKlinesV1(requestParameters: MarketDataApiUmfuturesGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {MarketDataApiUmfuturesGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetOpenInterestV1(requestParameters: MarketDataApiUmfuturesGetOpenInterestV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetOpenInterestV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetPingV1(options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetPingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {MarketDataApiUmfuturesGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetPremiumIndexKlinesV1(requestParameters: MarketDataApiUmfuturesGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark Price and Funding Rate
     * @summary Mark Price
     * @param {MarketDataApiUmfuturesGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetPremiumIndexV1(requestParameters: MarketDataApiUmfuturesGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetPremiumIndexV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
     * @summary 24hr Ticker Price Change Statistics
     * @param {MarketDataApiUmfuturesGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetTicker24hrV1(requestParameters: MarketDataApiUmfuturesGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetTicker24hrV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {MarketDataApiUmfuturesGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetTickerBookTickerV1(requestParameters: MarketDataApiUmfuturesGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetTickerBookTickerV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {MarketDataApiUmfuturesGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetTickerPriceV1(requestParameters: MarketDataApiUmfuturesGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetTickerPriceV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker V2
     * @param {MarketDataApiUmfuturesGetTickerPriceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetTickerPriceV2(requestParameters: MarketDataApiUmfuturesGetTickerPriceV2Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetTickerPriceV2(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetTimeV1(options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetTimeV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {MarketDataApiUmfuturesGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public umfuturesGetTradesV1(requestParameters: MarketDataApiUmfuturesGetTradesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).umfuturesGetTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}

