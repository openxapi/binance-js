/* tslint:disable */
/* eslint-disable */
/**
 * Binance COIN-M Futures API
 * OpenAPI specification for Binance exchange - Cmfutures API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CmfuturesGetAggTradesV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetConstituentsV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetContinuousKlinesV1RespInnerInner } from '../model';
// @ts-ignore
import type { CmfuturesGetDepthV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetExchangeInfoV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetFundingInfoV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetFundingRateV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetFuturesDataBasisRespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetFuturesDataOpenInterestHistRespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetFuturesDataTakerBuySellVolRespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetFuturesDataTopLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetFuturesDataTopLongShortPositionRatioRespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetHistoricalTradesV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetOpenInterestV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetPremiumIndexV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetTicker24hrV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetTickerBookTickerV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetTickerPriceV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetTimeV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetTradesV1RespItem } from '../model';
/**
 * MarketDataApi - axios parameter creator
 * @export
 */
export const MarketDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetAggTradesV1: async (symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetAggTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/aggTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetConstituentsV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetConstituentsV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/constituents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetContinuousKlinesV1: async (pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('cmfuturesGetContinuousKlinesV1', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('cmfuturesGetContinuousKlinesV1', 'contractType', contractType)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('cmfuturesGetContinuousKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/continuousKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetDepthV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetDepthV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetExchangeInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFundingInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/fundingInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {string} symbol 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFundingRateV1: async (symbol: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetFundingRateV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/fundingRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query basis
         * @summary Basis
         * @param {string} pair BTCUSD
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataBasis: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataBasis', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataBasis', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataBasis', 'period', period)
            const localVarPath = `/futures/data/basis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataGlobalLongShortAccountRatio: async (pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataGlobalLongShortAccountRatio', 'pair', pair)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataGlobalLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/globalLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataOpenInterestHist: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataOpenInterestHist', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataOpenInterestHist', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataOpenInterestHist', 'period', period)
            const localVarPath = `/futures/data/openInterestHist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataTakerBuySellVol: async (pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataTakerBuySellVol', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataTakerBuySellVol', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataTakerBuySellVol', 'period', period)
            const localVarPath = `/futures/data/takerBuySellVol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataTopLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataTopLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataTopLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataTopLongShortPositionRatio: async (pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataTopLongShortPositionRatio', 'pair', pair)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('cmfuturesGetFuturesDataTopLongShortPositionRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortPositionRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetHistoricalTradesV1: async (symbol: string, limit?: number, fromId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetHistoricalTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetIndexPriceKlinesV1: async (pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('cmfuturesGetIndexPriceKlinesV1', 'pair', pair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('cmfuturesGetIndexPriceKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/indexPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('cmfuturesGetKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetMarkPriceKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetMarkPriceKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('cmfuturesGetMarkPriceKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/markPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOpenInterestV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetOpenInterestV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/openInterest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPingV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPremiumIndexKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetPremiumIndexKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('cmfuturesGetPremiumIndexKlinesV1', 'interval', interval)
            const localVarPath = `/dapi/v1/premiumIndexKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPremiumIndexV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/premiumIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTicker24hrV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/24hr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTickerBookTickerV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/bookTicker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTickerPriceV1: async (symbol?: string, pair?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTimeV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapi/v1/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTradesV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetTradesV1', 'symbol', symbol)
            const localVarPath = `/dapi/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketDataApi - functional programming interface
 * @export
 */
export const MarketDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetAggTradesV1(symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetAggTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetAggTradesV1(symbol, fromId, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetAggTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetConstituentsV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetConstituentsV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetConstituentsV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetConstituentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetContinuousKlinesV1(pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetContinuousKlinesV1(pair, contractType, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetContinuousKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetDepthV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetDepthV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetDepthV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetDepthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetExchangeInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetExchangeInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetExchangeInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetFundingInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetFundingInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetFundingInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetFundingInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {string} symbol 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetFundingRateV1(symbol: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetFundingRateV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetFundingRateV1(symbol, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetFundingRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query basis
         * @summary Basis
         * @param {string} pair BTCUSD
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetFuturesDataBasis(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetFuturesDataBasisRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetFuturesDataBasis(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetFuturesDataBasis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetFuturesDataGlobalLongShortAccountRatio(pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetFuturesDataGlobalLongShortAccountRatio(pair, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetFuturesDataGlobalLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetFuturesDataOpenInterestHist(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetFuturesDataOpenInterestHistRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetFuturesDataOpenInterestHist(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetFuturesDataOpenInterestHist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {string} pair BTCUSD
         * @param {string} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetFuturesDataTakerBuySellVol(pair: string, contractType: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetFuturesDataTakerBuySellVolRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetFuturesDataTakerBuySellVol(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetFuturesDataTakerBuySellVol']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetFuturesDataTopLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetFuturesDataTopLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetFuturesDataTopLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetFuturesDataTopLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} pair BTCUSD
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetFuturesDataTopLongShortPositionRatio(pair: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetFuturesDataTopLongShortPositionRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetFuturesDataTopLongShortPositionRatio(pair, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetFuturesDataTopLongShortPositionRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetHistoricalTradesV1(symbol: string, limit?: number, fromId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetHistoricalTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetHistoricalTradesV1(symbol, limit, fromId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetHistoricalTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetIndexPriceKlinesV1(pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetIndexPriceKlinesV1(pair, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetIndexPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetMarkPriceKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetMarkPriceKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetMarkPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetOpenInterestV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetOpenInterestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetOpenInterestV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetOpenInterestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetPingV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetPingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetPingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetPremiumIndexKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetPremiumIndexKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetPremiumIndexKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetPremiumIndexV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetPremiumIndexV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetPremiumIndexV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetPremiumIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetTicker24hrV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetTicker24hrV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetTicker24hrV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetTicker24hrV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetTickerBookTickerV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetTickerBookTickerV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetTickerBookTickerV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetTickerBookTickerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetTickerPriceV1(symbol?: string, pair?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetTickerPriceV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetTickerPriceV1(symbol, pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetTickerPriceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetTimeV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetTimeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetTimeV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetTimeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetTradesV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetTradesV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataApi.cmfuturesGetTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketDataApi - factory interface
 * @export
 */
export const MarketDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketDataApiFp(configuration)
    return {
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {MarketDataApiCmfuturesGetAggTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetAggTradesV1(requestParameters: MarketDataApiCmfuturesGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetAggTradesV1RespItem>> {
            return localVarFp.cmfuturesGetAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {MarketDataApiCmfuturesGetConstituentsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetConstituentsV1(requestParameters: MarketDataApiCmfuturesGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetConstituentsV1Resp> {
            return localVarFp.cmfuturesGetConstituentsV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {MarketDataApiCmfuturesGetContinuousKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetContinuousKlinesV1(requestParameters: MarketDataApiCmfuturesGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.cmfuturesGetContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query orderbook on specific symbol
         * @summary Order Book
         * @param {MarketDataApiCmfuturesGetDepthV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetDepthV1(requestParameters: MarketDataApiCmfuturesGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetDepthV1Resp> {
            return localVarFp.cmfuturesGetDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetExchangeInfoV1Resp> {
            return localVarFp.cmfuturesGetExchangeInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFundingInfoV1RespItem>> {
            return localVarFp.cmfuturesGetFundingInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {MarketDataApiCmfuturesGetFundingRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFundingRateV1(requestParameters: MarketDataApiCmfuturesGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFundingRateV1RespItem>> {
            return localVarFp.cmfuturesGetFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query basis
         * @summary Basis
         * @param {MarketDataApiCmfuturesGetFuturesDataBasisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataBasis(requestParameters: MarketDataApiCmfuturesGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataBasisRespItem>> {
            return localVarFp.cmfuturesGetFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem>> {
            return localVarFp.cmfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query open interest stats
         * @summary Open Interest Statistics
         * @param {MarketDataApiCmfuturesGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataOpenInterestHist(requestParameters: MarketDataApiCmfuturesGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataOpenInterestHistRespItem>> {
            return localVarFp.cmfuturesGetFuturesDataOpenInterestHist(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         * @summary Taker Buy/Sell Volume
         * @param {MarketDataApiCmfuturesGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataTakerBuySellVol(requestParameters: MarketDataApiCmfuturesGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataTakerBuySellVolRespItem>> {
            return localVarFp.cmfuturesGetFuturesDataTakerBuySellVol(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataTopLongShortAccountRatioRespItem>> {
            return localVarFp.cmfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataTopLongShortPositionRatioRespItem>> {
            return localVarFp.cmfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {MarketDataApiCmfuturesGetHistoricalTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetHistoricalTradesV1(requestParameters: MarketDataApiCmfuturesGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetHistoricalTradesV1RespItem>> {
            return localVarFp.cmfuturesGetHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {MarketDataApiCmfuturesGetIndexPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetIndexPriceKlinesV1(requestParameters: MarketDataApiCmfuturesGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.cmfuturesGetIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {MarketDataApiCmfuturesGetKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetKlinesV1(requestParameters: MarketDataApiCmfuturesGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.cmfuturesGetKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {MarketDataApiCmfuturesGetMarkPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetMarkPriceKlinesV1(requestParameters: MarketDataApiCmfuturesGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.cmfuturesGetMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {MarketDataApiCmfuturesGetOpenInterestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOpenInterestV1(requestParameters: MarketDataApiCmfuturesGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetOpenInterestV1Resp> {
            return localVarFp.cmfuturesGetOpenInterestV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cmfuturesGetPingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {MarketDataApiCmfuturesGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPremiumIndexKlinesV1(requestParameters: MarketDataApiCmfuturesGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.cmfuturesGetPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price and mark price
         * @summary Index Price and Mark Price
         * @param {MarketDataApiCmfuturesGetPremiumIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPremiumIndexV1(requestParameters: MarketDataApiCmfuturesGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetPremiumIndexV1RespItem>> {
            return localVarFp.cmfuturesGetPremiumIndexV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics.
         * @summary 24hr Ticker Price Change Statistics
         * @param {MarketDataApiCmfuturesGetTicker24hrV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTicker24hrV1(requestParameters: MarketDataApiCmfuturesGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetTicker24hrV1RespItem>> {
            return localVarFp.cmfuturesGetTicker24hrV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {MarketDataApiCmfuturesGetTickerBookTickerV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTickerBookTickerV1(requestParameters: MarketDataApiCmfuturesGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetTickerBookTickerV1RespItem>> {
            return localVarFp.cmfuturesGetTickerBookTickerV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {MarketDataApiCmfuturesGetTickerPriceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTickerPriceV1(requestParameters: MarketDataApiCmfuturesGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetTickerPriceV1RespItem>> {
            return localVarFp.cmfuturesGetTickerPriceV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetTimeV1Resp> {
            return localVarFp.cmfuturesGetTimeV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {MarketDataApiCmfuturesGetTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetTradesV1(requestParameters: MarketDataApiCmfuturesGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetTradesV1RespItem>> {
            return localVarFp.cmfuturesGetTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketDataApi - interface
 * @export
 * @interface MarketDataApi
 */
export interface MarketDataApiInterface {
    /**
     * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {MarketDataApiCmfuturesGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetAggTradesV1(requestParameters: MarketDataApiCmfuturesGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetAggTradesV1RespItem>>;

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {MarketDataApiCmfuturesGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetConstituentsV1(requestParameters: MarketDataApiCmfuturesGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetConstituentsV1Resp>;

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {MarketDataApiCmfuturesGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetContinuousKlinesV1(requestParameters: MarketDataApiCmfuturesGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query orderbook on specific symbol
     * @summary Order Book
     * @param {MarketDataApiCmfuturesGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetDepthV1(requestParameters: MarketDataApiCmfuturesGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetDepthV1Resp>;

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetExchangeInfoV1Resp>;

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFundingInfoV1RespItem>>;

    /**
     * Get Funding Rate History of Perpetual Futures
     * @summary Get Funding Rate History of Perpetual Futures
     * @param {MarketDataApiCmfuturesGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetFundingRateV1(requestParameters: MarketDataApiCmfuturesGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFundingRateV1RespItem>>;

    /**
     * Query basis
     * @summary Basis
     * @param {MarketDataApiCmfuturesGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetFuturesDataBasis(requestParameters: MarketDataApiCmfuturesGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataBasisRespItem>>;

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem>>;

    /**
     * Query open interest stats
     * @summary Open Interest Statistics
     * @param {MarketDataApiCmfuturesGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetFuturesDataOpenInterestHist(requestParameters: MarketDataApiCmfuturesGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataOpenInterestHistRespItem>>;

    /**
     * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
     * @summary Taker Buy/Sell Volume
     * @param {MarketDataApiCmfuturesGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetFuturesDataTakerBuySellVol(requestParameters: MarketDataApiCmfuturesGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataTakerBuySellVolRespItem>>;

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataTopLongShortAccountRatioRespItem>>;

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetFuturesDataTopLongShortPositionRatioRespItem>>;

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup(MARKET_DATA)
     * @param {MarketDataApiCmfuturesGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetHistoricalTradesV1(requestParameters: MarketDataApiCmfuturesGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetHistoricalTradesV1RespItem>>;

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {MarketDataApiCmfuturesGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetIndexPriceKlinesV1(requestParameters: MarketDataApiCmfuturesGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {MarketDataApiCmfuturesGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetKlinesV1(requestParameters: MarketDataApiCmfuturesGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarketDataApiCmfuturesGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetMarkPriceKlinesV1(requestParameters: MarketDataApiCmfuturesGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {MarketDataApiCmfuturesGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetOpenInterestV1(requestParameters: MarketDataApiCmfuturesGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetOpenInterestV1Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {MarketDataApiCmfuturesGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetPremiumIndexKlinesV1(requestParameters: MarketDataApiCmfuturesGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<CmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query index price and mark price
     * @summary Index Price and Mark Price
     * @param {MarketDataApiCmfuturesGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetPremiumIndexV1(requestParameters?: MarketDataApiCmfuturesGetPremiumIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetPremiumIndexV1RespItem>>;

    /**
     * 24 hour rolling window price change statistics.
     * @summary 24hr Ticker Price Change Statistics
     * @param {MarketDataApiCmfuturesGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetTicker24hrV1(requestParameters?: MarketDataApiCmfuturesGetTicker24hrV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetTicker24hrV1RespItem>>;

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {MarketDataApiCmfuturesGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetTickerBookTickerV1(requestParameters?: MarketDataApiCmfuturesGetTickerBookTickerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetTickerBookTickerV1RespItem>>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {MarketDataApiCmfuturesGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetTickerPriceV1(requestParameters?: MarketDataApiCmfuturesGetTickerPriceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetTickerPriceV1RespItem>>;

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetTimeV1Resp>;

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {MarketDataApiCmfuturesGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApiInterface
     */
    cmfuturesGetTradesV1(requestParameters: MarketDataApiCmfuturesGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetTradesV1RespItem>>;

}

/**
 * Request parameters for cmfuturesGetAggTradesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetAggTradesV1Request
 */
export interface MarketDataApiCmfuturesGetAggTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetAggTradesV1
     */
    readonly symbol: string

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetAggTradesV1
     */
    readonly fromId?: number

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetAggTradesV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetAggTradesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetAggTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for cmfuturesGetConstituentsV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetConstituentsV1Request
 */
export interface MarketDataApiCmfuturesGetConstituentsV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetConstituentsV1
     */
    readonly symbol: string
}

/**
 * Request parameters for cmfuturesGetContinuousKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetContinuousKlinesV1Request
 */
export interface MarketDataApiCmfuturesGetContinuousKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetContinuousKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetContinuousKlinesV1
     */
    readonly contractType: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetContinuousKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetContinuousKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetContinuousKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetContinuousKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for cmfuturesGetDepthV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetDepthV1Request
 */
export interface MarketDataApiCmfuturesGetDepthV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetDepthV1
     */
    readonly symbol: string

    /**
     * Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetDepthV1
     */
    readonly limit?: number
}

/**
 * Request parameters for cmfuturesGetFundingRateV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetFundingRateV1Request
 */
export interface MarketDataApiCmfuturesGetFundingRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFundingRateV1
     */
    readonly symbol: string

    /**
     * Timestamp in ms to get funding rate from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFundingRateV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding rate  until INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFundingRateV1
     */
    readonly endTime?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFundingRateV1
     */
    readonly limit?: number
}

/**
 * Request parameters for cmfuturesGetFuturesDataBasis operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetFuturesDataBasisRequest
 */
export interface MarketDataApiCmfuturesGetFuturesDataBasisRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataBasis
     */
    readonly pair: string

    /**
     * CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataBasis
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataBasis
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataBasis
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataBasis
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataBasis
     */
    readonly endTime?: number
}

/**
 * Request parameters for cmfuturesGetFuturesDataGlobalLongShortAccountRatio operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest
 */
export interface MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly pair: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for cmfuturesGetFuturesDataOpenInterestHist operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetFuturesDataOpenInterestHistRequest
 */
export interface MarketDataApiCmfuturesGetFuturesDataOpenInterestHistRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataOpenInterestHist
     */
    readonly pair: string

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataOpenInterestHist
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataOpenInterestHist
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataOpenInterestHist
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataOpenInterestHist
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataOpenInterestHist
     */
    readonly endTime?: number
}

/**
 * Request parameters for cmfuturesGetFuturesDataTakerBuySellVol operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetFuturesDataTakerBuySellVolRequest
 */
export interface MarketDataApiCmfuturesGetFuturesDataTakerBuySellVolRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTakerBuySellVol
     */
    readonly pair: string

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTakerBuySellVol
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTakerBuySellVol
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTakerBuySellVol
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTakerBuySellVol
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTakerBuySellVol
     */
    readonly endTime?: number
}

/**
 * Request parameters for cmfuturesGetFuturesDataTopLongShortAccountRatio operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatioRequest
 */
export interface MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for cmfuturesGetFuturesDataTopLongShortPositionRatio operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatioRequest
 */
export interface MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatioRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly pair: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for cmfuturesGetHistoricalTradesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetHistoricalTradesV1Request
 */
export interface MarketDataApiCmfuturesGetHistoricalTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetHistoricalTradesV1
     */
    readonly symbol: string

    /**
     * Default 100; max 500.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetHistoricalTradesV1
     */
    readonly limit?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetHistoricalTradesV1
     */
    readonly fromId?: number
}

/**
 * Request parameters for cmfuturesGetIndexPriceKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetIndexPriceKlinesV1Request
 */
export interface MarketDataApiCmfuturesGetIndexPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetIndexPriceKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetIndexPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetIndexPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetIndexPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetIndexPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for cmfuturesGetKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetKlinesV1Request
 */
export interface MarketDataApiCmfuturesGetKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for cmfuturesGetMarkPriceKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetMarkPriceKlinesV1Request
 */
export interface MarketDataApiCmfuturesGetMarkPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetMarkPriceKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetMarkPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetMarkPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetMarkPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetMarkPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for cmfuturesGetOpenInterestV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetOpenInterestV1Request
 */
export interface MarketDataApiCmfuturesGetOpenInterestV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetOpenInterestV1
     */
    readonly symbol: string
}

/**
 * Request parameters for cmfuturesGetPremiumIndexKlinesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetPremiumIndexKlinesV1Request
 */
export interface MarketDataApiCmfuturesGetPremiumIndexKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetPremiumIndexKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetPremiumIndexKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetPremiumIndexKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetPremiumIndexKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetPremiumIndexKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for cmfuturesGetPremiumIndexV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetPremiumIndexV1Request
 */
export interface MarketDataApiCmfuturesGetPremiumIndexV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetPremiumIndexV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetPremiumIndexV1
     */
    readonly pair?: string
}

/**
 * Request parameters for cmfuturesGetTicker24hrV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetTicker24hrV1Request
 */
export interface MarketDataApiCmfuturesGetTicker24hrV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetTicker24hrV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetTicker24hrV1
     */
    readonly pair?: string
}

/**
 * Request parameters for cmfuturesGetTickerBookTickerV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetTickerBookTickerV1Request
 */
export interface MarketDataApiCmfuturesGetTickerBookTickerV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetTickerBookTickerV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetTickerBookTickerV1
     */
    readonly pair?: string
}

/**
 * Request parameters for cmfuturesGetTickerPriceV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetTickerPriceV1Request
 */
export interface MarketDataApiCmfuturesGetTickerPriceV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetTickerPriceV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetTickerPriceV1
     */
    readonly pair?: string
}

/**
 * Request parameters for cmfuturesGetTradesV1 operation in MarketDataApi.
 * @export
 * @interface MarketDataApiCmfuturesGetTradesV1Request
 */
export interface MarketDataApiCmfuturesGetTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarketDataApiCmfuturesGetTradesV1
     */
    readonly symbol: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof MarketDataApiCmfuturesGetTradesV1
     */
    readonly limit?: number
}

/**
 * MarketDataApi - object-oriented interface
 * @export
 * @class MarketDataApi
 * @extends {BaseAPI}
 */
export class MarketDataApi extends BaseAPI implements MarketDataApiInterface {
    /**
     * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {MarketDataApiCmfuturesGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetAggTradesV1(requestParameters: MarketDataApiCmfuturesGetAggTradesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {MarketDataApiCmfuturesGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetConstituentsV1(requestParameters: MarketDataApiCmfuturesGetConstituentsV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetConstituentsV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {MarketDataApiCmfuturesGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetContinuousKlinesV1(requestParameters: MarketDataApiCmfuturesGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query orderbook on specific symbol
     * @summary Order Book
     * @param {MarketDataApiCmfuturesGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetDepthV1(requestParameters: MarketDataApiCmfuturesGetDepthV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetExchangeInfoV1(options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetExchangeInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetFundingInfoV1(options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetFundingInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Funding Rate History of Perpetual Futures
     * @summary Get Funding Rate History of Perpetual Futures
     * @param {MarketDataApiCmfuturesGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetFundingRateV1(requestParameters: MarketDataApiCmfuturesGetFundingRateV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query basis
     * @summary Basis
     * @param {MarketDataApiCmfuturesGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetFuturesDataBasis(requestParameters: MarketDataApiCmfuturesGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetFuturesDataGlobalLongShortAccountRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query open interest stats
     * @summary Open Interest Statistics
     * @param {MarketDataApiCmfuturesGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetFuturesDataOpenInterestHist(requestParameters: MarketDataApiCmfuturesGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetFuturesDataOpenInterestHist(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker Sell Volume: the total volume of sell orders filled by takers within the period.
     * @summary Taker Buy/Sell Volume
     * @param {MarketDataApiCmfuturesGetFuturesDataTakerBuySellVolRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetFuturesDataTakerBuySellVol(requestParameters: MarketDataApiCmfuturesGetFuturesDataTakerBuySellVolRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetFuturesDataTakerBuySellVol(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters: MarketDataApiCmfuturesGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetFuturesDataTopLongShortPositionRatio(requestParameters.pair, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup(MARKET_DATA)
     * @param {MarketDataApiCmfuturesGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetHistoricalTradesV1(requestParameters: MarketDataApiCmfuturesGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {MarketDataApiCmfuturesGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetIndexPriceKlinesV1(requestParameters: MarketDataApiCmfuturesGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {MarketDataApiCmfuturesGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetKlinesV1(requestParameters: MarketDataApiCmfuturesGetKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarketDataApiCmfuturesGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetMarkPriceKlinesV1(requestParameters: MarketDataApiCmfuturesGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {MarketDataApiCmfuturesGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetOpenInterestV1(requestParameters: MarketDataApiCmfuturesGetOpenInterestV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetOpenInterestV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetPingV1(options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetPingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {MarketDataApiCmfuturesGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetPremiumIndexKlinesV1(requestParameters: MarketDataApiCmfuturesGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price and mark price
     * @summary Index Price and Mark Price
     * @param {MarketDataApiCmfuturesGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetPremiumIndexV1(requestParameters: MarketDataApiCmfuturesGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetPremiumIndexV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics.
     * @summary 24hr Ticker Price Change Statistics
     * @param {MarketDataApiCmfuturesGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetTicker24hrV1(requestParameters: MarketDataApiCmfuturesGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetTicker24hrV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {MarketDataApiCmfuturesGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetTickerBookTickerV1(requestParameters: MarketDataApiCmfuturesGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetTickerBookTickerV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {MarketDataApiCmfuturesGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetTickerPriceV1(requestParameters: MarketDataApiCmfuturesGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetTickerPriceV1(requestParameters.symbol, requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetTimeV1(options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetTimeV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {MarketDataApiCmfuturesGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public cmfuturesGetTradesV1(requestParameters: MarketDataApiCmfuturesGetTradesV1Request, options?: RawAxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).cmfuturesGetTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}

