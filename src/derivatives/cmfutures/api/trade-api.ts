/* tslint:disable */
/* eslint-disable */
/**
 * Binance COIN-M Futures API
 * OpenAPI specification for Binance exchange - Cmfutures API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CmfuturesCreateBatchOrderV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { CmfuturesCreateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CmfuturesCreateCountdownCancelAllV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesCreateLeverageV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesCreateMarginTypeV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesCreateOrderV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesCreatePositionMarginV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesCreatePositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesDeleteAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesDeleteBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CmfuturesDeleteOrderV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetOrderV1Resp } from '../model';
// @ts-ignore
import type { CmfuturesGetPositionMarginHistoryV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetPositionRiskV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesGetUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { CmfuturesUpdateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { CmfuturesUpdateOrderV1Resp } from '../model';
/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateBatchOrdersV1: async (batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('cmfuturesCreateBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesCreateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {number} countdownTime 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateCountdownCancelAllV1: async (countdownTime: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countdownTime' is not null or undefined
            assertParamExists('cmfuturesCreateCountdownCancelAllV1', 'countdownTime', countdownTime)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesCreateCountdownCancelAllV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesCreateCountdownCancelAllV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/countdownCancelAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (countdownTime !== undefined) { 
                localVarFormParams.set('countdownTime', countdownTime as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('cmfuturesCreateLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesCreateLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesCreateLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateMarginTypeV1: async (marginType: string, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marginType' is not null or undefined
            assertParamExists('cmfuturesCreateMarginTypeV1', 'marginType', marginType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesCreateMarginTypeV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesCreateMarginTypeV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/marginType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (marginType !== undefined) { 
                localVarFormParams.set('marginType', marginType as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateOrderV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('cmfuturesCreateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesCreateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesCreateOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('cmfuturesCreateOrderV1', 'type', type)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreatePositionMarginV1: async (amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('cmfuturesCreatePositionMarginV1', 'amount', amount)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesCreatePositionMarginV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesCreatePositionMarginV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('cmfuturesCreatePositionMarginV1', 'type', type)
            const localVarPath = `/dapi/v1/positionMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreatePositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('cmfuturesCreatePositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesCreatePositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesDeleteAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesDeleteAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesDeleteAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesDeleteBatchOrdersV1: async (symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesDeleteBatchOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesDeleteBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIdList) {
                localVarQueryParameter['orderIdList'] = orderIdList;
            }

            if (origClientOrderIdList) {
                localVarQueryParameter['origClientOrderIdList'] = origClientOrderIdList;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesDeleteOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesDeleteOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesDeleteOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetAdlQuantileV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetAdlQuantileV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetAllOrdersV1: async (timestamp: number, symbol?: string, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] 
         * @param {number} [recvWindow] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, recvWindow?: number, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOpenOrdersV1: async (timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin,2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default: 50
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPositionMarginHistoryV1: async (symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesGetPositionMarginHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetPositionMarginHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionMargin/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPositionRiskV1: async (timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetPositionRiskV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (marginAsset !== undefined) {
                localVarQueryParameter['marginAsset'] = marginAsset;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {string} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetUserTradesV1: async (timestamp: number, symbol?: string, pair?: string, orderId?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesGetUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {object} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesUpdateBatchOrdersV1: async (batchOrders: object, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('cmfuturesUpdateBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesUpdateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (batchOrders !== undefined) { 
                localVarFormParams.set('batchOrders', batchOrders as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesUpdateOrderV1: async (side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('cmfuturesUpdateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cmfuturesUpdateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('cmfuturesUpdateOrderV1', 'timestamp', timestamp)
            const localVarPath = `/dapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration)
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesCreateBatchOrdersV1(batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesCreateBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesCreateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {number} countdownTime 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesCreateCountdownCancelAllV1(countdownTime: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesCreateCountdownCancelAllV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesCreateCountdownCancelAllV1(countdownTime, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesCreateCountdownCancelAllV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesCreateLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesCreateLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesCreateLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesCreateLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesCreateMarginTypeV1(marginType: string, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesCreateMarginTypeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesCreateMarginTypeV1(marginType, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesCreateMarginTypeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesCreateOrderV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesCreateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesCreateOrderV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesCreateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesCreatePositionMarginV1(amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesCreatePositionMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesCreatePositionMarginV1(amount, symbol, timestamp, type, positionSide, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesCreatePositionMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesCreatePositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesCreatePositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesCreatePositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesCreatePositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesDeleteAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesDeleteAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesDeleteAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesDeleteAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesDeleteBatchOrdersV1(symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesDeleteBatchOrdersV1(symbol, timestamp, orderIdList, origClientOrderIdList, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesDeleteBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesDeleteOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesDeleteOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesDeleteOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesDeleteOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetAdlQuantileV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetAdlQuantileV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetAllOrdersV1(timestamp: number, symbol?: string, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetAllOrdersV1(timestamp, symbol, pair, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] 
         * @param {number} [recvWindow] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, recvWindow?: number, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetForceOrdersV1(timestamp, symbol, autoCloseType, recvWindow, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetOpenOrdersV1(timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetOpenOrdersV1(timestamp, symbol, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesGetOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin,2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default: 50
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetPositionMarginHistoryV1(symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetPositionMarginHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetPositionMarginHistoryV1(symbol, timestamp, type, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetPositionMarginHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetPositionRiskV1(timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetPositionRiskV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetPositionRiskV1(timestamp, marginAsset, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetPositionRiskV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {string} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesGetUserTradesV1(timestamp: number, symbol?: string, pair?: string, orderId?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesGetUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesGetUserTradesV1(timestamp, symbol, pair, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesGetUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {object} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesUpdateBatchOrdersV1(batchOrders: object, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesUpdateBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesUpdateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmfuturesUpdateOrderV1(side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmfuturesUpdateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmfuturesUpdateOrderV1(side, symbol, timestamp, orderId, origClientOrderId, price, priceMatch, quantity, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cmfuturesUpdateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeApiFp(configuration)
    return {
        /**
         * Place multiple orders
         * @summary Place Multiple Orders(TRADE)
         * @param {TradeApiCmfuturesCreateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateBatchOrdersV1(requestParameters: TradeApiCmfuturesCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>> {
            return localVarFp.cmfuturesCreateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {TradeApiCmfuturesCreateCountdownCancelAllV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateCountdownCancelAllV1(requestParameters: TradeApiCmfuturesCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreateCountdownCancelAllV1Resp> {
            return localVarFp.cmfuturesCreateCountdownCancelAllV1(requestParameters.countdownTime, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         * @summary Change Initial Leverage (TRADE)
         * @param {TradeApiCmfuturesCreateLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateLeverageV1(requestParameters: TradeApiCmfuturesCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreateLeverageV1Resp> {
            return localVarFp.cmfuturesCreateLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         * @summary Change Margin Type (TRADE)
         * @param {TradeApiCmfuturesCreateMarginTypeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateMarginTypeV1(requestParameters: TradeApiCmfuturesCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreateMarginTypeV1Resp> {
            return localVarFp.cmfuturesCreateMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new order.
         * @summary New Order (TRADE)
         * @param {TradeApiCmfuturesCreateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreateOrderV1(requestParameters: TradeApiCmfuturesCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreateOrderV1Resp> {
            return localVarFp.cmfuturesCreateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {TradeApiCmfuturesCreatePositionMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreatePositionMarginV1(requestParameters: TradeApiCmfuturesCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreatePositionMarginV1Resp> {
            return localVarFp.cmfuturesCreatePositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {TradeApiCmfuturesCreatePositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesCreatePositionSideDualV1(requestParameters: TradeApiCmfuturesCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreatePositionSideDualV1Resp> {
            return localVarFp.cmfuturesCreatePositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders(TRADE)
         * @param {TradeApiCmfuturesDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesDeleteAllOpenOrdersV1(requestParameters: TradeApiCmfuturesDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesDeleteAllOpenOrdersV1Resp> {
            return localVarFp.cmfuturesDeleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders(TRADE)
         * @param {TradeApiCmfuturesDeleteBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesDeleteBatchOrdersV1(requestParameters: TradeApiCmfuturesDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>> {
            return localVarFp.cmfuturesDeleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {TradeApiCmfuturesDeleteOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesDeleteOrderV1(requestParameters: TradeApiCmfuturesDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesDeleteOrderV1Resp> {
            return localVarFp.cmfuturesDeleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query position ADL quantile estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {TradeApiCmfuturesGetAdlQuantileV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetAdlQuantileV1(requestParameters: TradeApiCmfuturesGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetAdlQuantileV1RespItem>> {
            return localVarFp.cmfuturesGetAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {TradeApiCmfuturesGetAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetAllOrdersV1(requestParameters: TradeApiCmfuturesGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetAllOrdersV1RespItem>> {
            return localVarFp.cmfuturesGetAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * User\'s Force Orders
         * @summary User\'s Force Orders(USER_DATA)
         * @param {TradeApiCmfuturesGetForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetForceOrdersV1(requestParameters: TradeApiCmfuturesGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>> {
            return localVarFp.cmfuturesGetForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.recvWindow, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current Open Order
         * @summary Query Current Open Order(USER_DATA)
         * @param {TradeApiCmfuturesGetOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOpenOrderV1(requestParameters: TradeApiCmfuturesGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetOpenOrderV1Resp> {
            return localVarFp.cmfuturesGetOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {TradeApiCmfuturesGetOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOpenOrdersV1(requestParameters: TradeApiCmfuturesGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetOpenOrdersV1RespItem>> {
            return localVarFp.cmfuturesGetOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {TradeApiCmfuturesGetOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOrderAmendmentV1(requestParameters: TradeApiCmfuturesGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetOrderAmendmentV1RespItem>> {
            return localVarFp.cmfuturesGetOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {TradeApiCmfuturesGetOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetOrderV1(requestParameters: TradeApiCmfuturesGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetOrderV1Resp> {
            return localVarFp.cmfuturesGetOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get position margin change history
         * @summary Get Position Margin Change History(TRADE)
         * @param {TradeApiCmfuturesGetPositionMarginHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPositionMarginHistoryV1(requestParameters: TradeApiCmfuturesGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetPositionMarginHistoryV1RespItem>> {
            return localVarFp.cmfuturesGetPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information.
         * @summary Position Information(USER_DATA)
         * @param {TradeApiCmfuturesGetPositionRiskV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetPositionRiskV1(requestParameters: TradeApiCmfuturesGetPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetPositionRiskV1RespItem>> {
            return localVarFp.cmfuturesGetPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {TradeApiCmfuturesGetUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesGetUserTradesV1(requestParameters: TradeApiCmfuturesGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetUserTradesV1RespItem>> {
            return localVarFp.cmfuturesGetUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Multiple Orders
         * @summary Modify Multiple Orders(TRADE)
         * @param {TradeApiCmfuturesUpdateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesUpdateBatchOrdersV1(requestParameters: TradeApiCmfuturesUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>> {
            return localVarFp.cmfuturesUpdateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {TradeApiCmfuturesUpdateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmfuturesUpdateOrderV1(requestParameters: TradeApiCmfuturesUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesUpdateOrderV1Resp> {
            return localVarFp.cmfuturesUpdateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeApi - interface
 * @export
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Place multiple orders
     * @summary Place Multiple Orders(TRADE)
     * @param {TradeApiCmfuturesCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesCreateBatchOrdersV1(requestParameters: TradeApiCmfuturesCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesCreateBatchOrdersV1RespInner>>;

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {TradeApiCmfuturesCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesCreateCountdownCancelAllV1(requestParameters: TradeApiCmfuturesCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreateCountdownCancelAllV1Resp>;

    /**
     * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
     * @summary Change Initial Leverage (TRADE)
     * @param {TradeApiCmfuturesCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesCreateLeverageV1(requestParameters: TradeApiCmfuturesCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreateLeverageV1Resp>;

    /**
     * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
     * @summary Change Margin Type (TRADE)
     * @param {TradeApiCmfuturesCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesCreateMarginTypeV1(requestParameters: TradeApiCmfuturesCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreateMarginTypeV1Resp>;

    /**
     * Send in a new order.
     * @summary New Order (TRADE)
     * @param {TradeApiCmfuturesCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesCreateOrderV1(requestParameters: TradeApiCmfuturesCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreateOrderV1Resp>;

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {TradeApiCmfuturesCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesCreatePositionMarginV1(requestParameters: TradeApiCmfuturesCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreatePositionMarginV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {TradeApiCmfuturesCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesCreatePositionSideDualV1(requestParameters: TradeApiCmfuturesCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesCreatePositionSideDualV1Resp>;

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders(TRADE)
     * @param {TradeApiCmfuturesDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesDeleteAllOpenOrdersV1(requestParameters: TradeApiCmfuturesDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesDeleteAllOpenOrdersV1Resp>;

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders(TRADE)
     * @param {TradeApiCmfuturesDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesDeleteBatchOrdersV1(requestParameters: TradeApiCmfuturesDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesDeleteBatchOrdersV1RespInner>>;

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {TradeApiCmfuturesDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesDeleteOrderV1(requestParameters: TradeApiCmfuturesDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesDeleteOrderV1Resp>;

    /**
     * Query position ADL quantile estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {TradeApiCmfuturesGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetAdlQuantileV1(requestParameters: TradeApiCmfuturesGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetAdlQuantileV1RespItem>>;

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {TradeApiCmfuturesGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetAllOrdersV1(requestParameters: TradeApiCmfuturesGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetAllOrdersV1RespItem>>;

    /**
     * User\'s Force Orders
     * @summary User\'s Force Orders(USER_DATA)
     * @param {TradeApiCmfuturesGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetForceOrdersV1(requestParameters: TradeApiCmfuturesGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetForceOrdersV1RespItem>>;

    /**
     * Query Current Open Order
     * @summary Query Current Open Order(USER_DATA)
     * @param {TradeApiCmfuturesGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetOpenOrderV1(requestParameters: TradeApiCmfuturesGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {TradeApiCmfuturesGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetOpenOrdersV1(requestParameters: TradeApiCmfuturesGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {TradeApiCmfuturesGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetOrderAmendmentV1(requestParameters: TradeApiCmfuturesGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetOrderAmendmentV1RespItem>>;

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {TradeApiCmfuturesGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetOrderV1(requestParameters: TradeApiCmfuturesGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesGetOrderV1Resp>;

    /**
     * Get position margin change history
     * @summary Get Position Margin Change History(TRADE)
     * @param {TradeApiCmfuturesGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetPositionMarginHistoryV1(requestParameters: TradeApiCmfuturesGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetPositionMarginHistoryV1RespItem>>;

    /**
     * Get current account information.
     * @summary Position Information(USER_DATA)
     * @param {TradeApiCmfuturesGetPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetPositionRiskV1(requestParameters: TradeApiCmfuturesGetPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetPositionRiskV1RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {TradeApiCmfuturesGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesGetUserTradesV1(requestParameters: TradeApiCmfuturesGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesGetUserTradesV1RespItem>>;

    /**
     * Modify Multiple Orders
     * @summary Modify Multiple Orders(TRADE)
     * @param {TradeApiCmfuturesUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesUpdateBatchOrdersV1(requestParameters: TradeApiCmfuturesUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<CmfuturesUpdateBatchOrdersV1RespInner>>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {TradeApiCmfuturesUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApiInterface
     */
    cmfuturesUpdateOrderV1(requestParameters: TradeApiCmfuturesUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CmfuturesUpdateOrderV1Resp>;

}

/**
 * Request parameters for cmfuturesCreateBatchOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesCreateBatchOrdersV1Request
 */
export interface TradeApiCmfuturesCreateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>}
     * @memberof TradeApiCmfuturesCreateBatchOrdersV1
     */
    readonly batchOrders: Array<CmfuturesCreateBatchOrderV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesCreateCountdownCancelAllV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesCreateCountdownCancelAllV1Request
 */
export interface TradeApiCmfuturesCreateCountdownCancelAllV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateCountdownCancelAllV1
     */
    readonly countdownTime: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateCountdownCancelAllV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateCountdownCancelAllV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateCountdownCancelAllV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesCreateLeverageV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesCreateLeverageV1Request
 */
export interface TradeApiCmfuturesCreateLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesCreateMarginTypeV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesCreateMarginTypeV1Request
 */
export interface TradeApiCmfuturesCreateMarginTypeV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateMarginTypeV1
     */
    readonly marginType: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateMarginTypeV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateMarginTypeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateMarginTypeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesCreateOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesCreateOrderV1Request
 */
export interface TradeApiCmfuturesCreateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreateOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for cmfuturesCreatePositionMarginV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesCreatePositionMarginV1Request
 */
export interface TradeApiCmfuturesCreatePositionMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreatePositionMarginV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreatePositionMarginV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreatePositionMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreatePositionMarginV1
     */
    readonly type: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreatePositionMarginV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreatePositionMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesCreatePositionSideDualV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesCreatePositionSideDualV1Request
 */
export interface TradeApiCmfuturesCreatePositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesCreatePositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreatePositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesCreatePositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesDeleteAllOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesDeleteAllOpenOrdersV1Request
 */
export interface TradeApiCmfuturesDeleteAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesDeleteAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesDeleteAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesDeleteAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesDeleteBatchOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesDeleteBatchOrdersV1Request
 */
export interface TradeApiCmfuturesDeleteBatchOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesDeleteBatchOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesDeleteBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * max length 10 &lt;br/&gt; e.g. [1234567,2345678]
     * @type {Array<number>}
     * @memberof TradeApiCmfuturesDeleteBatchOrdersV1
     */
    readonly orderIdList?: Array<number>

    /**
     * max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
     * @type {Array<string>}
     * @memberof TradeApiCmfuturesDeleteBatchOrdersV1
     */
    readonly origClientOrderIdList?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesDeleteBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesDeleteOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesDeleteOrderV1Request
 */
export interface TradeApiCmfuturesDeleteOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesDeleteOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesDeleteOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesDeleteOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesDeleteOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesDeleteOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetAdlQuantileV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetAdlQuantileV1Request
 */
export interface TradeApiCmfuturesGetAdlQuantileV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetAdlQuantileV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetAdlQuantileV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetAdlQuantileV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetAllOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetAllOrdersV1Request
 */
export interface TradeApiCmfuturesGetAllOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetAllOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetAllOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof TradeApiCmfuturesGetAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetForceOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetForceOrdersV1Request
 */
export interface TradeApiCmfuturesGetForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetForceOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetForceOrdersV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetForceOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetForceOrdersV1
     */
    readonly endTime?: number
}

/**
 * Request parameters for cmfuturesGetOpenOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetOpenOrderV1Request
 */
export interface TradeApiCmfuturesGetOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetOpenOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetOpenOrdersV1Request
 */
export interface TradeApiCmfuturesGetOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetOpenOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetOrderAmendmentV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetOrderAmendmentV1Request
 */
export interface TradeApiCmfuturesGetOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetOrderV1Request
 */
export interface TradeApiCmfuturesGetOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetPositionMarginHistoryV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetPositionMarginHistoryV1Request
 */
export interface TradeApiCmfuturesGetPositionMarginHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetPositionMarginHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetPositionMarginHistoryV1
     */
    readonly timestamp: number

    /**
     * 1: Add position margin,2: Reduce position margin
     * @type {number}
     * @memberof TradeApiCmfuturesGetPositionMarginHistoryV1
     */
    readonly type?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetPositionMarginHistoryV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetPositionMarginHistoryV1
     */
    readonly endTime?: number

    /**
     * Default: 50
     * @type {number}
     * @memberof TradeApiCmfuturesGetPositionMarginHistoryV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetPositionMarginHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetPositionRiskV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetPositionRiskV1Request
 */
export interface TradeApiCmfuturesGetPositionRiskV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetPositionRiskV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetPositionRiskV1
     */
    readonly marginAsset?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetPositionRiskV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetPositionRiskV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesGetUserTradesV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesGetUserTradesV1Request
 */
export interface TradeApiCmfuturesGetUserTradesV1Request {
    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly pair?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly orderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 50; max 1000
     * @type {number}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesGetUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesUpdateBatchOrdersV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesUpdateBatchOrdersV1Request
 */
export interface TradeApiCmfuturesUpdateBatchOrdersV1Request {
    /**
     * 
     * @type {object}
     * @memberof TradeApiCmfuturesUpdateBatchOrdersV1
     */
    readonly batchOrders: object

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesUpdateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesUpdateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for cmfuturesUpdateOrderV1 operation in TradeApi.
 * @export
 * @interface TradeApiCmfuturesUpdateOrderV1Request
 */
export interface TradeApiCmfuturesUpdateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof TradeApiCmfuturesUpdateOrderV1
     */
    readonly recvWindow?: number
}

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI implements TradeApiInterface {
    /**
     * Place multiple orders
     * @summary Place Multiple Orders(TRADE)
     * @param {TradeApiCmfuturesCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesCreateBatchOrdersV1(requestParameters: TradeApiCmfuturesCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesCreateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {TradeApiCmfuturesCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesCreateCountdownCancelAllV1(requestParameters: TradeApiCmfuturesCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesCreateCountdownCancelAllV1(requestParameters.countdownTime, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage in the specific symbol market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
     * @summary Change Initial Leverage (TRADE)
     * @param {TradeApiCmfuturesCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesCreateLeverageV1(requestParameters: TradeApiCmfuturesCreateLeverageV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesCreateLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
     * @summary Change Margin Type (TRADE)
     * @param {TradeApiCmfuturesCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesCreateMarginTypeV1(requestParameters: TradeApiCmfuturesCreateMarginTypeV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesCreateMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new order.
     * @summary New Order (TRADE)
     * @param {TradeApiCmfuturesCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesCreateOrderV1(requestParameters: TradeApiCmfuturesCreateOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesCreateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {TradeApiCmfuturesCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesCreatePositionMarginV1(requestParameters: TradeApiCmfuturesCreatePositionMarginV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesCreatePositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {TradeApiCmfuturesCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesCreatePositionSideDualV1(requestParameters: TradeApiCmfuturesCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesCreatePositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders(TRADE)
     * @param {TradeApiCmfuturesDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesDeleteAllOpenOrdersV1(requestParameters: TradeApiCmfuturesDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesDeleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders(TRADE)
     * @param {TradeApiCmfuturesDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesDeleteBatchOrdersV1(requestParameters: TradeApiCmfuturesDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesDeleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {TradeApiCmfuturesDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesDeleteOrderV1(requestParameters: TradeApiCmfuturesDeleteOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesDeleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query position ADL quantile estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {TradeApiCmfuturesGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetAdlQuantileV1(requestParameters: TradeApiCmfuturesGetAdlQuantileV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {TradeApiCmfuturesGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetAllOrdersV1(requestParameters: TradeApiCmfuturesGetAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User\'s Force Orders
     * @summary User\'s Force Orders(USER_DATA)
     * @param {TradeApiCmfuturesGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetForceOrdersV1(requestParameters: TradeApiCmfuturesGetForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.recvWindow, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current Open Order
     * @summary Query Current Open Order(USER_DATA)
     * @param {TradeApiCmfuturesGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetOpenOrderV1(requestParameters: TradeApiCmfuturesGetOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {TradeApiCmfuturesGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetOpenOrdersV1(requestParameters: TradeApiCmfuturesGetOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {TradeApiCmfuturesGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetOrderAmendmentV1(requestParameters: TradeApiCmfuturesGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {TradeApiCmfuturesGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetOrderV1(requestParameters: TradeApiCmfuturesGetOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get position margin change history
     * @summary Get Position Margin Change History(TRADE)
     * @param {TradeApiCmfuturesGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetPositionMarginHistoryV1(requestParameters: TradeApiCmfuturesGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information.
     * @summary Position Information(USER_DATA)
     * @param {TradeApiCmfuturesGetPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetPositionRiskV1(requestParameters: TradeApiCmfuturesGetPositionRiskV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {TradeApiCmfuturesGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesGetUserTradesV1(requestParameters: TradeApiCmfuturesGetUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesGetUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Multiple Orders
     * @summary Modify Multiple Orders(TRADE)
     * @param {TradeApiCmfuturesUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesUpdateBatchOrdersV1(requestParameters: TradeApiCmfuturesUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesUpdateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {TradeApiCmfuturesUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cmfuturesUpdateOrderV1(requestParameters: TradeApiCmfuturesUpdateOrderV1Request, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cmfuturesUpdateOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

