/* tslint:disable */
/* eslint-disable */
/**
 * Binance Portfolio Margin API
 * OpenAPI specification for Binance exchange - Pmargin API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CreateAssetCollectionV1Resp } from '../model';
// @ts-ignore
import type { CreateAutoCollectionV1Resp } from '../model';
// @ts-ignore
import type { CreateBnbTransferV1Resp } from '../model';
// @ts-ignore
import type { CreateCmConditionalOrderV1Resp } from '../model';
// @ts-ignore
import type { CreateCmLeverageV1Resp } from '../model';
// @ts-ignore
import type { CreateCmOrderV1Resp } from '../model';
// @ts-ignore
import type { CreateCmPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { CreateListenKeyV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginLoanV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginOrderOcoV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginRepayDebtV1Resp } from '../model';
// @ts-ignore
import type { CreateRepayFuturesNegativeBalanceV1Resp } from '../model';
// @ts-ignore
import type { CreateRepayFuturesSwitchV1Resp } from '../model';
// @ts-ignore
import type { CreateRepayLoanV1Resp } from '../model';
// @ts-ignore
import type { CreateUmConditionalOrderV1Resp } from '../model';
// @ts-ignore
import type { CreateUmFeeBurnV1Resp } from '../model';
// @ts-ignore
import type { CreateUmLeverageV1Resp } from '../model';
// @ts-ignore
import type { CreateUmOrderV1Resp } from '../model';
// @ts-ignore
import type { CreateUmPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { DeleteCmAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteCmConditionalAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteCmConditionalOrderV1Resp } from '../model';
// @ts-ignore
import type { DeleteCmOrderV1Resp } from '../model';
// @ts-ignore
import type { DeleteMarginOrderListV1Resp } from '../model';
// @ts-ignore
import type { DeleteMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { DeleteUmAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteUmConditionalAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteUmConditionalOrderV1Resp } from '../model';
// @ts-ignore
import type { DeleteUmOrderV1Resp } from '../model';
// @ts-ignore
import type { GetAccountV1Resp } from '../model';
// @ts-ignore
import type { GetCmAccountV1Resp } from '../model';
// @ts-ignore
import type { GetCmAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { GetCmAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetCmCommissionRateV1Resp } from '../model';
// @ts-ignore
import type { GetCmConditionalAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetCmConditionalOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { GetCmConditionalOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetCmConditionalOrderHistoryV1Resp } from '../model';
// @ts-ignore
import type { GetCmForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetCmIncomeV1RespItem } from '../model';
// @ts-ignore
import type { GetCmLeverageBracketV1RespItem } from '../model';
// @ts-ignore
import type { GetCmOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { GetCmOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetCmOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { GetCmOrderV1Resp } from '../model';
// @ts-ignore
import type { GetCmPositionRiskV1RespItem } from '../model';
// @ts-ignore
import type { GetCmPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { GetCmUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginAllOrderListV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginForceOrdersV1Resp } from '../model';
// @ts-ignore
import type { GetMarginMarginInterestHistoryV1Resp } from '../model';
// @ts-ignore
import type { GetMarginMarginLoanV1Resp } from '../model';
// @ts-ignore
import type { GetMarginMaxBorrowableV1Resp } from '../model';
// @ts-ignore
import type { GetMarginMaxWithdrawV1Resp } from '../model';
// @ts-ignore
import type { GetMarginMyTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginOpenOrderListV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginOrderListV1Resp } from '../model';
// @ts-ignore
import type { GetMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { GetMarginRepayLoanV1Resp } from '../model';
// @ts-ignore
import type { GetPortfolioInterestHistoryV1RespItem } from '../model';
// @ts-ignore
import type { GetPortfolioNegativeBalanceExchangeRecordV1Resp } from '../model';
// @ts-ignore
import type { GetRateLimitOrderV1RespItem } from '../model';
// @ts-ignore
import type { GetRepayFuturesSwitchV1Resp } from '../model';
// @ts-ignore
import type { GetUmAccountConfigV1Resp } from '../model';
// @ts-ignore
import type { GetUmAccountV1Resp } from '../model';
// @ts-ignore
import type { GetUmAccountV2Resp } from '../model';
// @ts-ignore
import type { GetUmAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { GetUmAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetUmApiTradingStatusV1Resp } from '../model';
// @ts-ignore
import type { GetUmCommissionRateV1Resp } from '../model';
// @ts-ignore
import type { GetUmConditionalAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetUmConditionalOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { GetUmConditionalOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetUmConditionalOrderHistoryV1Resp } from '../model';
// @ts-ignore
import type { GetUmFeeBurnV1Resp } from '../model';
// @ts-ignore
import type { GetUmForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetUmIncomeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetUmIncomeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetUmIncomeV1RespItem } from '../model';
// @ts-ignore
import type { GetUmLeverageBracketV1RespItem } from '../model';
// @ts-ignore
import type { GetUmOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { GetUmOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetUmOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { GetUmOrderAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetUmOrderAsynV1Resp } from '../model';
// @ts-ignore
import type { GetUmOrderV1Resp } from '../model';
// @ts-ignore
import type { GetUmPositionRiskV1RespItem } from '../model';
// @ts-ignore
import type { GetUmPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { GetUmSymbolConfigV1RespItem } from '../model';
// @ts-ignore
import type { GetUmTradeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetUmTradeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetUmUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { PmarginDeleteMarginAllOpenOrdersV1RespInner } from '../model';
// @ts-ignore
import type { PmarginGetBalanceV1Resp } from '../model';
// @ts-ignore
import type { UpdateCmOrderV1Resp } from '../model';
// @ts-ignore
import type { UpdateUmOrderV1Resp } from '../model';
/**
 * PortfolioMarginApi - axios parameter creator
 * @export
 */
export const PortfolioMarginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transfers specific asset from Futures Account to Margin account
         * @summary Fund Collection by Asset(TRADE)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetCollectionV1: async (asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('createAssetCollectionV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createAssetCollectionV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/asset-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fund collection for Portfolio Margin
         * @summary Fund Auto-collection(TRADE)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoCollectionV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createAutoCollectionV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/auto-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer BNB in and out of UM
         * @summary BNB transfer (TRADE)
         * @param {string} amount 
         * @param {number} timestamp 
         * @param {string} transferSide 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBnbTransferV1: async (amount: string, timestamp: number, transferSide: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createBnbTransferV1', 'amount', amount)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createBnbTransferV1', 'timestamp', timestamp)
            // verify required parameter 'transferSide' is not null or undefined
            assertParamExists('createBnbTransferV1', 'transferSide', transferSide)
            const localVarPath = `/papi/v1/bnb-transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (transferSide !== undefined) { 
                localVarFormParams.set('transferSide', transferSide as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * New CM Conditional Order
         * @summary New CM Conditional Order(TRADE)
         * @param {string} side 
         * @param {string} strategyType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [newClientStrategyId] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmConditionalOrderV1: async (side: string, strategyType: string, symbol: string, timestamp: number, activationPrice?: string, callbackRate?: string, newClientStrategyId?: string, positionSide?: string, price?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createCmConditionalOrderV1', 'side', side)
            // verify required parameter 'strategyType' is not null or undefined
            assertParamExists('createCmConditionalOrderV1', 'strategyType', strategyType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createCmConditionalOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCmConditionalOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (newClientStrategyId !== undefined) { 
                localVarFormParams.set('newClientStrategyId', newClientStrategyId as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage of specific symbol in CM.
         * @summary Change CM Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('createCmLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createCmLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCmLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place new CM order
         * @summary New CM Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmOrderV1: async (side: string, symbol: string, timestamp: number, type: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createCmOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createCmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCmOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createCmOrderV1', 'type', type)
            const localVarPath = `/papi/v1/cm/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Change CM Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmPositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('createCmPositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createCmPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply for a margin loan.
         * @summary Margin Account Borrow(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginLoanV1: async (amount: string, asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createMarginLoanV1', 'amount', amount)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('createMarginLoanV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginLoanV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/marginLoan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderOcoV1: async (price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, limitClientOrderId?: string, limitIcebergQty?: string, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, sideEffectType?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'side', side)
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'stopPrice', stopPrice)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/order/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (limitClientOrderId !== undefined) { 
                localVarFormParams.set('limitClientOrderId', limitClientOrderId as any);
            }
    
            if (limitIcebergQty !== undefined) { 
                localVarFormParams.set('limitIcebergQty', limitIcebergQty as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (sideEffectType !== undefined) { 
                localVarFormParams.set('sideEffectType', sideEffectType as any);
            }
    
            if (stopClientOrderId !== undefined) { 
                localVarFormParams.set('stopClientOrderId', stopClientOrderId as any);
            }
    
            if (stopIcebergQty !== undefined) { 
                localVarFormParams.set('stopIcebergQty', stopIcebergQty as any);
            }
    
            if (stopLimitPrice !== undefined) { 
                localVarFormParams.set('stopLimitPrice', stopLimitPrice as any);
            }
    
            if (stopLimitTimeInForce !== undefined) { 
                localVarFormParams.set('stopLimitTimeInForce', stopLimitTimeInForce as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * New Margin Order
         * @summary New Margin Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderV1: async (side: string, symbol: string, timestamp: number, type: string, autoRepayAtCancel?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, sideEffectType?: string, stopPrice?: string, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createMarginOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createMarginOrderV1', 'type', type)
            const localVarPath = `/papi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (autoRepayAtCancel !== undefined) { 
                localVarFormParams.set('autoRepayAtCancel', autoRepayAtCancel as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (sideEffectType !== undefined) { 
                localVarFormParams.set('sideEffectType', sideEffectType as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Repay debt for a margin loan.
         * @summary Margin Account Repay Debt(TRADE)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {string} [amount] 
         * @param {number} [recvWindow] 
         * @param {string} [specifyRepayAssets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginRepayDebtV1: async (asset: string, timestamp: number, amount?: string, recvWindow?: number, specifyRepayAssets?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('createMarginRepayDebtV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginRepayDebtV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/repay-debt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (specifyRepayAssets !== undefined) { 
                localVarFormParams.set('specifyRepayAssets', specifyRepayAssets as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Repay futures Negative Balance
         * @summary Repay futures Negative Balance(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepayFuturesNegativeBalanceV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createRepayFuturesNegativeBalanceV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/repay-futures-negative-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change Auto-repay-futures Status
         * @summary Change Auto-repay-futures Status(TRADE)
         * @param {string} autoRepay 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepayFuturesSwitchV1: async (autoRepay: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoRepay' is not null or undefined
            assertParamExists('createRepayFuturesSwitchV1', 'autoRepay', autoRepay)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createRepayFuturesSwitchV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/repay-futures-switch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (autoRepay !== undefined) { 
                localVarFormParams.set('autoRepay', autoRepay as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Repay for a margin loan.
         * @summary Margin Account Repay(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepayLoanV1: async (amount: string, asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createRepayLoanV1', 'amount', amount)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('createRepayLoanV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createRepayLoanV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/repayLoan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place new UM conditional order
         * @summary New UM Conditional Order (TRADE)
         * @param {string} side 
         * @param {string} strategyType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientStrategyId] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmConditionalOrderV1: async (side: string, strategyType: string, symbol: string, timestamp: number, activationPrice?: string, callbackRate?: string, goodTillDate?: number, newClientStrategyId?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createUmConditionalOrderV1', 'side', side)
            // verify required parameter 'strategyType' is not null or undefined
            assertParamExists('createUmConditionalOrderV1', 'strategyType', strategyType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createUmConditionalOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createUmConditionalOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientStrategyId !== undefined) { 
                localVarFormParams.set('newClientStrategyId', newClientStrategyId as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
         * @param {string} feeBurn 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmFeeBurnV1: async (feeBurn: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feeBurn' is not null or undefined
            assertParamExists('createUmFeeBurnV1', 'feeBurn', feeBurn)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createUmFeeBurnV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/feeBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (feeBurn !== undefined) { 
                localVarFormParams.set('feeBurn', feeBurn as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage of specific symbol in UM.
         * @summary Change UM Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('createUmLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createUmLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createUmLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place new UM order
         * @summary New UM Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmOrderV1: async (side: string, symbol: string, timestamp: number, type: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createUmOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createUmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createUmOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createUmOrderV1', 'type', type)
            const localVarPath = `/papi/v1/um/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Change UM Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmPositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('createUmPositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createUmPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All CM Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteCmAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteCmAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All CM Open Conditional Orders
         * @summary Cancel All CM Open Conditional Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmConditionalAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteCmConditionalAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteCmConditionalAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel CM Conditional Order
         * @summary Cancel CM Conditional Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmConditionalOrderV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteCmConditionalOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteCmConditionalOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active LIMIT order
         * @summary Cancel CM Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteCmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteCmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Margin Account All Open Orders on a Symbol
         * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteMarginAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMarginAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Margin Account OCO Orders
         * @summary Cancel Margin Account OCO Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOrderListV1: async (symbol: string, timestamp: number, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteMarginOrderListV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMarginOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (listClientOrderId !== undefined) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Margin Account Order
         * @summary Cancel Margin Account Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMarginOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All UM Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUmAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteUmAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteUmAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All UM Open Conditional Orders
         * @summary Cancel All UM Open Conditional Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUmConditionalAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteUmConditionalAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteUmConditionalAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel UM Conditional Order
         * @summary Cancel UM Conditional Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUmConditionalOrderV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteUmConditionalOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteUmConditionalOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active UM LIMIT order
         * @summary Cancel UM Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUmOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteUmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteUmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account information
         * @summary Account Information(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account balance
         * @summary Account Balance(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV1: async (timestamp: number, asset?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBalanceV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current CM account asset and position information.
         * @summary Get CM Account Detail(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmAccountV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query CM Position ADL Quantile Estimation
         * @summary CM Position ADL Quantile Estimation(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmAdlQuantileV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/cm/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account CM orders; active, canceled, or filled.
         * @summary Query All CM Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmAllOrdersV1: async (symbol: string, timestamp: number, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCmAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Commission Rate for CM
         * @summary Get User Commission Rate for CM(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmCommissionRateV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCmCommissionRateV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmCommissionRateV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/commissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query All CM Conditional Orders
         * @summary Query All CM Conditional Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [strategyId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmConditionalAllOrdersV1: async (timestamp: number, symbol?: string, strategyId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmConditionalAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current CM Open Conditional Order
         * @summary Query Current CM Open Conditional Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmConditionalOpenOrderV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCmConditionalOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmConditionalOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
         * @summary Query All Current CM Open Conditional Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmConditionalOpenOrdersV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmConditionalOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query CM Conditional Order History
         * @summary Query CM Conditional Order History(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmConditionalOrderHistoryV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCmConditionalOrderHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmConditionalOrderHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/conditional/orderHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User\'s CM Force Orders
         * @summary Query User\'s CM Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CM Income History
         * @summary Get CM Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmIncomeV1: async (timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmIncomeV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/income`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (incomeType !== undefined) {
                localVarQueryParameter['incomeType'] = incomeType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query CM notional and leverage brackets
         * @summary CM Notional and Leverage Brackets(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmLeverageBracketV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmLeverageBracketV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query current CM open order
         * @summary Query Current CM Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCmOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current CM Open Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmOpenOrdersV1: async (timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Query CM Modify Order History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50, max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCmOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an CM order\'s status.
         * @summary Query CM Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current CM position information.
         * @summary Query CM Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmPositionRiskV1: async (timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmPositionRiskV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (marginAsset !== undefined) {
                localVarQueryParameter['marginAsset'] = marginAsset;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Get CM Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmPositionSideDualV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and CM symbol.
         * @summary CM Account Trade List(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmUserTradesV1: async (timestamp: number, symbol?: string, pair?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCmUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [fromId] If supplied, neither startTime or endTime can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllOrderListV1: async (timestamp: number, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginAllOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/allOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query All Margin Account Orders
         * @summary Query All Margin Account Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user\'s margin force orders
         * @summary Query User\'s Margin Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginForceOrdersV1: async (timestamp: number, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Margin Borrow/Loan Interest History
         * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMarginInterestHistoryV1: async (timestamp: number, asset?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginMarginInterestHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/marginInterestHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query margin loan record
         * @summary Query Margin Loan Record(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [txId] the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMarginLoanV1: async (asset: string, timestamp: number, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getMarginMarginLoanV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginMarginLoanV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/marginLoan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (txId !== undefined) {
                localVarQueryParameter['txId'] = txId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query margin max borrow
         * @summary Margin Max Borrow(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMaxBorrowableV1: async (asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getMarginMaxBorrowableV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginMaxBorrowableV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/maxBorrowable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Max Withdraw
         * @summary Query Margin Max Withdraw(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMaxWithdrawV1: async (asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getMarginMaxWithdrawV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginMaxWithdrawV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/maxWithdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Margin Account Trade List
         * @summary Margin Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMyTradesV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginMyTradesV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginMyTradesV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/myTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOpenOrderListV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginOpenOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/openOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current Margin Open Order
         * @summary Query Current Margin Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [orderListId] Either orderListId or origClientOrderId must be provided
         * @param {string} [origClientOrderId] Either orderListId or origClientOrderId must be provided
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOrderListV1: async (timestamp: number, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account Order
         * @summary Query Margin Account Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query margin repay record.
         * @summary Query Margin repay Record(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [txId] the tranId in &#x60;POST/papi/v1/repayLoan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginRepayLoanV1: async (asset: string, timestamp: number, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getMarginRepayLoanV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginRepayLoanV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/margin/repayLoan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (txId !== undefined) {
                localVarQueryParameter['txId'] = txId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query interest history of negative balance for portfolio margin.
         * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioInterestHistoryV1: async (timestamp: number, asset?: string, startTime?: number, endTime?: number, size?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPortfolioInterestHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/portfolio/interest-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user negative balance auto exchange record
         * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
         * @param {number} startTime 
         * @param {number} endTime 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioNegativeBalanceExchangeRecordV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getPortfolioNegativeBalanceExchangeRecordV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getPortfolioNegativeBalanceExchangeRecordV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPortfolioNegativeBalanceExchangeRecordV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/portfolio/negative-balance-exchange-record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimitOrderV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getRateLimitOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/rateLimit/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Auto-repay-futures Status
         * @summary Get Auto-repay-futures Status(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepayFuturesSwitchV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getRepayFuturesSwitchV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/repay-futures-switch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query UM Futures account configuration
         * @summary UM Futures Account Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAccountConfigV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmAccountConfigV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/accountConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmAccountV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail V2(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAccountV2: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmAccountV2', 'timestamp', timestamp)
            const localVarPath = `/papi/v2/um/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query UM Position ADL Quantile Estimation
         * @summary UM Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAdlQuantileV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmAdlQuantileV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account UM orders; active, canceled, or filled.
         * @summary Query All UM Orders(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAllOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUmAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Portfolio Margin UM Trading Quantitative Rules Indicators
         * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmApiTradingStatusV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmApiTradingStatusV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/apiTradingStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Commission Rate for UM
         * @summary Get User Commission Rate for UM(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmCommissionRateV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUmCommissionRateV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmCommissionRateV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/commissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query All UM Conditional Orders
         * @summary Query All UM Conditional Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [strategyId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmConditionalAllOrdersV1: async (timestamp: number, symbol?: string, strategyId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmConditionalAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Current UM Open Conditional Order
         * @summary Query Current UM Open Conditional Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmConditionalOpenOrderV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUmConditionalOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmConditionalOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open conditional orders on a symbol.
         * @summary Query All Current UM Open Conditional Orders(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmConditionalOpenOrdersV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/um/conditional/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query UM Conditional Order History
         * @summary Query UM Conditional Order History(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmConditionalOrderHistoryV1: async (symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUmConditionalOrderHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmConditionalOrderHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/conditional/orderHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (strategyId !== undefined) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (newClientStrategyId !== undefined) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
         * @summary Get UM Futures BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmFeeBurnV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmFeeBurnV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/feeBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User\'s UM Force Orders
         * @summary Query User\'s UM Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UM futures Transaction download link by Id
         * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmIncomeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getUmIncomeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmIncomeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/income/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for UM futures transaction history
         * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmIncomeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getUmIncomeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getUmIncomeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmIncomeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/income/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UM Income History
         * @summary Get UM Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmIncomeV1: async (timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmIncomeV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/income`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (incomeType !== undefined) {
                localVarQueryParameter['incomeType'] = incomeType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query UM notional and leverage brackets
         * @summary UM Notional and Leverage Brackets (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmLeverageBracketV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmLeverageBracketV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query current UM open order
         * @summary Query Current UM Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUmOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current UM Open Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOpenOrdersV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Query UM Modify Order History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 500, max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUmOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UM futures order download link by Id
         * @summary Get UM Futures Order Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOrderAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getUmOrderAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmOrderAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for UM futures order history
         * @summary Get Download Id For UM Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOrderAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getUmOrderAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getUmOrderAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmOrderAsynV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an UM order\'s status.
         * @summary Query UM Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current UM position information.
         * @summary Query UM Position Information(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmPositionRiskV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/um/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Get UM Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmPositionSideDualV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current UM account symbol configuration.
         * @summary UM Futures Symbol Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmSymbolConfigV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmSymbolConfigV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/symbolConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UM futures trade download link by Id
         * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmTradeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getUmTradeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmTradeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/trade/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for UM futures trade history
         * @summary Get Download Id For UM Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmTradeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getUmTradeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getUmTradeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmTradeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/trade/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and UM symbol.
         * @summary UM Account Trade List(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmUserTradesV1: async (symbol: string, timestamp: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUmUserTradesV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUmUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify CM Order(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCmOrderV1: async (price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('updateCmOrderV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('updateCmOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('updateCmOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('updateCmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateCmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/cm/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/papi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify UM Order(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUmOrderV1: async (price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('updateUmOrderV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('updateUmOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('updateUmOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('updateUmOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateUmOrderV1', 'timestamp', timestamp)
            const localVarPath = `/papi/v1/um/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioMarginApi - functional programming interface
 * @export
 */
export const PortfolioMarginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortfolioMarginApiAxiosParamCreator(configuration)
    return {
        /**
         * Transfers specific asset from Futures Account to Margin account
         * @summary Fund Collection by Asset(TRADE)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAssetCollectionV1(asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetCollectionV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAssetCollectionV1(asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createAssetCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fund collection for Portfolio Margin
         * @summary Fund Auto-collection(TRADE)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutoCollectionV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAutoCollectionV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutoCollectionV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createAutoCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transfer BNB in and out of UM
         * @summary BNB transfer (TRADE)
         * @param {string} amount 
         * @param {number} timestamp 
         * @param {string} transferSide 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBnbTransferV1(amount: string, timestamp: number, transferSide: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBnbTransferV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBnbTransferV1(amount, timestamp, transferSide, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createBnbTransferV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * New CM Conditional Order
         * @summary New CM Conditional Order(TRADE)
         * @param {string} side 
         * @param {string} strategyType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [newClientStrategyId] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCmConditionalOrderV1(side: string, strategyType: string, symbol: string, timestamp: number, activationPrice?: string, callbackRate?: string, newClientStrategyId?: string, positionSide?: string, price?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCmConditionalOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCmConditionalOrderV1(side, strategyType, symbol, timestamp, activationPrice, callbackRate, newClientStrategyId, positionSide, price, priceProtect, quantity, recvWindow, reduceOnly, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createCmConditionalOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage of specific symbol in CM.
         * @summary Change CM Initial Leverage (TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCmLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCmLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCmLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createCmLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Place new CM order
         * @summary New CM Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCmOrderV1(side: string, symbol: string, timestamp: number, type: string, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCmOrderV1(side, symbol, timestamp, type, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, quantity, recvWindow, reduceOnly, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createCmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Change CM Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCmPositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCmPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCmPositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createCmPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Apply for a margin loan.
         * @summary Margin Account Borrow(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginLoanV1(amount: string, asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginLoanV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginLoanV1(amount, asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createMarginLoanV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginOrderOcoV1(price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, limitClientOrderId?: string, limitIcebergQty?: string, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, sideEffectType?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginOrderOcoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginOrderOcoV1(price, quantity, side, stopPrice, symbol, timestamp, limitClientOrderId, limitIcebergQty, listClientOrderId, newOrderRespType, recvWindow, sideEffectType, stopClientOrderId, stopIcebergQty, stopLimitPrice, stopLimitTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createMarginOrderOcoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * New Margin Order
         * @summary New Margin Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginOrderV1(side: string, symbol: string, timestamp: number, type: string, autoRepayAtCancel?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, sideEffectType?: string, stopPrice?: string, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginOrderV1(side, symbol, timestamp, type, autoRepayAtCancel, icebergQty, newClientOrderId, newOrderRespType, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, sideEffectType, stopPrice, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Repay debt for a margin loan.
         * @summary Margin Account Repay Debt(TRADE)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {string} [amount] 
         * @param {number} [recvWindow] 
         * @param {string} [specifyRepayAssets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginRepayDebtV1(asset: string, timestamp: number, amount?: string, recvWindow?: number, specifyRepayAssets?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginRepayDebtV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginRepayDebtV1(asset, timestamp, amount, recvWindow, specifyRepayAssets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createMarginRepayDebtV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Repay futures Negative Balance
         * @summary Repay futures Negative Balance(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepayFuturesNegativeBalanceV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRepayFuturesNegativeBalanceV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepayFuturesNegativeBalanceV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createRepayFuturesNegativeBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change Auto-repay-futures Status
         * @summary Change Auto-repay-futures Status(TRADE)
         * @param {string} autoRepay 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepayFuturesSwitchV1(autoRepay: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRepayFuturesSwitchV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepayFuturesSwitchV1(autoRepay, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createRepayFuturesSwitchV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Repay for a margin loan.
         * @summary Margin Account Repay(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepayLoanV1(amount: string, asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRepayLoanV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepayLoanV1(amount, asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createRepayLoanV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Place new UM conditional order
         * @summary New UM Conditional Order (TRADE)
         * @param {string} side 
         * @param {string} strategyType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientStrategyId] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUmConditionalOrderV1(side: string, strategyType: string, symbol: string, timestamp: number, activationPrice?: string, callbackRate?: string, goodTillDate?: number, newClientStrategyId?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUmConditionalOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUmConditionalOrderV1(side, strategyType, symbol, timestamp, activationPrice, callbackRate, goodTillDate, newClientStrategyId, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createUmConditionalOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
         * @param {string} feeBurn 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUmFeeBurnV1(feeBurn: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUmFeeBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUmFeeBurnV1(feeBurn, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createUmFeeBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage of specific symbol in UM.
         * @summary Change UM Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUmLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUmLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUmLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createUmLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Place new UM order
         * @summary New UM Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUmOrderV1(side: string, symbol: string, timestamp: number, type: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUmOrderV1(side, symbol, timestamp, type, goodTillDate, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, quantity, recvWindow, reduceOnly, selfTradePreventionMode, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createUmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Change UM Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUmPositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUmPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUmPositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.createUmPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All CM Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCmAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCmAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCmAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteCmAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All CM Open Conditional Orders
         * @summary Cancel All CM Open Conditional Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCmConditionalAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCmConditionalAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCmConditionalAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteCmConditionalAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel CM Conditional Order
         * @summary Cancel CM Conditional Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCmConditionalOrderV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCmConditionalOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCmConditionalOrderV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteCmConditionalOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active LIMIT order
         * @summary Cancel CM Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCmOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCmOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteCmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Margin Account All Open Orders on a Symbol
         * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PmarginDeleteMarginAllOpenOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteMarginAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Margin Account OCO Orders
         * @summary Cancel Margin Account OCO Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginOrderListV1(symbol: string, timestamp: number, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMarginOrderListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginOrderListV1(symbol, timestamp, orderListId, listClientOrderId, newClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteMarginOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Margin Account Order
         * @summary Cancel Margin Account Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginOrderV1(symbol, timestamp, orderId, origClientOrderId, newClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All UM Open Orders(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUmAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUmAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUmAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteUmAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All UM Open Conditional Orders
         * @summary Cancel All UM Open Conditional Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUmConditionalAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUmConditionalAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUmConditionalAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteUmConditionalAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel UM Conditional Order
         * @summary Cancel UM Conditional Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUmConditionalOrderV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUmConditionalOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUmConditionalOrderV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteUmConditionalOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active UM LIMIT order
         * @summary Cancel UM Order(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUmOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUmOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.deleteUmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account information
         * @summary Account Information(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account balance
         * @summary Account Balance(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceV1(timestamp: number, asset?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PmarginGetBalanceV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceV1(timestamp, asset, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current CM account asset and position information.
         * @summary Get CM Account Detail(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCmAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query CM Position ADL Quantile Estimation
         * @summary CM Position ADL Quantile Estimation(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmAdlQuantileV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmAdlQuantileV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account CM orders; active, canceled, or filled.
         * @summary Query All CM Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [pair] 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmAllOrdersV1(symbol: string, timestamp: number, pair?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmAllOrdersV1(symbol, timestamp, pair, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User Commission Rate for CM
         * @summary Get User Commission Rate for CM(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmCommissionRateV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCmCommissionRateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmCommissionRateV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmCommissionRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query All CM Conditional Orders
         * @summary Query All CM Conditional Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [strategyId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmConditionalAllOrdersV1(timestamp: number, symbol?: string, strategyId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmConditionalAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmConditionalAllOrdersV1(timestamp, symbol, strategyId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmConditionalAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current CM Open Conditional Order
         * @summary Query Current CM Open Conditional Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmConditionalOpenOrderV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCmConditionalOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmConditionalOpenOrderV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmConditionalOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
         * @summary Query All Current CM Open Conditional Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmConditionalOpenOrdersV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmConditionalOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmConditionalOpenOrdersV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmConditionalOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query CM Conditional Order History
         * @summary Query CM Conditional Order History(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmConditionalOrderHistoryV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCmConditionalOrderHistoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmConditionalOrderHistoryV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmConditionalOrderHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query User\'s CM Force Orders
         * @summary Query User\'s CM Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmForceOrdersV1(timestamp, symbol, autoCloseType, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CM Income History
         * @summary Get CM Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmIncomeV1(timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmIncomeV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmIncomeV1(timestamp, symbol, incomeType, startTime, endTime, page, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmIncomeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query CM notional and leverage brackets
         * @summary CM Notional and Leverage Brackets(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmLeverageBracketV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmLeverageBracketV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmLeverageBracketV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query current CM open order
         * @summary Query Current CM Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCmOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current CM Open Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmOpenOrdersV1(timestamp: number, symbol?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmOpenOrdersV1(timestamp, symbol, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Query CM Modify Order History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50, max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an CM order\'s status.
         * @summary Query CM Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current CM position information.
         * @summary Query CM Position Information(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [marginAsset] 
         * @param {string} [pair] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmPositionRiskV1(timestamp: number, marginAsset?: string, pair?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmPositionRiskV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmPositionRiskV1(timestamp, marginAsset, pair, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmPositionRiskV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Get CM Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmPositionSideDualV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCmPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmPositionSideDualV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and CM symbol.
         * @summary CM Account Trade List(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [pair] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmUserTradesV1(timestamp: number, symbol?: string, pair?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCmUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmUserTradesV1(timestamp, symbol, pair, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getCmUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [fromId] If supplied, neither startTime or endTime can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAllOrderListV1(timestamp: number, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginAllOrderListV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAllOrderListV1(timestamp, fromId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginAllOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query All Margin Account Orders
         * @summary Query All Margin Account Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAllOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAllOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user\'s margin force orders
         * @summary Query User\'s Margin Force Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginForceOrdersV1(timestamp: number, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginForceOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginForceOrdersV1(timestamp, startTime, endTime, current, size, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Margin Borrow/Loan Interest History
         * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginMarginInterestHistoryV1(timestamp: number, asset?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginMarginInterestHistoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginMarginInterestHistoryV1(timestamp, asset, startTime, endTime, current, size, archived, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginMarginInterestHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query margin loan record
         * @summary Query Margin Loan Record(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [txId] the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginMarginLoanV1(asset: string, timestamp: number, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginMarginLoanV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginMarginLoanV1(asset, timestamp, txId, startTime, endTime, current, size, archived, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginMarginLoanV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query margin max borrow
         * @summary Margin Max Borrow(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginMaxBorrowableV1(asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginMaxBorrowableV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginMaxBorrowableV1(asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginMaxBorrowableV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Max Withdraw
         * @summary Query Margin Max Withdraw(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginMaxWithdrawV1(asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginMaxWithdrawV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginMaxWithdrawV1(asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginMaxWithdrawV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Margin Account Trade List
         * @summary Margin Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginMyTradesV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginMyTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginMyTradesV1(symbol, timestamp, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginMyTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginOpenOrderListV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginOpenOrderListV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginOpenOrderListV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginOpenOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current Margin Open Order
         * @summary Query Current Margin Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [orderListId] Either orderListId or origClientOrderId must be provided
         * @param {string} [origClientOrderId] Either orderListId or origClientOrderId must be provided
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginOrderListV1(timestamp: number, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginOrderListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginOrderListV1(timestamp, orderListId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account Order
         * @summary Query Margin Account Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query margin repay record.
         * @summary Query Margin repay Record(USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [txId] the tranId in &#x60;POST/papi/v1/repayLoan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [archived] Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginRepayLoanV1(asset: string, timestamp: number, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginRepayLoanV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginRepayLoanV1(asset, timestamp, txId, startTime, endTime, current, size, archived, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getMarginRepayLoanV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getPingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query interest history of negative balance for portfolio margin.
         * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioInterestHistoryV1(timestamp: number, asset?: string, startTime?: number, endTime?: number, size?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPortfolioInterestHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioInterestHistoryV1(timestamp, asset, startTime, endTime, size, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getPortfolioInterestHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user negative balance auto exchange record
         * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
         * @param {number} startTime 
         * @param {number} endTime 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioNegativeBalanceExchangeRecordV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPortfolioNegativeBalanceExchangeRecordV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioNegativeBalanceExchangeRecordV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getPortfolioNegativeBalanceExchangeRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimitOrderV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRateLimitOrderV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimitOrderV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getRateLimitOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Auto-repay-futures Status
         * @summary Get Auto-repay-futures Status(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepayFuturesSwitchV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRepayFuturesSwitchV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepayFuturesSwitchV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getRepayFuturesSwitchV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query UM Futures account configuration
         * @summary UM Futures Account Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmAccountConfigV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmAccountConfigV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmAccountConfigV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmAccountConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail V2(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmAccountV2(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmAccountV2Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmAccountV2(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmAccountV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query UM Position ADL Quantile Estimation
         * @summary UM Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmAdlQuantileV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmAdlQuantileV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account UM orders; active, canceled, or filled.
         * @summary Query All UM Orders(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmAllOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmAllOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Portfolio Margin UM Trading Quantitative Rules Indicators
         * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmApiTradingStatusV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmApiTradingStatusV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmApiTradingStatusV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmApiTradingStatusV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User Commission Rate for UM
         * @summary Get User Commission Rate for UM(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmCommissionRateV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmCommissionRateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmCommissionRateV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmCommissionRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query All UM Conditional Orders
         * @summary Query All UM Conditional Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [strategyId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmConditionalAllOrdersV1(timestamp: number, symbol?: string, strategyId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmConditionalAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmConditionalAllOrdersV1(timestamp, symbol, strategyId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmConditionalAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Current UM Open Conditional Order
         * @summary Query Current UM Open Conditional Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmConditionalOpenOrderV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmConditionalOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmConditionalOpenOrderV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmConditionalOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open conditional orders on a symbol.
         * @summary Query All Current UM Open Conditional Orders(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmConditionalOpenOrdersV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmConditionalOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmConditionalOpenOrdersV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmConditionalOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query UM Conditional Order History
         * @summary Query UM Conditional Order History(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [strategyId] 
         * @param {string} [newClientStrategyId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmConditionalOrderHistoryV1(symbol: string, timestamp: number, strategyId?: number, newClientStrategyId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmConditionalOrderHistoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmConditionalOrderHistoryV1(symbol, timestamp, strategyId, newClientStrategyId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmConditionalOrderHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
         * @summary Get UM Futures BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmFeeBurnV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmFeeBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmFeeBurnV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmFeeBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query User\'s UM Force Orders
         * @summary Query User\'s UM Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmForceOrdersV1(timestamp, symbol, autoCloseType, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UM futures Transaction download link by Id
         * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmIncomeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmIncomeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmIncomeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmIncomeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for UM futures transaction history
         * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmIncomeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmIncomeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmIncomeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmIncomeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UM Income History
         * @summary Get UM Income History(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [incomeType] TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
         * @param {number} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number} [page] 
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmIncomeV1(timestamp: number, symbol?: string, incomeType?: string, startTime?: number, endTime?: number, page?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmIncomeV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmIncomeV1(timestamp, symbol, incomeType, startTime, endTime, page, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmIncomeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query UM notional and leverage brackets
         * @summary UM Notional and Leverage Brackets (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmLeverageBracketV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmLeverageBracketV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmLeverageBracketV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query current UM open order
         * @summary Query Current UM Open Order(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current UM Open Orders(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmOpenOrdersV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmOpenOrdersV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Query UM Modify Order History(TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 500, max 1000
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UM futures order download link by Id
         * @summary Get UM Futures Order Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmOrderAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmOrderAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmOrderAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmOrderAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for UM futures order history
         * @summary Get Download Id For UM Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmOrderAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmOrderAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmOrderAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmOrderAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an UM order\'s status.
         * @summary Query UM Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current UM position information.
         * @summary Query UM Position Information(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmPositionRiskV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmPositionRiskV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmPositionRiskV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmPositionRiskV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Get UM Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmPositionSideDualV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmPositionSideDualV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current UM account symbol configuration.
         * @summary UM Futures Symbol Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmSymbolConfigV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmSymbolConfigV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmSymbolConfigV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmSymbolConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UM futures trade download link by Id
         * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmTradeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmTradeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmTradeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmTradeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for UM futures trade history
         * @summary Get Download Id For UM Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmTradeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUmTradeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmTradeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmTradeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and UM symbol.
         * @summary UM Account Trade List(USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmUserTradesV1(symbol: string, timestamp: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUmUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmUserTradesV1(symbol, timestamp, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.getUmUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify CM Order(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCmOrderV1(price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCmOrderV1(price, quantity, side, symbol, timestamp, orderId, origClientOrderId, priceMatch, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.updateCmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.updateListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify UM Order(TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUmOrderV1(price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUmOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUmOrderV1(price, quantity, side, symbol, timestamp, orderId, origClientOrderId, priceMatch, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioMarginApi.updateUmOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PortfolioMarginApi - factory interface
 * @export
 */
export const PortfolioMarginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortfolioMarginApiFp(configuration)
    return {
        /**
         * Transfers specific asset from Futures Account to Margin account
         * @summary Fund Collection by Asset(TRADE)
         * @param {PortfolioMarginApiCreateAssetCollectionV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetCollectionV1(requestParameters: PortfolioMarginApiCreateAssetCollectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetCollectionV1Resp> {
            return localVarFp.createAssetCollectionV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fund collection for Portfolio Margin
         * @summary Fund Auto-collection(TRADE)
         * @param {PortfolioMarginApiCreateAutoCollectionV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoCollectionV1(requestParameters: PortfolioMarginApiCreateAutoCollectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateAutoCollectionV1Resp> {
            return localVarFp.createAutoCollectionV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfer BNB in and out of UM
         * @summary BNB transfer (TRADE)
         * @param {PortfolioMarginApiCreateBnbTransferV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBnbTransferV1(requestParameters: PortfolioMarginApiCreateBnbTransferV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateBnbTransferV1Resp> {
            return localVarFp.createBnbTransferV1(requestParameters.amount, requestParameters.timestamp, requestParameters.transferSide, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * New CM Conditional Order
         * @summary New CM Conditional Order(TRADE)
         * @param {PortfolioMarginApiCreateCmConditionalOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmConditionalOrderV1(requestParameters: PortfolioMarginApiCreateCmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmConditionalOrderV1Resp> {
            return localVarFp.createCmConditionalOrderV1(requestParameters.side, requestParameters.strategyType, requestParameters.symbol, requestParameters.timestamp, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.newClientStrategyId, requestParameters.positionSide, requestParameters.price, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage of specific symbol in CM.
         * @summary Change CM Initial Leverage (TRADE)
         * @param {PortfolioMarginApiCreateCmLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmLeverageV1(requestParameters: PortfolioMarginApiCreateCmLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmLeverageV1Resp> {
            return localVarFp.createCmLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Place new CM order
         * @summary New CM Order(TRADE)
         * @param {PortfolioMarginApiCreateCmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmOrderV1(requestParameters: PortfolioMarginApiCreateCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmOrderV1Resp> {
            return localVarFp.createCmOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Change CM Position Mode(TRADE)
         * @param {PortfolioMarginApiCreateCmPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmPositionSideDualV1(requestParameters: PortfolioMarginApiCreateCmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmPositionSideDualV1Resp> {
            return localVarFp.createCmPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp> {
            return localVarFp.createListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Apply for a margin loan.
         * @summary Margin Account Borrow(MARGIN)
         * @param {PortfolioMarginApiCreateMarginLoanV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginLoanV1(requestParameters: PortfolioMarginApiCreateMarginLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginLoanV1Resp> {
            return localVarFp.createMarginLoanV1(requestParameters.amount, requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO(TRADE)
         * @param {PortfolioMarginApiCreateMarginOrderOcoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderOcoV1(requestParameters: PortfolioMarginApiCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderOcoV1Resp> {
            return localVarFp.createMarginOrderOcoV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.sideEffectType, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * New Margin Order
         * @summary New Margin Order(TRADE)
         * @param {PortfolioMarginApiCreateMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderV1(requestParameters: PortfolioMarginApiCreateMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderV1Resp> {
            return localVarFp.createMarginOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.autoRepayAtCancel, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.stopPrice, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Repay debt for a margin loan.
         * @summary Margin Account Repay Debt(TRADE)
         * @param {PortfolioMarginApiCreateMarginRepayDebtV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginRepayDebtV1(requestParameters: PortfolioMarginApiCreateMarginRepayDebtV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginRepayDebtV1Resp> {
            return localVarFp.createMarginRepayDebtV1(requestParameters.asset, requestParameters.timestamp, requestParameters.amount, requestParameters.recvWindow, requestParameters.specifyRepayAssets, options).then((request) => request(axios, basePath));
        },
        /**
         * Repay futures Negative Balance
         * @summary Repay futures Negative Balance(USER_DATA)
         * @param {PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepayFuturesNegativeBalanceV1(requestParameters: PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateRepayFuturesNegativeBalanceV1Resp> {
            return localVarFp.createRepayFuturesNegativeBalanceV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change Auto-repay-futures Status
         * @summary Change Auto-repay-futures Status(TRADE)
         * @param {PortfolioMarginApiCreateRepayFuturesSwitchV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepayFuturesSwitchV1(requestParameters: PortfolioMarginApiCreateRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateRepayFuturesSwitchV1Resp> {
            return localVarFp.createRepayFuturesSwitchV1(requestParameters.autoRepay, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Repay for a margin loan.
         * @summary Margin Account Repay(MARGIN)
         * @param {PortfolioMarginApiCreateRepayLoanV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepayLoanV1(requestParameters: PortfolioMarginApiCreateRepayLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateRepayLoanV1Resp> {
            return localVarFp.createRepayLoanV1(requestParameters.amount, requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Place new UM conditional order
         * @summary New UM Conditional Order (TRADE)
         * @param {PortfolioMarginApiCreateUmConditionalOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmConditionalOrderV1(requestParameters: PortfolioMarginApiCreateUmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmConditionalOrderV1Resp> {
            return localVarFp.createUmConditionalOrderV1(requestParameters.side, requestParameters.strategyType, requestParameters.symbol, requestParameters.timestamp, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.goodTillDate, requestParameters.newClientStrategyId, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
         * @param {PortfolioMarginApiCreateUmFeeBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmFeeBurnV1(requestParameters: PortfolioMarginApiCreateUmFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmFeeBurnV1Resp> {
            return localVarFp.createUmFeeBurnV1(requestParameters.feeBurn, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage of specific symbol in UM.
         * @summary Change UM Initial Leverage(TRADE)
         * @param {PortfolioMarginApiCreateUmLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmLeverageV1(requestParameters: PortfolioMarginApiCreateUmLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmLeverageV1Resp> {
            return localVarFp.createUmLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Place new UM order
         * @summary New UM Order (TRADE)
         * @param {PortfolioMarginApiCreateUmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmOrderV1(requestParameters: PortfolioMarginApiCreateUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmOrderV1Resp> {
            return localVarFp.createUmOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Change UM Position Mode(TRADE)
         * @param {PortfolioMarginApiCreateUmPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUmPositionSideDualV1(requestParameters: PortfolioMarginApiCreateUmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmPositionSideDualV1Resp> {
            return localVarFp.createUmPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All CM Open Orders(TRADE)
         * @param {PortfolioMarginApiDeleteCmAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteCmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCmAllOpenOrdersV1Resp> {
            return localVarFp.deleteCmAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All CM Open Conditional Orders
         * @summary Cancel All CM Open Conditional Orders(TRADE)
         * @param {PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmConditionalAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCmConditionalAllOpenOrdersV1Resp> {
            return localVarFp.deleteCmConditionalAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel CM Conditional Order
         * @summary Cancel CM Conditional Order(TRADE)
         * @param {PortfolioMarginApiDeleteCmConditionalOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmConditionalOrderV1(requestParameters: PortfolioMarginApiDeleteCmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCmConditionalOrderV1Resp> {
            return localVarFp.deleteCmConditionalOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active LIMIT order
         * @summary Cancel CM Order(TRADE)
         * @param {PortfolioMarginApiDeleteCmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmOrderV1(requestParameters: PortfolioMarginApiDeleteCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCmOrderV1Resp> {
            return localVarFp.deleteCmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream(USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Margin Account All Open Orders on a Symbol
         * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
         * @param {PortfolioMarginApiDeleteMarginAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteMarginAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginDeleteMarginAllOpenOrdersV1RespInner>> {
            return localVarFp.deleteMarginAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Margin Account OCO Orders
         * @summary Cancel Margin Account OCO Orders(TRADE)
         * @param {PortfolioMarginApiDeleteMarginOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOrderListV1(requestParameters: PortfolioMarginApiDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginOrderListV1Resp> {
            return localVarFp.deleteMarginOrderListV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Margin Account Order
         * @summary Cancel Margin Account Order(TRADE)
         * @param {PortfolioMarginApiDeleteMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOrderV1(requestParameters: PortfolioMarginApiDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginOrderV1Resp> {
            return localVarFp.deleteMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         * @summary Cancel All UM Open Orders(TRADE)
         * @param {PortfolioMarginApiDeleteUmAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUmAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteUmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUmAllOpenOrdersV1Resp> {
            return localVarFp.deleteUmAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All UM Open Conditional Orders
         * @summary Cancel All UM Open Conditional Orders (TRADE)
         * @param {PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUmConditionalAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUmConditionalAllOpenOrdersV1Resp> {
            return localVarFp.deleteUmConditionalAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel UM Conditional Order
         * @summary Cancel UM Conditional Order(TRADE)
         * @param {PortfolioMarginApiDeleteUmConditionalOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUmConditionalOrderV1(requestParameters: PortfolioMarginApiDeleteUmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUmConditionalOrderV1Resp> {
            return localVarFp.deleteUmConditionalOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active UM LIMIT order
         * @summary Cancel UM Order(TRADE)
         * @param {PortfolioMarginApiDeleteUmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUmOrderV1(requestParameters: PortfolioMarginApiDeleteUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUmOrderV1Resp> {
            return localVarFp.deleteUmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account information
         * @summary Account Information(USER_DATA)
         * @param {PortfolioMarginApiGetAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1(requestParameters: PortfolioMarginApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV1Resp> {
            return localVarFp.getAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account balance
         * @summary Account Balance(USER_DATA)
         * @param {PortfolioMarginApiGetBalanceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV1(requestParameters: PortfolioMarginApiGetBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetBalanceV1Resp> {
            return localVarFp.getBalanceV1(requestParameters.timestamp, requestParameters.asset, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current CM account asset and position information.
         * @summary Get CM Account Detail(USER_DATA)
         * @param {PortfolioMarginApiGetCmAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmAccountV1(requestParameters: PortfolioMarginApiGetCmAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmAccountV1Resp> {
            return localVarFp.getCmAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query CM Position ADL Quantile Estimation
         * @summary CM Position ADL Quantile Estimation(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmAdlQuantileV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmAdlQuantileV1RespItem>> {
            return localVarFp.getCmAdlQuantileV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account CM orders; active, canceled, or filled.
         * @summary Query All CM Orders (USER_DATA)
         * @param {PortfolioMarginApiGetCmAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmAllOrdersV1(requestParameters: PortfolioMarginApiGetCmAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmAllOrdersV1RespItem>> {
            return localVarFp.getCmAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User Commission Rate for CM
         * @summary Get User Commission Rate for CM(USER_DATA)
         * @param {PortfolioMarginApiGetCmCommissionRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmCommissionRateV1(requestParameters: PortfolioMarginApiGetCmCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmCommissionRateV1Resp> {
            return localVarFp.getCmCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query All CM Conditional Orders
         * @summary Query All CM Conditional Orders(USER_DATA)
         * @param {PortfolioMarginApiGetCmConditionalAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmConditionalAllOrdersV1(requestParameters: PortfolioMarginApiGetCmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmConditionalAllOrdersV1RespItem>> {
            return localVarFp.getCmConditionalAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.strategyId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current CM Open Conditional Order
         * @summary Query Current CM Open Conditional Order(USER_DATA)
         * @param {PortfolioMarginApiGetCmConditionalOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmConditionalOpenOrderV1(requestParameters: PortfolioMarginApiGetCmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmConditionalOpenOrderV1Resp> {
            return localVarFp.getCmConditionalOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
         * @summary Query All Current CM Open Conditional Orders (USER_DATA)
         * @param {PortfolioMarginApiGetCmConditionalOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmConditionalOpenOrdersV1(requestParameters: PortfolioMarginApiGetCmConditionalOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmConditionalOpenOrdersV1RespItem>> {
            return localVarFp.getCmConditionalOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query CM Conditional Order History
         * @summary Query CM Conditional Order History(USER_DATA)
         * @param {PortfolioMarginApiGetCmConditionalOrderHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmConditionalOrderHistoryV1(requestParameters: PortfolioMarginApiGetCmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmConditionalOrderHistoryV1Resp> {
            return localVarFp.getCmConditionalOrderHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User\'s CM Force Orders
         * @summary Query User\'s CM Force Orders(USER_DATA)
         * @param {PortfolioMarginApiGetCmForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmForceOrdersV1(requestParameters: PortfolioMarginApiGetCmForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmForceOrdersV1RespItem>> {
            return localVarFp.getCmForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CM Income History
         * @summary Get CM Income History(USER_DATA)
         * @param {PortfolioMarginApiGetCmIncomeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmIncomeV1(requestParameters: PortfolioMarginApiGetCmIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmIncomeV1RespItem>> {
            return localVarFp.getCmIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query CM notional and leverage brackets
         * @summary CM Notional and Leverage Brackets(USER_DATA)
         * @param {PortfolioMarginApiGetCmLeverageBracketV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmLeverageBracketV1(requestParameters: PortfolioMarginApiGetCmLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmLeverageBracketV1RespItem>> {
            return localVarFp.getCmLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query current CM open order
         * @summary Query Current CM Open Order (USER_DATA)
         * @param {PortfolioMarginApiGetCmOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmOpenOrderV1(requestParameters: PortfolioMarginApiGetCmOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmOpenOrderV1Resp> {
            return localVarFp.getCmOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current CM Open Orders(USER_DATA)
         * @param {PortfolioMarginApiGetCmOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmOpenOrdersV1(requestParameters: PortfolioMarginApiGetCmOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmOpenOrdersV1RespItem>> {
            return localVarFp.getCmOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Query CM Modify Order History(TRADE)
         * @param {PortfolioMarginApiGetCmOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmOrderAmendmentV1(requestParameters: PortfolioMarginApiGetCmOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmOrderAmendmentV1RespItem>> {
            return localVarFp.getCmOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an CM order\'s status.
         * @summary Query CM Order(USER_DATA)
         * @param {PortfolioMarginApiGetCmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmOrderV1(requestParameters: PortfolioMarginApiGetCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmOrderV1Resp> {
            return localVarFp.getCmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current CM position information.
         * @summary Query CM Position Information(USER_DATA)
         * @param {PortfolioMarginApiGetCmPositionRiskV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmPositionRiskV1(requestParameters: PortfolioMarginApiGetCmPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmPositionRiskV1RespItem>> {
            return localVarFp.getCmPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         * @summary Get CM Current Position Mode(USER_DATA)
         * @param {PortfolioMarginApiGetCmPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmPositionSideDualV1(requestParameters: PortfolioMarginApiGetCmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmPositionSideDualV1Resp> {
            return localVarFp.getCmPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and CM symbol.
         * @summary CM Account Trade List(USER_DATA)
         * @param {PortfolioMarginApiGetCmUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmUserTradesV1(requestParameters: PortfolioMarginApiGetCmUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmUserTradesV1RespItem>> {
            return localVarFp.getCmUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {PortfolioMarginApiGetMarginAllOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllOrderListV1(requestParameters: PortfolioMarginApiGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllOrderListV1RespItem>> {
            return localVarFp.getMarginAllOrderListV1(requestParameters.timestamp, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query All Margin Account Orders
         * @summary Query All Margin Account Orders (USER_DATA)
         * @param {PortfolioMarginApiGetMarginAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllOrdersV1(requestParameters: PortfolioMarginApiGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllOrdersV1RespItem>> {
            return localVarFp.getMarginAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user\'s margin force orders
         * @summary Query User\'s Margin Force Orders(USER_DATA)
         * @param {PortfolioMarginApiGetMarginForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginForceOrdersV1(requestParameters: PortfolioMarginApiGetMarginForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginForceOrdersV1Resp> {
            return localVarFp.getMarginForceOrdersV1(requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Margin Borrow/Loan Interest History
         * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
         * @param {PortfolioMarginApiGetMarginMarginInterestHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMarginInterestHistoryV1(requestParameters: PortfolioMarginApiGetMarginMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMarginInterestHistoryV1Resp> {
            return localVarFp.getMarginMarginInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query margin loan record
         * @summary Query Margin Loan Record(USER_DATA)
         * @param {PortfolioMarginApiGetMarginMarginLoanV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMarginLoanV1(requestParameters: PortfolioMarginApiGetMarginMarginLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMarginLoanV1Resp> {
            return localVarFp.getMarginMarginLoanV1(requestParameters.asset, requestParameters.timestamp, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query margin max borrow
         * @summary Margin Max Borrow(USER_DATA)
         * @param {PortfolioMarginApiGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMaxBorrowableV1(requestParameters: PortfolioMarginApiGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMaxBorrowableV1Resp> {
            return localVarFp.getMarginMaxBorrowableV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Max Withdraw
         * @summary Query Margin Max Withdraw(USER_DATA)
         * @param {PortfolioMarginApiGetMarginMaxWithdrawV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMaxWithdrawV1(requestParameters: PortfolioMarginApiGetMarginMaxWithdrawV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMaxWithdrawV1Resp> {
            return localVarFp.getMarginMaxWithdrawV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Margin Account Trade List
         * @summary Margin Account Trade List (USER_DATA)
         * @param {PortfolioMarginApiGetMarginMyTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMyTradesV1(requestParameters: PortfolioMarginApiGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginMyTradesV1RespItem>> {
            return localVarFp.getMarginMyTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {PortfolioMarginApiGetMarginOpenOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOpenOrderListV1(requestParameters: PortfolioMarginApiGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginOpenOrderListV1RespItem>> {
            return localVarFp.getMarginOpenOrderListV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current Margin Open Order
         * @summary Query Current Margin Open Order (USER_DATA)
         * @param {PortfolioMarginApiGetMarginOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOpenOrdersV1(requestParameters: PortfolioMarginApiGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginOpenOrdersV1RespItem>> {
            return localVarFp.getMarginOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {PortfolioMarginApiGetMarginOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOrderListV1(requestParameters: PortfolioMarginApiGetMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginOrderListV1Resp> {
            return localVarFp.getMarginOrderListV1(requestParameters.timestamp, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account Order
         * @summary Query Margin Account Order (USER_DATA)
         * @param {PortfolioMarginApiGetMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOrderV1(requestParameters: PortfolioMarginApiGetMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginOrderV1Resp> {
            return localVarFp.getMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query margin repay record.
         * @summary Query Margin repay Record(USER_DATA)
         * @param {PortfolioMarginApiGetMarginRepayLoanV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginRepayLoanV1(requestParameters: PortfolioMarginApiGetMarginRepayLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginRepayLoanV1Resp> {
            return localVarFp.getMarginRepayLoanV1(requestParameters.asset, requestParameters.timestamp, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Query interest history of negative balance for portfolio margin.
         * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
         * @param {PortfolioMarginApiGetPortfolioInterestHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioInterestHistoryV1(requestParameters: PortfolioMarginApiGetPortfolioInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPortfolioInterestHistoryV1RespItem>> {
            return localVarFp.getPortfolioInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.startTime, requestParameters.endTime, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user negative balance auto exchange record
         * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
         * @param {PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioNegativeBalanceExchangeRecordV1(requestParameters: PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPortfolioNegativeBalanceExchangeRecordV1Resp> {
            return localVarFp.getPortfolioNegativeBalanceExchangeRecordV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {PortfolioMarginApiGetRateLimitOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimitOrderV1(requestParameters: PortfolioMarginApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRateLimitOrderV1RespItem>> {
            return localVarFp.getRateLimitOrderV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Auto-repay-futures Status
         * @summary Get Auto-repay-futures Status(USER_DATA)
         * @param {PortfolioMarginApiGetRepayFuturesSwitchV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepayFuturesSwitchV1(requestParameters: PortfolioMarginApiGetRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetRepayFuturesSwitchV1Resp> {
            return localVarFp.getRepayFuturesSwitchV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query UM Futures account configuration
         * @summary UM Futures Account Configuration(USER_DATA)
         * @param {PortfolioMarginApiGetUmAccountConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAccountConfigV1(requestParameters: PortfolioMarginApiGetUmAccountConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmAccountConfigV1Resp> {
            return localVarFp.getUmAccountConfigV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail(USER_DATA)
         * @param {PortfolioMarginApiGetUmAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAccountV1(requestParameters: PortfolioMarginApiGetUmAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmAccountV1Resp> {
            return localVarFp.getUmAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current UM account asset and position information.
         * @summary Get UM Account Detail V2(USER_DATA)
         * @param {PortfolioMarginApiGetUmAccountV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAccountV2(requestParameters: PortfolioMarginApiGetUmAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmAccountV2Resp> {
            return localVarFp.getUmAccountV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query UM Position ADL Quantile Estimation
         * @summary UM Position ADL Quantile Estimation(USER_DATA)
         * @param {PortfolioMarginApiGetUmAdlQuantileV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAdlQuantileV1(requestParameters: PortfolioMarginApiGetUmAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmAdlQuantileV1RespItem>> {
            return localVarFp.getUmAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account UM orders; active, canceled, or filled.
         * @summary Query All UM Orders(USER_DATA)
         * @param {PortfolioMarginApiGetUmAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmAllOrdersV1(requestParameters: PortfolioMarginApiGetUmAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmAllOrdersV1RespItem>> {
            return localVarFp.getUmAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Portfolio Margin UM Trading Quantitative Rules Indicators
         * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
         * @param {PortfolioMarginApiGetUmApiTradingStatusV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmApiTradingStatusV1(requestParameters: PortfolioMarginApiGetUmApiTradingStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmApiTradingStatusV1Resp> {
            return localVarFp.getUmApiTradingStatusV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User Commission Rate for UM
         * @summary Get User Commission Rate for UM(USER_DATA)
         * @param {PortfolioMarginApiGetUmCommissionRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmCommissionRateV1(requestParameters: PortfolioMarginApiGetUmCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmCommissionRateV1Resp> {
            return localVarFp.getUmCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query All UM Conditional Orders
         * @summary Query All UM Conditional Orders(USER_DATA)
         * @param {PortfolioMarginApiGetUmConditionalAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmConditionalAllOrdersV1(requestParameters: PortfolioMarginApiGetUmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmConditionalAllOrdersV1RespItem>> {
            return localVarFp.getUmConditionalAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.strategyId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Current UM Open Conditional Order
         * @summary Query Current UM Open Conditional Order(USER_DATA)
         * @param {PortfolioMarginApiGetUmConditionalOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmConditionalOpenOrderV1(requestParameters: PortfolioMarginApiGetUmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmConditionalOpenOrderV1Resp> {
            return localVarFp.getUmConditionalOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open conditional orders on a symbol.
         * @summary Query All Current UM Open Conditional Orders(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmConditionalOpenOrdersV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmConditionalOpenOrdersV1RespItem>> {
            return localVarFp.getUmConditionalOpenOrdersV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Query UM Conditional Order History
         * @summary Query UM Conditional Order History(USER_DATA)
         * @param {PortfolioMarginApiGetUmConditionalOrderHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmConditionalOrderHistoryV1(requestParameters: PortfolioMarginApiGetUmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmConditionalOrderHistoryV1Resp> {
            return localVarFp.getUmConditionalOrderHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
         * @summary Get UM Futures BNB Burn Status (USER_DATA)
         * @param {PortfolioMarginApiGetUmFeeBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmFeeBurnV1(requestParameters: PortfolioMarginApiGetUmFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmFeeBurnV1Resp> {
            return localVarFp.getUmFeeBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User\'s UM Force Orders
         * @summary Query User\'s UM Force Orders (USER_DATA)
         * @param {PortfolioMarginApiGetUmForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmForceOrdersV1(requestParameters: PortfolioMarginApiGetUmForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmForceOrdersV1RespItem>> {
            return localVarFp.getUmForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UM futures Transaction download link by Id
         * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
         * @param {PortfolioMarginApiGetUmIncomeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmIncomeAsynIdV1(requestParameters: PortfolioMarginApiGetUmIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmIncomeAsynIdV1Resp> {
            return localVarFp.getUmIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for UM futures transaction history
         * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
         * @param {PortfolioMarginApiGetUmIncomeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmIncomeAsynV1(requestParameters: PortfolioMarginApiGetUmIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmIncomeAsynV1Resp> {
            return localVarFp.getUmIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UM Income History
         * @summary Get UM Income History(USER_DATA)
         * @param {PortfolioMarginApiGetUmIncomeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmIncomeV1(requestParameters: PortfolioMarginApiGetUmIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmIncomeV1RespItem>> {
            return localVarFp.getUmIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query UM notional and leverage brackets
         * @summary UM Notional and Leverage Brackets (USER_DATA)
         * @param {PortfolioMarginApiGetUmLeverageBracketV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmLeverageBracketV1(requestParameters: PortfolioMarginApiGetUmLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmLeverageBracketV1RespItem>> {
            return localVarFp.getUmLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query current UM open order
         * @summary Query Current UM Open Order(USER_DATA)
         * @param {PortfolioMarginApiGetUmOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOpenOrderV1(requestParameters: PortfolioMarginApiGetUmOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmOpenOrderV1Resp> {
            return localVarFp.getUmOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol.
         * @summary Query All Current UM Open Orders(USER_DATA)
         * @param {PortfolioMarginApiGetUmOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOpenOrdersV1(requestParameters: PortfolioMarginApiGetUmOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmOpenOrdersV1RespItem>> {
            return localVarFp.getUmOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Query UM Modify Order History(TRADE)
         * @param {PortfolioMarginApiGetUmOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOrderAmendmentV1(requestParameters: PortfolioMarginApiGetUmOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmOrderAmendmentV1RespItem>> {
            return localVarFp.getUmOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UM futures order download link by Id
         * @summary Get UM Futures Order Download Link by Id(USER_DATA)
         * @param {PortfolioMarginApiGetUmOrderAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOrderAsynIdV1(requestParameters: PortfolioMarginApiGetUmOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmOrderAsynIdV1Resp> {
            return localVarFp.getUmOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for UM futures order history
         * @summary Get Download Id For UM Futures Order History (USER_DATA)
         * @param {PortfolioMarginApiGetUmOrderAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOrderAsynV1(requestParameters: PortfolioMarginApiGetUmOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmOrderAsynV1Resp> {
            return localVarFp.getUmOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an UM order\'s status.
         * @summary Query UM Order (USER_DATA)
         * @param {PortfolioMarginApiGetUmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmOrderV1(requestParameters: PortfolioMarginApiGetUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmOrderV1Resp> {
            return localVarFp.getUmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current UM position information.
         * @summary Query UM Position Information(USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmPositionRiskV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmPositionRiskV1RespItem>> {
            return localVarFp.getUmPositionRiskV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         * @summary Get UM Current Position Mode(USER_DATA)
         * @param {PortfolioMarginApiGetUmPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmPositionSideDualV1(requestParameters: PortfolioMarginApiGetUmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmPositionSideDualV1Resp> {
            return localVarFp.getUmPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current UM account symbol configuration.
         * @summary UM Futures Symbol Configuration(USER_DATA)
         * @param {PortfolioMarginApiGetUmSymbolConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmSymbolConfigV1(requestParameters: PortfolioMarginApiGetUmSymbolConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmSymbolConfigV1RespItem>> {
            return localVarFp.getUmSymbolConfigV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UM futures trade download link by Id
         * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
         * @param {PortfolioMarginApiGetUmTradeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmTradeAsynIdV1(requestParameters: PortfolioMarginApiGetUmTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmTradeAsynIdV1Resp> {
            return localVarFp.getUmTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for UM futures trade history
         * @summary Get Download Id For UM Futures Trade History (USER_DATA)
         * @param {PortfolioMarginApiGetUmTradeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmTradeAsynV1(requestParameters: PortfolioMarginApiGetUmTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmTradeAsynV1Resp> {
            return localVarFp.getUmTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and UM symbol.
         * @summary UM Account Trade List(USER_DATA)
         * @param {PortfolioMarginApiGetUmUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmUserTradesV1(requestParameters: PortfolioMarginApiGetUmUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmUserTradesV1RespItem>> {
            return localVarFp.getUmUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify CM Order(TRADE)
         * @param {PortfolioMarginApiUpdateCmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCmOrderV1(requestParameters: PortfolioMarginApiUpdateCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateCmOrderV1Resp> {
            return localVarFp.updateCmOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify UM Order(TRADE)
         * @param {PortfolioMarginApiUpdateUmOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUmOrderV1(requestParameters: PortfolioMarginApiUpdateUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateUmOrderV1Resp> {
            return localVarFp.updateUmOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfolioMarginApi - interface
 * @export
 * @interface PortfolioMarginApi
 */
export interface PortfolioMarginApiInterface {
    /**
     * Transfers specific asset from Futures Account to Margin account
     * @summary Fund Collection by Asset(TRADE)
     * @param {PortfolioMarginApiCreateAssetCollectionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createAssetCollectionV1(requestParameters: PortfolioMarginApiCreateAssetCollectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetCollectionV1Resp>;

    /**
     * Fund collection for Portfolio Margin
     * @summary Fund Auto-collection(TRADE)
     * @param {PortfolioMarginApiCreateAutoCollectionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createAutoCollectionV1(requestParameters: PortfolioMarginApiCreateAutoCollectionV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateAutoCollectionV1Resp>;

    /**
     * Transfer BNB in and out of UM
     * @summary BNB transfer (TRADE)
     * @param {PortfolioMarginApiCreateBnbTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createBnbTransferV1(requestParameters: PortfolioMarginApiCreateBnbTransferV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateBnbTransferV1Resp>;

    /**
     * New CM Conditional Order
     * @summary New CM Conditional Order(TRADE)
     * @param {PortfolioMarginApiCreateCmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createCmConditionalOrderV1(requestParameters: PortfolioMarginApiCreateCmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmConditionalOrderV1Resp>;

    /**
     * Change user\'s initial leverage of specific symbol in CM.
     * @summary Change CM Initial Leverage (TRADE)
     * @param {PortfolioMarginApiCreateCmLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createCmLeverageV1(requestParameters: PortfolioMarginApiCreateCmLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmLeverageV1Resp>;

    /**
     * Place new CM order
     * @summary New CM Order(TRADE)
     * @param {PortfolioMarginApiCreateCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createCmOrderV1(requestParameters: PortfolioMarginApiCreateCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmOrderV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * @summary Change CM Position Mode(TRADE)
     * @param {PortfolioMarginApiCreateCmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createCmPositionSideDualV1(requestParameters: PortfolioMarginApiCreateCmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmPositionSideDualV1Resp>;

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream(USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp>;

    /**
     * Apply for a margin loan.
     * @summary Margin Account Borrow(MARGIN)
     * @param {PortfolioMarginApiCreateMarginLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createMarginLoanV1(requestParameters: PortfolioMarginApiCreateMarginLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginLoanV1Resp>;

    /**
     * Send in a new OCO for a margin account
     * @summary Margin Account New OCO(TRADE)
     * @param {PortfolioMarginApiCreateMarginOrderOcoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createMarginOrderOcoV1(requestParameters: PortfolioMarginApiCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderOcoV1Resp>;

    /**
     * New Margin Order
     * @summary New Margin Order(TRADE)
     * @param {PortfolioMarginApiCreateMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createMarginOrderV1(requestParameters: PortfolioMarginApiCreateMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderV1Resp>;

    /**
     * Repay debt for a margin loan.
     * @summary Margin Account Repay Debt(TRADE)
     * @param {PortfolioMarginApiCreateMarginRepayDebtV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createMarginRepayDebtV1(requestParameters: PortfolioMarginApiCreateMarginRepayDebtV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginRepayDebtV1Resp>;

    /**
     * Repay futures Negative Balance
     * @summary Repay futures Negative Balance(USER_DATA)
     * @param {PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createRepayFuturesNegativeBalanceV1(requestParameters: PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateRepayFuturesNegativeBalanceV1Resp>;

    /**
     * Change Auto-repay-futures Status
     * @summary Change Auto-repay-futures Status(TRADE)
     * @param {PortfolioMarginApiCreateRepayFuturesSwitchV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createRepayFuturesSwitchV1(requestParameters: PortfolioMarginApiCreateRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateRepayFuturesSwitchV1Resp>;

    /**
     * Repay for a margin loan.
     * @summary Margin Account Repay(MARGIN)
     * @param {PortfolioMarginApiCreateRepayLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createRepayLoanV1(requestParameters: PortfolioMarginApiCreateRepayLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateRepayLoanV1Resp>;

    /**
     * Place new UM conditional order
     * @summary New UM Conditional Order (TRADE)
     * @param {PortfolioMarginApiCreateUmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createUmConditionalOrderV1(requestParameters: PortfolioMarginApiCreateUmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmConditionalOrderV1Resp>;

    /**
     * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
     * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
     * @param {PortfolioMarginApiCreateUmFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createUmFeeBurnV1(requestParameters: PortfolioMarginApiCreateUmFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmFeeBurnV1Resp>;

    /**
     * Change user\'s initial leverage of specific symbol in UM.
     * @summary Change UM Initial Leverage(TRADE)
     * @param {PortfolioMarginApiCreateUmLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createUmLeverageV1(requestParameters: PortfolioMarginApiCreateUmLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmLeverageV1Resp>;

    /**
     * Place new UM order
     * @summary New UM Order (TRADE)
     * @param {PortfolioMarginApiCreateUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createUmOrderV1(requestParameters: PortfolioMarginApiCreateUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmOrderV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * @summary Change UM Position Mode(TRADE)
     * @param {PortfolioMarginApiCreateUmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    createUmPositionSideDualV1(requestParameters: PortfolioMarginApiCreateUmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUmPositionSideDualV1Resp>;

    /**
     * Cancel all active LIMIT orders on specific symbol
     * @summary Cancel All CM Open Orders(TRADE)
     * @param {PortfolioMarginApiDeleteCmAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteCmAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteCmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCmAllOpenOrdersV1Resp>;

    /**
     * Cancel All CM Open Conditional Orders
     * @summary Cancel All CM Open Conditional Orders(TRADE)
     * @param {PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteCmConditionalAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCmConditionalAllOpenOrdersV1Resp>;

    /**
     * Cancel CM Conditional Order
     * @summary Cancel CM Conditional Order(TRADE)
     * @param {PortfolioMarginApiDeleteCmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteCmConditionalOrderV1(requestParameters: PortfolioMarginApiDeleteCmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCmConditionalOrderV1Resp>;

    /**
     * Cancel an active LIMIT order
     * @summary Cancel CM Order(TRADE)
     * @param {PortfolioMarginApiDeleteCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteCmOrderV1(requestParameters: PortfolioMarginApiDeleteCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCmOrderV1Resp>;

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream(USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Cancel Margin Account All Open Orders on a Symbol
     * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
     * @param {PortfolioMarginApiDeleteMarginAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteMarginAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteMarginAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PmarginDeleteMarginAllOpenOrdersV1RespInner>>;

    /**
     * Cancel Margin Account OCO Orders
     * @summary Cancel Margin Account OCO Orders(TRADE)
     * @param {PortfolioMarginApiDeleteMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteMarginOrderListV1(requestParameters: PortfolioMarginApiDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginOrderListV1Resp>;

    /**
     * Cancel Margin Account Order
     * @summary Cancel Margin Account Order(TRADE)
     * @param {PortfolioMarginApiDeleteMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteMarginOrderV1(requestParameters: PortfolioMarginApiDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginOrderV1Resp>;

    /**
     * Cancel all active LIMIT orders on specific symbol
     * @summary Cancel All UM Open Orders(TRADE)
     * @param {PortfolioMarginApiDeleteUmAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteUmAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteUmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUmAllOpenOrdersV1Resp>;

    /**
     * Cancel All UM Open Conditional Orders
     * @summary Cancel All UM Open Conditional Orders (TRADE)
     * @param {PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteUmConditionalAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUmConditionalAllOpenOrdersV1Resp>;

    /**
     * Cancel UM Conditional Order
     * @summary Cancel UM Conditional Order(TRADE)
     * @param {PortfolioMarginApiDeleteUmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteUmConditionalOrderV1(requestParameters: PortfolioMarginApiDeleteUmConditionalOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUmConditionalOrderV1Resp>;

    /**
     * Cancel an active UM LIMIT order
     * @summary Cancel UM Order(TRADE)
     * @param {PortfolioMarginApiDeleteUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    deleteUmOrderV1(requestParameters: PortfolioMarginApiDeleteUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUmOrderV1Resp>;

    /**
     * Query account information
     * @summary Account Information(USER_DATA)
     * @param {PortfolioMarginApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getAccountV1(requestParameters: PortfolioMarginApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV1Resp>;

    /**
     * Query account balance
     * @summary Account Balance(USER_DATA)
     * @param {PortfolioMarginApiGetBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getBalanceV1(requestParameters: PortfolioMarginApiGetBalanceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<PmarginGetBalanceV1Resp>;

    /**
     * Get current CM account asset and position information.
     * @summary Get CM Account Detail(USER_DATA)
     * @param {PortfolioMarginApiGetCmAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmAccountV1(requestParameters: PortfolioMarginApiGetCmAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmAccountV1Resp>;

    /**
     * Query CM Position ADL Quantile Estimation
     * @summary CM Position ADL Quantile Estimation(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmAdlQuantileV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmAdlQuantileV1RespItem>>;

    /**
     * Get all account CM orders; active, canceled, or filled.
     * @summary Query All CM Orders (USER_DATA)
     * @param {PortfolioMarginApiGetCmAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmAllOrdersV1(requestParameters: PortfolioMarginApiGetCmAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmAllOrdersV1RespItem>>;

    /**
     * Get User Commission Rate for CM
     * @summary Get User Commission Rate for CM(USER_DATA)
     * @param {PortfolioMarginApiGetCmCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmCommissionRateV1(requestParameters: PortfolioMarginApiGetCmCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmCommissionRateV1Resp>;

    /**
     * Query All CM Conditional Orders
     * @summary Query All CM Conditional Orders(USER_DATA)
     * @param {PortfolioMarginApiGetCmConditionalAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmConditionalAllOrdersV1(requestParameters: PortfolioMarginApiGetCmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmConditionalAllOrdersV1RespItem>>;

    /**
     * Query Current CM Open Conditional Order
     * @summary Query Current CM Open Conditional Order(USER_DATA)
     * @param {PortfolioMarginApiGetCmConditionalOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmConditionalOpenOrderV1(requestParameters: PortfolioMarginApiGetCmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmConditionalOpenOrderV1Resp>;

    /**
     * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
     * @summary Query All Current CM Open Conditional Orders (USER_DATA)
     * @param {PortfolioMarginApiGetCmConditionalOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmConditionalOpenOrdersV1(requestParameters: PortfolioMarginApiGetCmConditionalOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmConditionalOpenOrdersV1RespItem>>;

    /**
     * Query CM Conditional Order History
     * @summary Query CM Conditional Order History(USER_DATA)
     * @param {PortfolioMarginApiGetCmConditionalOrderHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmConditionalOrderHistoryV1(requestParameters: PortfolioMarginApiGetCmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmConditionalOrderHistoryV1Resp>;

    /**
     * Query User\'s CM Force Orders
     * @summary Query User\'s CM Force Orders(USER_DATA)
     * @param {PortfolioMarginApiGetCmForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmForceOrdersV1(requestParameters: PortfolioMarginApiGetCmForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmForceOrdersV1RespItem>>;

    /**
     * Get CM Income History
     * @summary Get CM Income History(USER_DATA)
     * @param {PortfolioMarginApiGetCmIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmIncomeV1(requestParameters: PortfolioMarginApiGetCmIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmIncomeV1RespItem>>;

    /**
     * Query CM notional and leverage brackets
     * @summary CM Notional and Leverage Brackets(USER_DATA)
     * @param {PortfolioMarginApiGetCmLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmLeverageBracketV1(requestParameters: PortfolioMarginApiGetCmLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmLeverageBracketV1RespItem>>;

    /**
     * Query current CM open order
     * @summary Query Current CM Open Order (USER_DATA)
     * @param {PortfolioMarginApiGetCmOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmOpenOrderV1(requestParameters: PortfolioMarginApiGetCmOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol.
     * @summary Query All Current CM Open Orders(USER_DATA)
     * @param {PortfolioMarginApiGetCmOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmOpenOrdersV1(requestParameters: PortfolioMarginApiGetCmOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Query CM Modify Order History(TRADE)
     * @param {PortfolioMarginApiGetCmOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmOrderAmendmentV1(requestParameters: PortfolioMarginApiGetCmOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmOrderAmendmentV1RespItem>>;

    /**
     * Check an CM order\'s status.
     * @summary Query CM Order(USER_DATA)
     * @param {PortfolioMarginApiGetCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmOrderV1(requestParameters: PortfolioMarginApiGetCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmOrderV1Resp>;

    /**
     * Get current CM position information.
     * @summary Query CM Position Information(USER_DATA)
     * @param {PortfolioMarginApiGetCmPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmPositionRiskV1(requestParameters: PortfolioMarginApiGetCmPositionRiskV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmPositionRiskV1RespItem>>;

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * @summary Get CM Current Position Mode(USER_DATA)
     * @param {PortfolioMarginApiGetCmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmPositionSideDualV1(requestParameters: PortfolioMarginApiGetCmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCmPositionSideDualV1Resp>;

    /**
     * Get trades for a specific account and CM symbol.
     * @summary CM Account Trade List(USER_DATA)
     * @param {PortfolioMarginApiGetCmUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getCmUserTradesV1(requestParameters: PortfolioMarginApiGetCmUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCmUserTradesV1RespItem>>;

    /**
     * Query all OCO for a specific margin account based on provided optional parameters
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {PortfolioMarginApiGetMarginAllOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginAllOrderListV1(requestParameters: PortfolioMarginApiGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllOrderListV1RespItem>>;

    /**
     * Query All Margin Account Orders
     * @summary Query All Margin Account Orders (USER_DATA)
     * @param {PortfolioMarginApiGetMarginAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginAllOrdersV1(requestParameters: PortfolioMarginApiGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllOrdersV1RespItem>>;

    /**
     * Query user\'s margin force orders
     * @summary Query User\'s Margin Force Orders(USER_DATA)
     * @param {PortfolioMarginApiGetMarginForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginForceOrdersV1(requestParameters: PortfolioMarginApiGetMarginForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginForceOrdersV1Resp>;

    /**
     * Get Margin Borrow/Loan Interest History
     * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
     * @param {PortfolioMarginApiGetMarginMarginInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginMarginInterestHistoryV1(requestParameters: PortfolioMarginApiGetMarginMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMarginInterestHistoryV1Resp>;

    /**
     * Query margin loan record
     * @summary Query Margin Loan Record(USER_DATA)
     * @param {PortfolioMarginApiGetMarginMarginLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginMarginLoanV1(requestParameters: PortfolioMarginApiGetMarginMarginLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMarginLoanV1Resp>;

    /**
     * Query margin max borrow
     * @summary Margin Max Borrow(USER_DATA)
     * @param {PortfolioMarginApiGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginMaxBorrowableV1(requestParameters: PortfolioMarginApiGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMaxBorrowableV1Resp>;

    /**
     * Query Margin Max Withdraw
     * @summary Query Margin Max Withdraw(USER_DATA)
     * @param {PortfolioMarginApiGetMarginMaxWithdrawV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginMaxWithdrawV1(requestParameters: PortfolioMarginApiGetMarginMaxWithdrawV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMaxWithdrawV1Resp>;

    /**
     * Margin Account Trade List
     * @summary Margin Account Trade List (USER_DATA)
     * @param {PortfolioMarginApiGetMarginMyTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginMyTradesV1(requestParameters: PortfolioMarginApiGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginMyTradesV1RespItem>>;

    /**
     * Query Margin Account\'s Open OCO
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {PortfolioMarginApiGetMarginOpenOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginOpenOrderListV1(requestParameters: PortfolioMarginApiGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginOpenOrderListV1RespItem>>;

    /**
     * Query Current Margin Open Order
     * @summary Query Current Margin Open Order (USER_DATA)
     * @param {PortfolioMarginApiGetMarginOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginOpenOrdersV1(requestParameters: PortfolioMarginApiGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginOpenOrdersV1RespItem>>;

    /**
     * Retrieves a specific OCO based on provided optional parameters
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {PortfolioMarginApiGetMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginOrderListV1(requestParameters: PortfolioMarginApiGetMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginOrderListV1Resp>;

    /**
     * Query Margin Account Order
     * @summary Query Margin Account Order (USER_DATA)
     * @param {PortfolioMarginApiGetMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginOrderV1(requestParameters: PortfolioMarginApiGetMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginOrderV1Resp>;

    /**
     * Query margin repay record.
     * @summary Query Margin repay Record(USER_DATA)
     * @param {PortfolioMarginApiGetMarginRepayLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getMarginRepayLoanV1(requestParameters: PortfolioMarginApiGetMarginRepayLoanV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginRepayLoanV1Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Query interest history of negative balance for portfolio margin.
     * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     * @param {PortfolioMarginApiGetPortfolioInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getPortfolioInterestHistoryV1(requestParameters: PortfolioMarginApiGetPortfolioInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPortfolioInterestHistoryV1RespItem>>;

    /**
     * Query user negative balance auto exchange record
     * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
     * @param {PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getPortfolioNegativeBalanceExchangeRecordV1(requestParameters: PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPortfolioNegativeBalanceExchangeRecordV1Resp>;

    /**
     * Query User Rate Limit
     * @summary Query User Rate Limit (USER_DATA)
     * @param {PortfolioMarginApiGetRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getRateLimitOrderV1(requestParameters: PortfolioMarginApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRateLimitOrderV1RespItem>>;

    /**
     * Query Auto-repay-futures Status
     * @summary Get Auto-repay-futures Status(USER_DATA)
     * @param {PortfolioMarginApiGetRepayFuturesSwitchV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getRepayFuturesSwitchV1(requestParameters: PortfolioMarginApiGetRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetRepayFuturesSwitchV1Resp>;

    /**
     * Query UM Futures account configuration
     * @summary UM Futures Account Configuration(USER_DATA)
     * @param {PortfolioMarginApiGetUmAccountConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmAccountConfigV1(requestParameters: PortfolioMarginApiGetUmAccountConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmAccountConfigV1Resp>;

    /**
     * Get current UM account asset and position information.
     * @summary Get UM Account Detail(USER_DATA)
     * @param {PortfolioMarginApiGetUmAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmAccountV1(requestParameters: PortfolioMarginApiGetUmAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmAccountV1Resp>;

    /**
     * Get current UM account asset and position information.
     * @summary Get UM Account Detail V2(USER_DATA)
     * @param {PortfolioMarginApiGetUmAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmAccountV2(requestParameters: PortfolioMarginApiGetUmAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmAccountV2Resp>;

    /**
     * Query UM Position ADL Quantile Estimation
     * @summary UM Position ADL Quantile Estimation(USER_DATA)
     * @param {PortfolioMarginApiGetUmAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmAdlQuantileV1(requestParameters: PortfolioMarginApiGetUmAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmAdlQuantileV1RespItem>>;

    /**
     * Get all account UM orders; active, canceled, or filled.
     * @summary Query All UM Orders(USER_DATA)
     * @param {PortfolioMarginApiGetUmAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmAllOrdersV1(requestParameters: PortfolioMarginApiGetUmAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmAllOrdersV1RespItem>>;

    /**
     * Portfolio Margin UM Trading Quantitative Rules Indicators
     * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     * @param {PortfolioMarginApiGetUmApiTradingStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmApiTradingStatusV1(requestParameters: PortfolioMarginApiGetUmApiTradingStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmApiTradingStatusV1Resp>;

    /**
     * Get User Commission Rate for UM
     * @summary Get User Commission Rate for UM(USER_DATA)
     * @param {PortfolioMarginApiGetUmCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmCommissionRateV1(requestParameters: PortfolioMarginApiGetUmCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmCommissionRateV1Resp>;

    /**
     * Query All UM Conditional Orders
     * @summary Query All UM Conditional Orders(USER_DATA)
     * @param {PortfolioMarginApiGetUmConditionalAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmConditionalAllOrdersV1(requestParameters: PortfolioMarginApiGetUmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmConditionalAllOrdersV1RespItem>>;

    /**
     * Query Current UM Open Conditional Order
     * @summary Query Current UM Open Conditional Order(USER_DATA)
     * @param {PortfolioMarginApiGetUmConditionalOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmConditionalOpenOrderV1(requestParameters: PortfolioMarginApiGetUmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmConditionalOpenOrderV1Resp>;

    /**
     * Get all open conditional orders on a symbol.
     * @summary Query All Current UM Open Conditional Orders(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmConditionalOpenOrdersV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmConditionalOpenOrdersV1RespItem>>;

    /**
     * Query UM Conditional Order History
     * @summary Query UM Conditional Order History(USER_DATA)
     * @param {PortfolioMarginApiGetUmConditionalOrderHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmConditionalOrderHistoryV1(requestParameters: PortfolioMarginApiGetUmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmConditionalOrderHistoryV1Resp>;

    /**
     * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
     * @summary Get UM Futures BNB Burn Status (USER_DATA)
     * @param {PortfolioMarginApiGetUmFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmFeeBurnV1(requestParameters: PortfolioMarginApiGetUmFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmFeeBurnV1Resp>;

    /**
     * Query User\'s UM Force Orders
     * @summary Query User\'s UM Force Orders (USER_DATA)
     * @param {PortfolioMarginApiGetUmForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmForceOrdersV1(requestParameters: PortfolioMarginApiGetUmForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmForceOrdersV1RespItem>>;

    /**
     * Get UM futures Transaction download link by Id
     * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
     * @param {PortfolioMarginApiGetUmIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmIncomeAsynIdV1(requestParameters: PortfolioMarginApiGetUmIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmIncomeAsynIdV1Resp>;

    /**
     * Get download id for UM futures transaction history
     * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
     * @param {PortfolioMarginApiGetUmIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmIncomeAsynV1(requestParameters: PortfolioMarginApiGetUmIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmIncomeAsynV1Resp>;

    /**
     * Get UM Income History
     * @summary Get UM Income History(USER_DATA)
     * @param {PortfolioMarginApiGetUmIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmIncomeV1(requestParameters: PortfolioMarginApiGetUmIncomeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmIncomeV1RespItem>>;

    /**
     * Query UM notional and leverage brackets
     * @summary UM Notional and Leverage Brackets (USER_DATA)
     * @param {PortfolioMarginApiGetUmLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmLeverageBracketV1(requestParameters: PortfolioMarginApiGetUmLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmLeverageBracketV1RespItem>>;

    /**
     * Query current UM open order
     * @summary Query Current UM Open Order(USER_DATA)
     * @param {PortfolioMarginApiGetUmOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmOpenOrderV1(requestParameters: PortfolioMarginApiGetUmOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol.
     * @summary Query All Current UM Open Orders(USER_DATA)
     * @param {PortfolioMarginApiGetUmOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmOpenOrdersV1(requestParameters: PortfolioMarginApiGetUmOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Query UM Modify Order History(TRADE)
     * @param {PortfolioMarginApiGetUmOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmOrderAmendmentV1(requestParameters: PortfolioMarginApiGetUmOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmOrderAmendmentV1RespItem>>;

    /**
     * Get UM futures order download link by Id
     * @summary Get UM Futures Order Download Link by Id(USER_DATA)
     * @param {PortfolioMarginApiGetUmOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmOrderAsynIdV1(requestParameters: PortfolioMarginApiGetUmOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmOrderAsynIdV1Resp>;

    /**
     * Get download id for UM futures order history
     * @summary Get Download Id For UM Futures Order History (USER_DATA)
     * @param {PortfolioMarginApiGetUmOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmOrderAsynV1(requestParameters: PortfolioMarginApiGetUmOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmOrderAsynV1Resp>;

    /**
     * Check an UM order\'s status.
     * @summary Query UM Order (USER_DATA)
     * @param {PortfolioMarginApiGetUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmOrderV1(requestParameters: PortfolioMarginApiGetUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmOrderV1Resp>;

    /**
     * Get current UM position information.
     * @summary Query UM Position Information(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmPositionRiskV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmPositionRiskV1RespItem>>;

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * @summary Get UM Current Position Mode(USER_DATA)
     * @param {PortfolioMarginApiGetUmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmPositionSideDualV1(requestParameters: PortfolioMarginApiGetUmPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmPositionSideDualV1Resp>;

    /**
     * Get current UM account symbol configuration.
     * @summary UM Futures Symbol Configuration(USER_DATA)
     * @param {PortfolioMarginApiGetUmSymbolConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmSymbolConfigV1(requestParameters: PortfolioMarginApiGetUmSymbolConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmSymbolConfigV1RespItem>>;

    /**
     * Get UM futures trade download link by Id
     * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
     * @param {PortfolioMarginApiGetUmTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmTradeAsynIdV1(requestParameters: PortfolioMarginApiGetUmTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmTradeAsynIdV1Resp>;

    /**
     * Get download id for UM futures trade history
     * @summary Get Download Id For UM Futures Trade History (USER_DATA)
     * @param {PortfolioMarginApiGetUmTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmTradeAsynV1(requestParameters: PortfolioMarginApiGetUmTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetUmTradeAsynV1Resp>;

    /**
     * Get trades for a specific account and UM symbol.
     * @summary UM Account Trade List(USER_DATA)
     * @param {PortfolioMarginApiGetUmUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    getUmUserTradesV1(requestParameters: PortfolioMarginApiGetUmUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUmUserTradesV1RespItem>>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify CM Order(TRADE)
     * @param {PortfolioMarginApiUpdateCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    updateCmOrderV1(requestParameters: PortfolioMarginApiUpdateCmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateCmOrderV1Resp>;

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify UM Order(TRADE)
     * @param {PortfolioMarginApiUpdateUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApiInterface
     */
    updateUmOrderV1(requestParameters: PortfolioMarginApiUpdateUmOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateUmOrderV1Resp>;

}

/**
 * Request parameters for createAssetCollectionV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateAssetCollectionV1Request
 */
export interface PortfolioMarginApiCreateAssetCollectionV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateAssetCollectionV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateAssetCollectionV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateAssetCollectionV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createAutoCollectionV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateAutoCollectionV1Request
 */
export interface PortfolioMarginApiCreateAutoCollectionV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateAutoCollectionV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateAutoCollectionV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createBnbTransferV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateBnbTransferV1Request
 */
export interface PortfolioMarginApiCreateBnbTransferV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateBnbTransferV1
     */
    readonly amount: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateBnbTransferV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateBnbTransferV1
     */
    readonly transferSide: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateBnbTransferV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createCmConditionalOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateCmConditionalOrderV1Request
 */
export interface PortfolioMarginApiCreateCmConditionalOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly strategyType: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmConditionalOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for createCmLeverageV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateCmLeverageV1Request
 */
export interface PortfolioMarginApiCreateCmLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createCmOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateCmOrderV1Request
 */
export interface PortfolioMarginApiCreateCmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for createCmPositionSideDualV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateCmPositionSideDualV1Request
 */
export interface PortfolioMarginApiCreateCmPositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateCmPositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateCmPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginLoanV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateMarginLoanV1Request
 */
export interface PortfolioMarginApiCreateMarginLoanV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginLoanV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginLoanV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateMarginLoanV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateMarginLoanV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginOrderOcoV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateMarginOrderOcoV1Request
 */
export interface PortfolioMarginApiCreateMarginOrderOcoV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly stopPrice: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly limitClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly limitIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly sideEffectType?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly stopClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly stopIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly stopLimitPrice?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderOcoV1
     */
    readonly stopLimitTimeInForce?: string
}

/**
 * Request parameters for createMarginOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateMarginOrderV1Request
 */
export interface PortfolioMarginApiCreateMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {boolean}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly autoRepayAtCancel?: boolean

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly sideEffectType?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for createMarginRepayDebtV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateMarginRepayDebtV1Request
 */
export interface PortfolioMarginApiCreateMarginRepayDebtV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginRepayDebtV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateMarginRepayDebtV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginRepayDebtV1
     */
    readonly amount?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateMarginRepayDebtV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateMarginRepayDebtV1
     */
    readonly specifyRepayAssets?: string
}

/**
 * Request parameters for createRepayFuturesNegativeBalanceV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1Request
 */
export interface PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createRepayFuturesSwitchV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateRepayFuturesSwitchV1Request
 */
export interface PortfolioMarginApiCreateRepayFuturesSwitchV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateRepayFuturesSwitchV1
     */
    readonly autoRepay: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateRepayFuturesSwitchV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateRepayFuturesSwitchV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createRepayLoanV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateRepayLoanV1Request
 */
export interface PortfolioMarginApiCreateRepayLoanV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateRepayLoanV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateRepayLoanV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateRepayLoanV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateRepayLoanV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createUmConditionalOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateUmConditionalOrderV1Request
 */
export interface PortfolioMarginApiCreateUmConditionalOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly strategyType: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmConditionalOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for createUmFeeBurnV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateUmFeeBurnV1Request
 */
export interface PortfolioMarginApiCreateUmFeeBurnV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmFeeBurnV1
     */
    readonly feeBurn: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmFeeBurnV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmFeeBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createUmLeverageV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateUmLeverageV1Request
 */
export interface PortfolioMarginApiCreateUmLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createUmOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateUmOrderV1Request
 */
export interface PortfolioMarginApiCreateUmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for createUmPositionSideDualV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiCreateUmPositionSideDualV1Request
 */
export interface PortfolioMarginApiCreateUmPositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiCreateUmPositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiCreateUmPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteCmAllOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteCmAllOpenOrdersV1Request
 */
export interface PortfolioMarginApiDeleteCmAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteCmAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteCmConditionalAllOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1Request
 */
export interface PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteCmConditionalOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteCmConditionalOrderV1Request
 */
export interface PortfolioMarginApiDeleteCmConditionalOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteCmConditionalOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmConditionalOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmConditionalOrderV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteCmConditionalOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmConditionalOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteCmOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteCmOrderV1Request
 */
export interface PortfolioMarginApiDeleteCmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteCmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteCmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteCmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteMarginAllOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteMarginAllOpenOrdersV1Request
 */
export interface PortfolioMarginApiDeleteMarginAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteMarginAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteMarginAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiDeleteMarginAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteMarginOrderListV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteMarginOrderListV1Request
 */
export interface PortfolioMarginApiDeleteMarginOrderListV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteMarginOrderListV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteMarginOrderListV1
     */
    readonly timestamp: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {number}
     * @memberof PortfolioMarginApiDeleteMarginOrderListV1
     */
    readonly orderListId?: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {string}
     * @memberof PortfolioMarginApiDeleteMarginOrderListV1
     */
    readonly listClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof PortfolioMarginApiDeleteMarginOrderListV1
     */
    readonly newClientOrderId?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiDeleteMarginOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteMarginOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteMarginOrderV1Request
 */
export interface PortfolioMarginApiDeleteMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteMarginOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteMarginOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteMarginOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default.
     * @type {string}
     * @memberof PortfolioMarginApiDeleteMarginOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof PortfolioMarginApiDeleteMarginOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteUmAllOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteUmAllOpenOrdersV1Request
 */
export interface PortfolioMarginApiDeleteUmAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteUmAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteUmConditionalAllOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1Request
 */
export interface PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteUmConditionalOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteUmConditionalOrderV1Request
 */
export interface PortfolioMarginApiDeleteUmConditionalOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteUmConditionalOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmConditionalOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmConditionalOrderV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteUmConditionalOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmConditionalOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteUmOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiDeleteUmOrderV1Request
 */
export interface PortfolioMarginApiDeleteUmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteUmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiDeleteUmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiDeleteUmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetAccountV1Request
 */
export interface PortfolioMarginApiGetAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBalanceV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetBalanceV1Request
 */
export interface PortfolioMarginApiGetBalanceV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetBalanceV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetBalanceV1
     */
    readonly asset?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetBalanceV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmAccountV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmAccountV1Request
 */
export interface PortfolioMarginApiGetCmAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmAllOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmAllOrdersV1Request
 */
export interface PortfolioMarginApiGetCmAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmAllOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof PortfolioMarginApiGetCmAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmCommissionRateV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmCommissionRateV1Request
 */
export interface PortfolioMarginApiGetCmCommissionRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmCommissionRateV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmCommissionRateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmCommissionRateV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmConditionalAllOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmConditionalAllOrdersV1Request
 */
export interface PortfolioMarginApiGetCmConditionalAllOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmConditionalAllOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalAllOrdersV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmConditionalOpenOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmConditionalOpenOrderV1Request
 */
export interface PortfolioMarginApiGetCmConditionalOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmConditionalOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalOpenOrderV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmConditionalOpenOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmConditionalOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmConditionalOpenOrdersV1Request
 */
export interface PortfolioMarginApiGetCmConditionalOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmConditionalOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmConditionalOrderHistoryV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmConditionalOrderHistoryV1Request
 */
export interface PortfolioMarginApiGetCmConditionalOrderHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmConditionalOrderHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalOrderHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalOrderHistoryV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmConditionalOrderHistoryV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmConditionalOrderHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmForceOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmForceOrdersV1Request
 */
export interface PortfolioMarginApiGetCmForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmForceOrdersV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
     * @type {string}
     * @memberof PortfolioMarginApiGetCmForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof PortfolioMarginApiGetCmForceOrdersV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetCmForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmIncomeV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmIncomeV1Request
 */
export interface PortfolioMarginApiGetCmIncomeV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmIncomeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmIncomeV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
     * @type {string}
     * @memberof PortfolioMarginApiGetCmIncomeV1
     */
    readonly incomeType?: string

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number}
     * @memberof PortfolioMarginApiGetCmIncomeV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number}
     * @memberof PortfolioMarginApiGetCmIncomeV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmIncomeV1
     */
    readonly page?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof PortfolioMarginApiGetCmIncomeV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmIncomeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmLeverageBracketV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmLeverageBracketV1Request
 */
export interface PortfolioMarginApiGetCmLeverageBracketV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmLeverageBracketV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmLeverageBracketV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmLeverageBracketV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmOpenOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmOpenOrderV1Request
 */
export interface PortfolioMarginApiGetCmOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmOpenOrdersV1Request
 */
export interface PortfolioMarginApiGetCmOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmOpenOrdersV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmOrderAmendmentV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmOrderAmendmentV1Request
 */
export interface PortfolioMarginApiGetCmOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 50, max 100
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmOrderV1Request
 */
export interface PortfolioMarginApiGetCmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmPositionRiskV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmPositionRiskV1Request
 */
export interface PortfolioMarginApiGetCmPositionRiskV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmPositionRiskV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmPositionRiskV1
     */
    readonly marginAsset?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmPositionRiskV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmPositionRiskV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmPositionSideDualV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmPositionSideDualV1Request
 */
export interface PortfolioMarginApiGetCmPositionSideDualV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCmUserTradesV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetCmUserTradesV1Request
 */
export interface PortfolioMarginApiGetCmUserTradesV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmUserTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmUserTradesV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetCmUserTradesV1
     */
    readonly pair?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof PortfolioMarginApiGetCmUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 50; max 1000.
     * @type {number}
     * @memberof PortfolioMarginApiGetCmUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetCmUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginAllOrderListV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginAllOrderListV1Request
 */
export interface PortfolioMarginApiGetMarginAllOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrderListV1
     */
    readonly timestamp: number

    /**
     * If supplied, neither startTime or endTime can be provided
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrderListV1
     */
    readonly fromId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrderListV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrderListV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 500.
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrderListV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginAllOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginAllOrdersV1Request
 */
export interface PortfolioMarginApiGetMarginAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 500.
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrdersV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginForceOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginForceOrdersV1Request
 */
export interface PortfolioMarginApiGetMarginForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginForceOrdersV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginForceOrdersV1
     */
    readonly size?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginMarginInterestHistoryV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginMarginInterestHistoryV1Request
 */
export interface PortfolioMarginApiGetMarginMarginInterestHistoryV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginInterestHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginMarginInterestHistoryV1
     */
    readonly asset?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginInterestHistoryV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginInterestHistoryV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginInterestHistoryV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginInterestHistoryV1
     */
    readonly size?: number

    /**
     * Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginMarginInterestHistoryV1
     */
    readonly archived?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginInterestHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginMarginLoanV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginMarginLoanV1Request
 */
export interface PortfolioMarginApiGetMarginMarginLoanV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly timestamp: number

    /**
     * the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60;
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly txId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly size?: number

    /**
     * Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly archived?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMarginLoanV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginMaxBorrowableV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginMaxBorrowableV1Request
 */
export interface PortfolioMarginApiGetMarginMaxBorrowableV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginMaxBorrowableV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMaxBorrowableV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMaxBorrowableV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginMaxWithdrawV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginMaxWithdrawV1Request
 */
export interface PortfolioMarginApiGetMarginMaxWithdrawV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginMaxWithdrawV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMaxWithdrawV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMaxWithdrawV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginMyTradesV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginMyTradesV1Request
 */
export interface PortfolioMarginApiGetMarginMyTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginMyTradesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMyTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMyTradesV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMyTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMyTradesV1
     */
    readonly endTime?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMyTradesV1
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMyTradesV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginMyTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginOpenOrderListV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginOpenOrderListV1Request
 */
export interface PortfolioMarginApiGetMarginOpenOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOpenOrderListV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOpenOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginOpenOrdersV1Request
 */
export interface PortfolioMarginApiGetMarginOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginOrderListV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginOrderListV1Request
 */
export interface PortfolioMarginApiGetMarginOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOrderListV1
     */
    readonly timestamp: number

    /**
     * Either orderListId or origClientOrderId must be provided
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOrderListV1
     */
    readonly orderListId?: number

    /**
     * Either orderListId or origClientOrderId must be provided
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginOrderListV1
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginOrderV1Request
 */
export interface PortfolioMarginApiGetMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginRepayLoanV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetMarginRepayLoanV1Request
 */
export interface PortfolioMarginApiGetMarginRepayLoanV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly timestamp: number

    /**
     * the tranId in &#x60;POST/papi/v1/repayLoan&#x60;
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly txId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly size?: number

    /**
     * Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
     * @type {string}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly archived?: string

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetMarginRepayLoanV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPortfolioInterestHistoryV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetPortfolioInterestHistoryV1Request
 */
export interface PortfolioMarginApiGetPortfolioInterestHistoryV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioInterestHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetPortfolioInterestHistoryV1
     */
    readonly asset?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioInterestHistoryV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioInterestHistoryV1
     */
    readonly endTime?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioInterestHistoryV1
     */
    readonly size?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioInterestHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPortfolioNegativeBalanceExchangeRecordV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1Request
 */
export interface PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1
     */
    readonly startTime: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getRateLimitOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetRateLimitOrderV1Request
 */
export interface PortfolioMarginApiGetRateLimitOrderV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetRateLimitOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetRateLimitOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getRepayFuturesSwitchV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetRepayFuturesSwitchV1Request
 */
export interface PortfolioMarginApiGetRepayFuturesSwitchV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetRepayFuturesSwitchV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetRepayFuturesSwitchV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmAccountConfigV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmAccountConfigV1Request
 */
export interface PortfolioMarginApiGetUmAccountConfigV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAccountConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAccountConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmAccountV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmAccountV1Request
 */
export interface PortfolioMarginApiGetUmAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmAccountV2 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmAccountV2Request
 */
export interface PortfolioMarginApiGetUmAccountV2Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAccountV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAccountV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmAdlQuantileV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmAdlQuantileV1Request
 */
export interface PortfolioMarginApiGetUmAdlQuantileV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAdlQuantileV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmAdlQuantileV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAdlQuantileV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmAllOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmAllOrdersV1Request
 */
export interface PortfolioMarginApiGetUmAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmApiTradingStatusV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmApiTradingStatusV1Request
 */
export interface PortfolioMarginApiGetUmApiTradingStatusV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmApiTradingStatusV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmApiTradingStatusV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmApiTradingStatusV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmCommissionRateV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmCommissionRateV1Request
 */
export interface PortfolioMarginApiGetUmCommissionRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmCommissionRateV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmCommissionRateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmCommissionRateV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmConditionalAllOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmConditionalAllOrdersV1Request
 */
export interface PortfolioMarginApiGetUmConditionalAllOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmConditionalAllOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalAllOrdersV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmConditionalOpenOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmConditionalOpenOrderV1Request
 */
export interface PortfolioMarginApiGetUmConditionalOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmConditionalOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalOpenOrderV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmConditionalOpenOrderV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmConditionalOrderHistoryV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmConditionalOrderHistoryV1Request
 */
export interface PortfolioMarginApiGetUmConditionalOrderHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmConditionalOrderHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalOrderHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalOrderHistoryV1
     */
    readonly strategyId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmConditionalOrderHistoryV1
     */
    readonly newClientStrategyId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmConditionalOrderHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmFeeBurnV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmFeeBurnV1Request
 */
export interface PortfolioMarginApiGetUmFeeBurnV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmFeeBurnV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmFeeBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmForceOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmForceOrdersV1Request
 */
export interface PortfolioMarginApiGetUmForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmForceOrdersV1
     */
    readonly symbol?: string

    /**
     * &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders.
     * @type {string}
     * @memberof PortfolioMarginApiGetUmForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof PortfolioMarginApiGetUmForceOrdersV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof PortfolioMarginApiGetUmForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmIncomeAsynIdV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmIncomeAsynIdV1Request
 */
export interface PortfolioMarginApiGetUmIncomeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof PortfolioMarginApiGetUmIncomeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmIncomeAsynV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmIncomeAsynV1Request
 */
export interface PortfolioMarginApiGetUmIncomeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmIncomeV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmIncomeV1Request
 */
export interface PortfolioMarginApiGetUmIncomeV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmIncomeV1
     */
    readonly symbol?: string

    /**
     * TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
     * @type {string}
     * @memberof PortfolioMarginApiGetUmIncomeV1
     */
    readonly incomeType?: string

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeV1
     */
    readonly page?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmIncomeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmLeverageBracketV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmLeverageBracketV1Request
 */
export interface PortfolioMarginApiGetUmLeverageBracketV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmLeverageBracketV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmLeverageBracketV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmLeverageBracketV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmOpenOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmOpenOrderV1Request
 */
export interface PortfolioMarginApiGetUmOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmOpenOrdersV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmOpenOrdersV1Request
 */
export interface PortfolioMarginApiGetUmOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmOrderAmendmentV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmOrderAmendmentV1Request
 */
export interface PortfolioMarginApiGetUmOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 500, max 1000
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmOrderAsynIdV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmOrderAsynIdV1Request
 */
export interface PortfolioMarginApiGetUmOrderAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof PortfolioMarginApiGetUmOrderAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmOrderAsynV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmOrderAsynV1Request
 */
export interface PortfolioMarginApiGetUmOrderAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmOrderV1Request
 */
export interface PortfolioMarginApiGetUmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmPositionSideDualV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmPositionSideDualV1Request
 */
export interface PortfolioMarginApiGetUmPositionSideDualV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmSymbolConfigV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmSymbolConfigV1Request
 */
export interface PortfolioMarginApiGetUmSymbolConfigV1Request {
    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmSymbolConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmSymbolConfigV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmSymbolConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmTradeAsynIdV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmTradeAsynIdV1Request
 */
export interface PortfolioMarginApiGetUmTradeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof PortfolioMarginApiGetUmTradeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmTradeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmTradeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmTradeAsynV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmTradeAsynV1Request
 */
export interface PortfolioMarginApiGetUmTradeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof PortfolioMarginApiGetUmTradeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof PortfolioMarginApiGetUmTradeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmTradeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmTradeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getUmUserTradesV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiGetUmUserTradesV1Request
 */
export interface PortfolioMarginApiGetUmUserTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiGetUmUserTradesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmUserTradesV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof PortfolioMarginApiGetUmUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof PortfolioMarginApiGetUmUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiGetUmUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateCmOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiUpdateCmOrderV1Request
 */
export interface PortfolioMarginApiUpdateCmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiUpdateCmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateUmOrderV1 operation in PortfolioMarginApi.
 * @export
 * @interface PortfolioMarginApiUpdateUmOrderV1Request
 */
export interface PortfolioMarginApiUpdateUmOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {number}
     * @memberof PortfolioMarginApiUpdateUmOrderV1
     */
    readonly recvWindow?: number
}

/**
 * PortfolioMarginApi - object-oriented interface
 * @export
 * @class PortfolioMarginApi
 * @extends {BaseAPI}
 */
export class PortfolioMarginApi extends BaseAPI implements PortfolioMarginApiInterface {
    /**
     * Transfers specific asset from Futures Account to Margin account
     * @summary Fund Collection by Asset(TRADE)
     * @param {PortfolioMarginApiCreateAssetCollectionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createAssetCollectionV1(requestParameters: PortfolioMarginApiCreateAssetCollectionV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createAssetCollectionV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fund collection for Portfolio Margin
     * @summary Fund Auto-collection(TRADE)
     * @param {PortfolioMarginApiCreateAutoCollectionV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createAutoCollectionV1(requestParameters: PortfolioMarginApiCreateAutoCollectionV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createAutoCollectionV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfer BNB in and out of UM
     * @summary BNB transfer (TRADE)
     * @param {PortfolioMarginApiCreateBnbTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createBnbTransferV1(requestParameters: PortfolioMarginApiCreateBnbTransferV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createBnbTransferV1(requestParameters.amount, requestParameters.timestamp, requestParameters.transferSide, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * New CM Conditional Order
     * @summary New CM Conditional Order(TRADE)
     * @param {PortfolioMarginApiCreateCmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createCmConditionalOrderV1(requestParameters: PortfolioMarginApiCreateCmConditionalOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createCmConditionalOrderV1(requestParameters.side, requestParameters.strategyType, requestParameters.symbol, requestParameters.timestamp, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.newClientStrategyId, requestParameters.positionSide, requestParameters.price, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage of specific symbol in CM.
     * @summary Change CM Initial Leverage (TRADE)
     * @param {PortfolioMarginApiCreateCmLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createCmLeverageV1(requestParameters: PortfolioMarginApiCreateCmLeverageV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createCmLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place new CM order
     * @summary New CM Order(TRADE)
     * @param {PortfolioMarginApiCreateCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createCmOrderV1(requestParameters: PortfolioMarginApiCreateCmOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createCmOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * @summary Change CM Position Mode(TRADE)
     * @param {PortfolioMarginApiCreateCmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createCmPositionSideDualV1(requestParameters: PortfolioMarginApiCreateCmPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createCmPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream(USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createListenKeyV1(options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply for a margin loan.
     * @summary Margin Account Borrow(MARGIN)
     * @param {PortfolioMarginApiCreateMarginLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createMarginLoanV1(requestParameters: PortfolioMarginApiCreateMarginLoanV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createMarginLoanV1(requestParameters.amount, requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new OCO for a margin account
     * @summary Margin Account New OCO(TRADE)
     * @param {PortfolioMarginApiCreateMarginOrderOcoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createMarginOrderOcoV1(requestParameters: PortfolioMarginApiCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createMarginOrderOcoV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.sideEffectType, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * New Margin Order
     * @summary New Margin Order(TRADE)
     * @param {PortfolioMarginApiCreateMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createMarginOrderV1(requestParameters: PortfolioMarginApiCreateMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createMarginOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.autoRepayAtCancel, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.stopPrice, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Repay debt for a margin loan.
     * @summary Margin Account Repay Debt(TRADE)
     * @param {PortfolioMarginApiCreateMarginRepayDebtV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createMarginRepayDebtV1(requestParameters: PortfolioMarginApiCreateMarginRepayDebtV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createMarginRepayDebtV1(requestParameters.asset, requestParameters.timestamp, requestParameters.amount, requestParameters.recvWindow, requestParameters.specifyRepayAssets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Repay futures Negative Balance
     * @summary Repay futures Negative Balance(USER_DATA)
     * @param {PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createRepayFuturesNegativeBalanceV1(requestParameters: PortfolioMarginApiCreateRepayFuturesNegativeBalanceV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createRepayFuturesNegativeBalanceV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change Auto-repay-futures Status
     * @summary Change Auto-repay-futures Status(TRADE)
     * @param {PortfolioMarginApiCreateRepayFuturesSwitchV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createRepayFuturesSwitchV1(requestParameters: PortfolioMarginApiCreateRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createRepayFuturesSwitchV1(requestParameters.autoRepay, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Repay for a margin loan.
     * @summary Margin Account Repay(MARGIN)
     * @param {PortfolioMarginApiCreateRepayLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createRepayLoanV1(requestParameters: PortfolioMarginApiCreateRepayLoanV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createRepayLoanV1(requestParameters.amount, requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place new UM conditional order
     * @summary New UM Conditional Order (TRADE)
     * @param {PortfolioMarginApiCreateUmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createUmConditionalOrderV1(requestParameters: PortfolioMarginApiCreateUmConditionalOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createUmConditionalOrderV1(requestParameters.side, requestParameters.strategyType, requestParameters.symbol, requestParameters.timestamp, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.goodTillDate, requestParameters.newClientStrategyId, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
     * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
     * @param {PortfolioMarginApiCreateUmFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createUmFeeBurnV1(requestParameters: PortfolioMarginApiCreateUmFeeBurnV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createUmFeeBurnV1(requestParameters.feeBurn, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage of specific symbol in UM.
     * @summary Change UM Initial Leverage(TRADE)
     * @param {PortfolioMarginApiCreateUmLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createUmLeverageV1(requestParameters: PortfolioMarginApiCreateUmLeverageV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createUmLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place new UM order
     * @summary New UM Order (TRADE)
     * @param {PortfolioMarginApiCreateUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createUmOrderV1(requestParameters: PortfolioMarginApiCreateUmOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createUmOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * @summary Change UM Position Mode(TRADE)
     * @param {PortfolioMarginApiCreateUmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public createUmPositionSideDualV1(requestParameters: PortfolioMarginApiCreateUmPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).createUmPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all active LIMIT orders on specific symbol
     * @summary Cancel All CM Open Orders(TRADE)
     * @param {PortfolioMarginApiDeleteCmAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteCmAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteCmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteCmAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All CM Open Conditional Orders
     * @summary Cancel All CM Open Conditional Orders(TRADE)
     * @param {PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteCmConditionalAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteCmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteCmConditionalAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel CM Conditional Order
     * @summary Cancel CM Conditional Order(TRADE)
     * @param {PortfolioMarginApiDeleteCmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteCmConditionalOrderV1(requestParameters: PortfolioMarginApiDeleteCmConditionalOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteCmConditionalOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active LIMIT order
     * @summary Cancel CM Order(TRADE)
     * @param {PortfolioMarginApiDeleteCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteCmOrderV1(requestParameters: PortfolioMarginApiDeleteCmOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteCmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream(USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteListenKeyV1(options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Margin Account All Open Orders on a Symbol
     * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
     * @param {PortfolioMarginApiDeleteMarginAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteMarginAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteMarginAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteMarginAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Margin Account OCO Orders
     * @summary Cancel Margin Account OCO Orders(TRADE)
     * @param {PortfolioMarginApiDeleteMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteMarginOrderListV1(requestParameters: PortfolioMarginApiDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteMarginOrderListV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Margin Account Order
     * @summary Cancel Margin Account Order(TRADE)
     * @param {PortfolioMarginApiDeleteMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteMarginOrderV1(requestParameters: PortfolioMarginApiDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all active LIMIT orders on specific symbol
     * @summary Cancel All UM Open Orders(TRADE)
     * @param {PortfolioMarginApiDeleteUmAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteUmAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteUmAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteUmAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All UM Open Conditional Orders
     * @summary Cancel All UM Open Conditional Orders (TRADE)
     * @param {PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteUmConditionalAllOpenOrdersV1(requestParameters: PortfolioMarginApiDeleteUmConditionalAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteUmConditionalAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel UM Conditional Order
     * @summary Cancel UM Conditional Order(TRADE)
     * @param {PortfolioMarginApiDeleteUmConditionalOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteUmConditionalOrderV1(requestParameters: PortfolioMarginApiDeleteUmConditionalOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteUmConditionalOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active UM LIMIT order
     * @summary Cancel UM Order(TRADE)
     * @param {PortfolioMarginApiDeleteUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public deleteUmOrderV1(requestParameters: PortfolioMarginApiDeleteUmOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).deleteUmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account information
     * @summary Account Information(USER_DATA)
     * @param {PortfolioMarginApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getAccountV1(requestParameters: PortfolioMarginApiGetAccountV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account balance
     * @summary Account Balance(USER_DATA)
     * @param {PortfolioMarginApiGetBalanceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getBalanceV1(requestParameters: PortfolioMarginApiGetBalanceV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getBalanceV1(requestParameters.timestamp, requestParameters.asset, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current CM account asset and position information.
     * @summary Get CM Account Detail(USER_DATA)
     * @param {PortfolioMarginApiGetCmAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmAccountV1(requestParameters: PortfolioMarginApiGetCmAccountV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query CM Position ADL Quantile Estimation
     * @summary CM Position ADL Quantile Estimation(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmAdlQuantileV1(options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmAdlQuantileV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account CM orders; active, canceled, or filled.
     * @summary Query All CM Orders (USER_DATA)
     * @param {PortfolioMarginApiGetCmAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmAllOrdersV1(requestParameters: PortfolioMarginApiGetCmAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.pair, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get User Commission Rate for CM
     * @summary Get User Commission Rate for CM(USER_DATA)
     * @param {PortfolioMarginApiGetCmCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmCommissionRateV1(requestParameters: PortfolioMarginApiGetCmCommissionRateV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query All CM Conditional Orders
     * @summary Query All CM Conditional Orders(USER_DATA)
     * @param {PortfolioMarginApiGetCmConditionalAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmConditionalAllOrdersV1(requestParameters: PortfolioMarginApiGetCmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmConditionalAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.strategyId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current CM Open Conditional Order
     * @summary Query Current CM Open Conditional Order(USER_DATA)
     * @param {PortfolioMarginApiGetCmConditionalOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmConditionalOpenOrderV1(requestParameters: PortfolioMarginApiGetCmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmConditionalOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
     * @summary Query All Current CM Open Conditional Orders (USER_DATA)
     * @param {PortfolioMarginApiGetCmConditionalOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmConditionalOpenOrdersV1(requestParameters: PortfolioMarginApiGetCmConditionalOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmConditionalOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query CM Conditional Order History
     * @summary Query CM Conditional Order History(USER_DATA)
     * @param {PortfolioMarginApiGetCmConditionalOrderHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmConditionalOrderHistoryV1(requestParameters: PortfolioMarginApiGetCmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmConditionalOrderHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query User\'s CM Force Orders
     * @summary Query User\'s CM Force Orders(USER_DATA)
     * @param {PortfolioMarginApiGetCmForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmForceOrdersV1(requestParameters: PortfolioMarginApiGetCmForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CM Income History
     * @summary Get CM Income History(USER_DATA)
     * @param {PortfolioMarginApiGetCmIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmIncomeV1(requestParameters: PortfolioMarginApiGetCmIncomeV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query CM notional and leverage brackets
     * @summary CM Notional and Leverage Brackets(USER_DATA)
     * @param {PortfolioMarginApiGetCmLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmLeverageBracketV1(requestParameters: PortfolioMarginApiGetCmLeverageBracketV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query current CM open order
     * @summary Query Current CM Open Order (USER_DATA)
     * @param {PortfolioMarginApiGetCmOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmOpenOrderV1(requestParameters: PortfolioMarginApiGetCmOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol.
     * @summary Query All Current CM Open Orders(USER_DATA)
     * @param {PortfolioMarginApiGetCmOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmOpenOrdersV1(requestParameters: PortfolioMarginApiGetCmOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Query CM Modify Order History(TRADE)
     * @param {PortfolioMarginApiGetCmOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmOrderAmendmentV1(requestParameters: PortfolioMarginApiGetCmOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an CM order\'s status.
     * @summary Query CM Order(USER_DATA)
     * @param {PortfolioMarginApiGetCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmOrderV1(requestParameters: PortfolioMarginApiGetCmOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current CM position information.
     * @summary Query CM Position Information(USER_DATA)
     * @param {PortfolioMarginApiGetCmPositionRiskV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmPositionRiskV1(requestParameters: PortfolioMarginApiGetCmPositionRiskV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmPositionRiskV1(requestParameters.timestamp, requestParameters.marginAsset, requestParameters.pair, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * @summary Get CM Current Position Mode(USER_DATA)
     * @param {PortfolioMarginApiGetCmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmPositionSideDualV1(requestParameters: PortfolioMarginApiGetCmPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and CM symbol.
     * @summary CM Account Trade List(USER_DATA)
     * @param {PortfolioMarginApiGetCmUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getCmUserTradesV1(requestParameters: PortfolioMarginApiGetCmUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getCmUserTradesV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.pair, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query all OCO for a specific margin account based on provided optional parameters
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {PortfolioMarginApiGetMarginAllOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginAllOrderListV1(requestParameters: PortfolioMarginApiGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginAllOrderListV1(requestParameters.timestamp, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query All Margin Account Orders
     * @summary Query All Margin Account Orders (USER_DATA)
     * @param {PortfolioMarginApiGetMarginAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginAllOrdersV1(requestParameters: PortfolioMarginApiGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user\'s margin force orders
     * @summary Query User\'s Margin Force Orders(USER_DATA)
     * @param {PortfolioMarginApiGetMarginForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginForceOrdersV1(requestParameters: PortfolioMarginApiGetMarginForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginForceOrdersV1(requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Margin Borrow/Loan Interest History
     * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
     * @param {PortfolioMarginApiGetMarginMarginInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginMarginInterestHistoryV1(requestParameters: PortfolioMarginApiGetMarginMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginMarginInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query margin loan record
     * @summary Query Margin Loan Record(USER_DATA)
     * @param {PortfolioMarginApiGetMarginMarginLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginMarginLoanV1(requestParameters: PortfolioMarginApiGetMarginMarginLoanV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginMarginLoanV1(requestParameters.asset, requestParameters.timestamp, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query margin max borrow
     * @summary Margin Max Borrow(USER_DATA)
     * @param {PortfolioMarginApiGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginMaxBorrowableV1(requestParameters: PortfolioMarginApiGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginMaxBorrowableV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Max Withdraw
     * @summary Query Margin Max Withdraw(USER_DATA)
     * @param {PortfolioMarginApiGetMarginMaxWithdrawV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginMaxWithdrawV1(requestParameters: PortfolioMarginApiGetMarginMaxWithdrawV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginMaxWithdrawV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Margin Account Trade List
     * @summary Margin Account Trade List (USER_DATA)
     * @param {PortfolioMarginApiGetMarginMyTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginMyTradesV1(requestParameters: PortfolioMarginApiGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginMyTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account\'s Open OCO
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {PortfolioMarginApiGetMarginOpenOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginOpenOrderListV1(requestParameters: PortfolioMarginApiGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginOpenOrderListV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current Margin Open Order
     * @summary Query Current Margin Open Order (USER_DATA)
     * @param {PortfolioMarginApiGetMarginOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginOpenOrdersV1(requestParameters: PortfolioMarginApiGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific OCO based on provided optional parameters
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {PortfolioMarginApiGetMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginOrderListV1(requestParameters: PortfolioMarginApiGetMarginOrderListV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginOrderListV1(requestParameters.timestamp, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account Order
     * @summary Query Margin Account Order (USER_DATA)
     * @param {PortfolioMarginApiGetMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginOrderV1(requestParameters: PortfolioMarginApiGetMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query margin repay record.
     * @summary Query Margin repay Record(USER_DATA)
     * @param {PortfolioMarginApiGetMarginRepayLoanV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getMarginRepayLoanV1(requestParameters: PortfolioMarginApiGetMarginRepayLoanV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getMarginRepayLoanV1(requestParameters.asset, requestParameters.timestamp, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.archived, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getPingV1(options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getPingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query interest history of negative balance for portfolio margin.
     * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     * @param {PortfolioMarginApiGetPortfolioInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getPortfolioInterestHistoryV1(requestParameters: PortfolioMarginApiGetPortfolioInterestHistoryV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getPortfolioInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.startTime, requestParameters.endTime, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user negative balance auto exchange record
     * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
     * @param {PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getPortfolioNegativeBalanceExchangeRecordV1(requestParameters: PortfolioMarginApiGetPortfolioNegativeBalanceExchangeRecordV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getPortfolioNegativeBalanceExchangeRecordV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query User Rate Limit
     * @summary Query User Rate Limit (USER_DATA)
     * @param {PortfolioMarginApiGetRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getRateLimitOrderV1(requestParameters: PortfolioMarginApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getRateLimitOrderV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Auto-repay-futures Status
     * @summary Get Auto-repay-futures Status(USER_DATA)
     * @param {PortfolioMarginApiGetRepayFuturesSwitchV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getRepayFuturesSwitchV1(requestParameters: PortfolioMarginApiGetRepayFuturesSwitchV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getRepayFuturesSwitchV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query UM Futures account configuration
     * @summary UM Futures Account Configuration(USER_DATA)
     * @param {PortfolioMarginApiGetUmAccountConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmAccountConfigV1(requestParameters: PortfolioMarginApiGetUmAccountConfigV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmAccountConfigV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current UM account asset and position information.
     * @summary Get UM Account Detail(USER_DATA)
     * @param {PortfolioMarginApiGetUmAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmAccountV1(requestParameters: PortfolioMarginApiGetUmAccountV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current UM account asset and position information.
     * @summary Get UM Account Detail V2(USER_DATA)
     * @param {PortfolioMarginApiGetUmAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmAccountV2(requestParameters: PortfolioMarginApiGetUmAccountV2Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmAccountV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query UM Position ADL Quantile Estimation
     * @summary UM Position ADL Quantile Estimation(USER_DATA)
     * @param {PortfolioMarginApiGetUmAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmAdlQuantileV1(requestParameters: PortfolioMarginApiGetUmAdlQuantileV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account UM orders; active, canceled, or filled.
     * @summary Query All UM Orders(USER_DATA)
     * @param {PortfolioMarginApiGetUmAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmAllOrdersV1(requestParameters: PortfolioMarginApiGetUmAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Portfolio Margin UM Trading Quantitative Rules Indicators
     * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     * @param {PortfolioMarginApiGetUmApiTradingStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmApiTradingStatusV1(requestParameters: PortfolioMarginApiGetUmApiTradingStatusV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmApiTradingStatusV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get User Commission Rate for UM
     * @summary Get User Commission Rate for UM(USER_DATA)
     * @param {PortfolioMarginApiGetUmCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmCommissionRateV1(requestParameters: PortfolioMarginApiGetUmCommissionRateV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query All UM Conditional Orders
     * @summary Query All UM Conditional Orders(USER_DATA)
     * @param {PortfolioMarginApiGetUmConditionalAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmConditionalAllOrdersV1(requestParameters: PortfolioMarginApiGetUmConditionalAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmConditionalAllOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.strategyId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Current UM Open Conditional Order
     * @summary Query Current UM Open Conditional Order(USER_DATA)
     * @param {PortfolioMarginApiGetUmConditionalOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmConditionalOpenOrderV1(requestParameters: PortfolioMarginApiGetUmConditionalOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmConditionalOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open conditional orders on a symbol.
     * @summary Query All Current UM Open Conditional Orders(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmConditionalOpenOrdersV1(options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmConditionalOpenOrdersV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query UM Conditional Order History
     * @summary Query UM Conditional Order History(USER_DATA)
     * @param {PortfolioMarginApiGetUmConditionalOrderHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmConditionalOrderHistoryV1(requestParameters: PortfolioMarginApiGetUmConditionalOrderHistoryV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmConditionalOrderHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.strategyId, requestParameters.newClientStrategyId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
     * @summary Get UM Futures BNB Burn Status (USER_DATA)
     * @param {PortfolioMarginApiGetUmFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmFeeBurnV1(requestParameters: PortfolioMarginApiGetUmFeeBurnV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmFeeBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query User\'s UM Force Orders
     * @summary Query User\'s UM Force Orders (USER_DATA)
     * @param {PortfolioMarginApiGetUmForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmForceOrdersV1(requestParameters: PortfolioMarginApiGetUmForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UM futures Transaction download link by Id
     * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
     * @param {PortfolioMarginApiGetUmIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmIncomeAsynIdV1(requestParameters: PortfolioMarginApiGetUmIncomeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for UM futures transaction history
     * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
     * @param {PortfolioMarginApiGetUmIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmIncomeAsynV1(requestParameters: PortfolioMarginApiGetUmIncomeAsynV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UM Income History
     * @summary Get UM Income History(USER_DATA)
     * @param {PortfolioMarginApiGetUmIncomeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmIncomeV1(requestParameters: PortfolioMarginApiGetUmIncomeV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmIncomeV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.incomeType, requestParameters.startTime, requestParameters.endTime, requestParameters.page, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query UM notional and leverage brackets
     * @summary UM Notional and Leverage Brackets (USER_DATA)
     * @param {PortfolioMarginApiGetUmLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmLeverageBracketV1(requestParameters: PortfolioMarginApiGetUmLeverageBracketV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query current UM open order
     * @summary Query Current UM Open Order(USER_DATA)
     * @param {PortfolioMarginApiGetUmOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmOpenOrderV1(requestParameters: PortfolioMarginApiGetUmOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol.
     * @summary Query All Current UM Open Orders(USER_DATA)
     * @param {PortfolioMarginApiGetUmOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmOpenOrdersV1(requestParameters: PortfolioMarginApiGetUmOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Query UM Modify Order History(TRADE)
     * @param {PortfolioMarginApiGetUmOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmOrderAmendmentV1(requestParameters: PortfolioMarginApiGetUmOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UM futures order download link by Id
     * @summary Get UM Futures Order Download Link by Id(USER_DATA)
     * @param {PortfolioMarginApiGetUmOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmOrderAsynIdV1(requestParameters: PortfolioMarginApiGetUmOrderAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for UM futures order history
     * @summary Get Download Id For UM Futures Order History (USER_DATA)
     * @param {PortfolioMarginApiGetUmOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmOrderAsynV1(requestParameters: PortfolioMarginApiGetUmOrderAsynV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an UM order\'s status.
     * @summary Query UM Order (USER_DATA)
     * @param {PortfolioMarginApiGetUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmOrderV1(requestParameters: PortfolioMarginApiGetUmOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current UM position information.
     * @summary Query UM Position Information(USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmPositionRiskV1(options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmPositionRiskV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * @summary Get UM Current Position Mode(USER_DATA)
     * @param {PortfolioMarginApiGetUmPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmPositionSideDualV1(requestParameters: PortfolioMarginApiGetUmPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current UM account symbol configuration.
     * @summary UM Futures Symbol Configuration(USER_DATA)
     * @param {PortfolioMarginApiGetUmSymbolConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmSymbolConfigV1(requestParameters: PortfolioMarginApiGetUmSymbolConfigV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmSymbolConfigV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UM futures trade download link by Id
     * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
     * @param {PortfolioMarginApiGetUmTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmTradeAsynIdV1(requestParameters: PortfolioMarginApiGetUmTradeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for UM futures trade history
     * @summary Get Download Id For UM Futures Trade History (USER_DATA)
     * @param {PortfolioMarginApiGetUmTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmTradeAsynV1(requestParameters: PortfolioMarginApiGetUmTradeAsynV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and UM symbol.
     * @summary UM Account Trade List(USER_DATA)
     * @param {PortfolioMarginApiGetUmUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public getUmUserTradesV1(requestParameters: PortfolioMarginApiGetUmUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).getUmUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify CM Order(TRADE)
     * @param {PortfolioMarginApiUpdateCmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public updateCmOrderV1(requestParameters: PortfolioMarginApiUpdateCmOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).updateCmOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public updateListenKeyV1(options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).updateListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify UM Order(TRADE)
     * @param {PortfolioMarginApiUpdateUmOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioMarginApi
     */
    public updateUmOrderV1(requestParameters: PortfolioMarginApiUpdateUmOrderV1Request, options?: RawAxiosRequestConfig) {
        return PortfolioMarginApiFp(this.configuration).updateUmOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

