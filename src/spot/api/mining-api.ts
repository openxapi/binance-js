/* tslint:disable */
/* eslint-disable */
/**
 * Binance Spot API
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CreateMiningHashTransferConfigCancelV1Resp } from '../model';
// @ts-ignore
import type { CreateMiningHashTransferConfigV1Resp } from '../model';
// @ts-ignore
import type { GetMiningHashTransferConfigDetailsListV1Resp } from '../model';
// @ts-ignore
import type { GetMiningHashTransferProfitDetailsV1Resp } from '../model';
// @ts-ignore
import type { GetMiningPaymentListV1Resp } from '../model';
// @ts-ignore
import type { GetMiningPaymentOtherV1Resp } from '../model';
// @ts-ignore
import type { GetMiningPaymentUidV1Resp } from '../model';
// @ts-ignore
import type { GetMiningPubAlgoListV1Resp } from '../model';
// @ts-ignore
import type { GetMiningPubCoinListV1Resp } from '../model';
// @ts-ignore
import type { GetMiningStatisticsUserListV1Resp } from '../model';
// @ts-ignore
import type { GetMiningStatisticsUserStatusV1Resp } from '../model';
// @ts-ignore
import type { GetMiningWorkerDetailV1Resp } from '../model';
// @ts-ignore
import type { GetMiningWorkerListV1Resp } from '../model';
/**
 * MiningApi - axios parameter creator
 * @export
 */
export const MiningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel hashrate resale configuration(USER_DATA)
         * @param {number} configId 
         * @param {number} timestamp 
         * @param {string} userName 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMiningHashTransferConfigCancelV1: async (configId: number, timestamp: number, userName: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configId' is not null or undefined
            assertParamExists('createMiningHashTransferConfigCancelV1', 'configId', configId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMiningHashTransferConfigCancelV1', 'timestamp', timestamp)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('createMiningHashTransferConfigCancelV1', 'userName', userName)
            const localVarPath = `/sapi/v1/mining/hash-transfer/config/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (configId !== undefined) { 
                localVarFormParams.set('configId', configId as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (userName !== undefined) { 
                localVarFormParams.set('userName', userName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hashrate Resale Request
         * @summary Hashrate Resale Request(USER_DATA)
         * @param {string} algo 
         * @param {number} endDate 
         * @param {number} hashRate 
         * @param {number} startDate 
         * @param {number} timestamp 
         * @param {string} toPoolUser 
         * @param {string} userName 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMiningHashTransferConfigV1: async (algo: string, endDate: number, hashRate: number, startDate: number, timestamp: number, toPoolUser: string, userName: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            assertParamExists('createMiningHashTransferConfigV1', 'algo', algo)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('createMiningHashTransferConfigV1', 'endDate', endDate)
            // verify required parameter 'hashRate' is not null or undefined
            assertParamExists('createMiningHashTransferConfigV1', 'hashRate', hashRate)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('createMiningHashTransferConfigV1', 'startDate', startDate)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMiningHashTransferConfigV1', 'timestamp', timestamp)
            // verify required parameter 'toPoolUser' is not null or undefined
            assertParamExists('createMiningHashTransferConfigV1', 'toPoolUser', toPoolUser)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('createMiningHashTransferConfigV1', 'userName', userName)
            const localVarPath = `/sapi/v1/mining/hash-transfer/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (algo !== undefined) { 
                localVarFormParams.set('algo', algo as any);
            }
    
            if (endDate !== undefined) { 
                localVarFormParams.set('endDate', endDate as any);
            }
    
            if (hashRate !== undefined) { 
                localVarFormParams.set('hashRate', hashRate as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (startDate !== undefined) { 
                localVarFormParams.set('startDate', startDate as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (toPoolUser !== undefined) { 
                localVarFormParams.set('toPoolUser', toPoolUser as any);
            }
    
            if (userName !== undefined) { 
                localVarFormParams.set('userName', userName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hashrate Resale List
         * @summary Hashrate Resale List (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [pageIndex] Page number, empty default first page, starting from 1
         * @param {number} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningHashTransferConfigDetailsListV1: async (timestamp: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningHashTransferConfigDetailsListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/hash-transfer/config/details/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hashrate Resale Detail(USER_DATA)
         * @summary Hashrate Resale Detail(USER_DATA)
         * @param {number} configId Mining ID
         * @param {string} userName Mining Account
         * @param {number} timestamp 
         * @param {number} [pageIndex] Page number, empty default first page, starting from 1
         * @param {number} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningHashTransferProfitDetailsV1: async (configId: number, userName: string, timestamp: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configId' is not null or undefined
            assertParamExists('getMiningHashTransferProfitDetailsV1', 'configId', configId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getMiningHashTransferProfitDetailsV1', 'userName', userName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningHashTransferProfitDetailsV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/hash-transfer/profit/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (configId !== undefined) {
                localVarQueryParameter['configId'] = configId;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Earnings List
         * @summary Earnings List(USER_DATA)
         * @param {string} algo Transfer algorithm(sha256)
         * @param {string} userName Mining account
         * @param {number} timestamp 
         * @param {string} [coin] Coin name
         * @param {number} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, empty default first page, starting from 1
         * @param {number} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPaymentListV1: async (algo: string, userName: string, timestamp: number, coin?: string, startDate?: number, endDate?: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            assertParamExists('getMiningPaymentListV1', 'algo', algo)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getMiningPaymentListV1', 'userName', userName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningPaymentListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/payment/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extra Bonus List
         * @summary Extra Bonus List(USER_DATA)
         * @param {string} algo Transfer algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp 
         * @param {string} [coin] Coin Name
         * @param {number} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, empty default first page, starting from 1
         * @param {number} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPaymentOtherV1: async (algo: string, userName: string, timestamp: number, coin?: string, startDate?: number, endDate?: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            assertParamExists('getMiningPaymentOtherV1', 'algo', algo)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getMiningPaymentOtherV1', 'userName', userName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningPaymentOtherV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/payment/other`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mining Account Earning
         * @summary Mining Account Earning(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {number} timestamp 
         * @param {number} [startDate] Millisecond timestamp
         * @param {number} [endDate] Millisecond timestamp
         * @param {number} [pageIndex] Default 1
         * @param {number} [pageSize] Min 10,Max 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPaymentUidV1: async (algo: string, timestamp: number, startDate?: number, endDate?: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            assertParamExists('getMiningPaymentUidV1', 'algo', algo)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningPaymentUidV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/payment/uid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acquiring Algorithm
         * @summary Acquiring Algorithm(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPubAlgoListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/mining/pub/algoList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acquiring CoinName
         * @summary Acquiring CoinName(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPubCoinListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/mining/pub/coinList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Account List
         * @summary Account List(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining account
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningStatisticsUserListV1: async (algo: string, userName: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            assertParamExists('getMiningStatisticsUserListV1', 'algo', algo)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getMiningStatisticsUserListV1', 'userName', userName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningStatisticsUserListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/statistics/user/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Statistic List
         * @summary Statistic List(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining account
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningStatisticsUserStatusV1: async (algo: string, userName: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            assertParamExists('getMiningStatisticsUserStatusV1', 'algo', algo)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getMiningStatisticsUserStatusV1', 'userName', userName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningStatisticsUserStatusV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/statistics/user/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request for Detail Miner List
         * @summary Request for Detail Miner List(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining account
         * @param {string} workerName Miner’s name(required)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningWorkerDetailV1: async (algo: string, userName: string, workerName: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            assertParamExists('getMiningWorkerDetailV1', 'algo', algo)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getMiningWorkerDetailV1', 'userName', userName)
            // verify required parameter 'workerName' is not null or undefined
            assertParamExists('getMiningWorkerDetailV1', 'workerName', workerName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningWorkerDetailV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/worker/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (workerName !== undefined) {
                localVarQueryParameter['workerName'] = workerName;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request for Miner List
         * @summary Request for Miner List(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining account
         * @param {number} timestamp 
         * @param {number} [pageIndex] Page number，default is first page，start form 1
         * @param {number} [sort] sort sequence(default&#x3D;0)0 positive sequence，1 negative sequence
         * @param {number} [sortColumn] Sort by( default 1): &lt;br/&gt;&lt;br/&gt;1: miner name, &lt;br/&gt;&lt;br/&gt;2: real-time computing power, &lt;br/&gt;&lt;br/&gt;3: daily average computing power, &lt;br/&gt;&lt;br/&gt;4: real-time rejection rate, &lt;br/&gt;&lt;br/&gt;5: last submission time
         * @param {number} [workerStatus] miners status(default&#x3D;0),0 all，1 valid，2 invalid，3 failure
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningWorkerListV1: async (algo: string, userName: string, timestamp: number, pageIndex?: number, sort?: number, sortColumn?: number, workerStatus?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            assertParamExists('getMiningWorkerListV1', 'algo', algo)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getMiningWorkerListV1', 'userName', userName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMiningWorkerListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/mining/worker/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortColumn !== undefined) {
                localVarQueryParameter['sortColumn'] = sortColumn;
            }

            if (workerStatus !== undefined) {
                localVarQueryParameter['workerStatus'] = workerStatus;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiningApi - functional programming interface
 * @export
 */
export const MiningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiningApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel hashrate resale configuration(USER_DATA)
         * @param {number} configId 
         * @param {number} timestamp 
         * @param {string} userName 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMiningHashTransferConfigCancelV1(configId: number, timestamp: number, userName: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMiningHashTransferConfigCancelV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMiningHashTransferConfigCancelV1(configId, timestamp, userName, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.createMiningHashTransferConfigCancelV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hashrate Resale Request
         * @summary Hashrate Resale Request(USER_DATA)
         * @param {string} algo 
         * @param {number} endDate 
         * @param {number} hashRate 
         * @param {number} startDate 
         * @param {number} timestamp 
         * @param {string} toPoolUser 
         * @param {string} userName 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMiningHashTransferConfigV1(algo: string, endDate: number, hashRate: number, startDate: number, timestamp: number, toPoolUser: string, userName: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMiningHashTransferConfigV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMiningHashTransferConfigV1(algo, endDate, hashRate, startDate, timestamp, toPoolUser, userName, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.createMiningHashTransferConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hashrate Resale List
         * @summary Hashrate Resale List (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [pageIndex] Page number, empty default first page, starting from 1
         * @param {number} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningHashTransferConfigDetailsListV1(timestamp: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningHashTransferConfigDetailsListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningHashTransferConfigDetailsListV1(timestamp, pageIndex, pageSize, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningHashTransferConfigDetailsListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hashrate Resale Detail(USER_DATA)
         * @summary Hashrate Resale Detail(USER_DATA)
         * @param {number} configId Mining ID
         * @param {string} userName Mining Account
         * @param {number} timestamp 
         * @param {number} [pageIndex] Page number, empty default first page, starting from 1
         * @param {number} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningHashTransferProfitDetailsV1(configId: number, userName: string, timestamp: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningHashTransferProfitDetailsV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningHashTransferProfitDetailsV1(configId, userName, timestamp, pageIndex, pageSize, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningHashTransferProfitDetailsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Earnings List
         * @summary Earnings List(USER_DATA)
         * @param {string} algo Transfer algorithm(sha256)
         * @param {string} userName Mining account
         * @param {number} timestamp 
         * @param {string} [coin] Coin name
         * @param {number} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, empty default first page, starting from 1
         * @param {number} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningPaymentListV1(algo: string, userName: string, timestamp: number, coin?: string, startDate?: number, endDate?: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningPaymentListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningPaymentListV1(algo, userName, timestamp, coin, startDate, endDate, pageIndex, pageSize, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningPaymentListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Extra Bonus List
         * @summary Extra Bonus List(USER_DATA)
         * @param {string} algo Transfer algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp 
         * @param {string} [coin] Coin Name
         * @param {number} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, empty default first page, starting from 1
         * @param {number} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningPaymentOtherV1(algo: string, userName: string, timestamp: number, coin?: string, startDate?: number, endDate?: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningPaymentOtherV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningPaymentOtherV1(algo, userName, timestamp, coin, startDate, endDate, pageIndex, pageSize, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningPaymentOtherV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mining Account Earning
         * @summary Mining Account Earning(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {number} timestamp 
         * @param {number} [startDate] Millisecond timestamp
         * @param {number} [endDate] Millisecond timestamp
         * @param {number} [pageIndex] Default 1
         * @param {number} [pageSize] Min 10,Max 200
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningPaymentUidV1(algo: string, timestamp: number, startDate?: number, endDate?: number, pageIndex?: number, pageSize?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningPaymentUidV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningPaymentUidV1(algo, timestamp, startDate, endDate, pageIndex, pageSize, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningPaymentUidV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Acquiring Algorithm
         * @summary Acquiring Algorithm(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningPubAlgoListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningPubAlgoListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningPubAlgoListV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningPubAlgoListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Acquiring CoinName
         * @summary Acquiring CoinName(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningPubCoinListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningPubCoinListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningPubCoinListV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningPubCoinListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Account List
         * @summary Account List(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining account
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningStatisticsUserListV1(algo: string, userName: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningStatisticsUserListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningStatisticsUserListV1(algo, userName, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningStatisticsUserListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Statistic List
         * @summary Statistic List(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining account
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningStatisticsUserStatusV1(algo: string, userName: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningStatisticsUserStatusV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningStatisticsUserStatusV1(algo, userName, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningStatisticsUserStatusV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request for Detail Miner List
         * @summary Request for Detail Miner List(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining account
         * @param {string} workerName Miner’s name(required)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningWorkerDetailV1(algo: string, userName: string, workerName: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningWorkerDetailV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningWorkerDetailV1(algo, userName, workerName, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningWorkerDetailV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request for Miner List
         * @summary Request for Miner List(USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining account
         * @param {number} timestamp 
         * @param {number} [pageIndex] Page number，default is first page，start form 1
         * @param {number} [sort] sort sequence(default&#x3D;0)0 positive sequence，1 negative sequence
         * @param {number} [sortColumn] Sort by( default 1): &lt;br/&gt;&lt;br/&gt;1: miner name, &lt;br/&gt;&lt;br/&gt;2: real-time computing power, &lt;br/&gt;&lt;br/&gt;3: daily average computing power, &lt;br/&gt;&lt;br/&gt;4: real-time rejection rate, &lt;br/&gt;&lt;br/&gt;5: last submission time
         * @param {number} [workerStatus] miners status(default&#x3D;0),0 all，1 valid，2 invalid，3 failure
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiningWorkerListV1(algo: string, userName: string, timestamp: number, pageIndex?: number, sort?: number, sortColumn?: number, workerStatus?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiningWorkerListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiningWorkerListV1(algo, userName, timestamp, pageIndex, sort, sortColumn, workerStatus, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiningApi.getMiningWorkerListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiningApi - factory interface
 * @export
 */
export const MiningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiningApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel hashrate resale configuration(USER_DATA)
         * @param {MiningApiCreateMiningHashTransferConfigCancelV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMiningHashTransferConfigCancelV1(requestParameters: MiningApiCreateMiningHashTransferConfigCancelV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMiningHashTransferConfigCancelV1Resp> {
            return localVarFp.createMiningHashTransferConfigCancelV1(requestParameters.configId, requestParameters.timestamp, requestParameters.userName, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Hashrate Resale Request
         * @summary Hashrate Resale Request(USER_DATA)
         * @param {MiningApiCreateMiningHashTransferConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMiningHashTransferConfigV1(requestParameters: MiningApiCreateMiningHashTransferConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMiningHashTransferConfigV1Resp> {
            return localVarFp.createMiningHashTransferConfigV1(requestParameters.algo, requestParameters.endDate, requestParameters.hashRate, requestParameters.startDate, requestParameters.timestamp, requestParameters.toPoolUser, requestParameters.userName, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Hashrate Resale List
         * @summary Hashrate Resale List (USER_DATA)
         * @param {MiningApiGetMiningHashTransferConfigDetailsListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningHashTransferConfigDetailsListV1(requestParameters: MiningApiGetMiningHashTransferConfigDetailsListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningHashTransferConfigDetailsListV1Resp> {
            return localVarFp.getMiningHashTransferConfigDetailsListV1(requestParameters.timestamp, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Hashrate Resale Detail(USER_DATA)
         * @summary Hashrate Resale Detail(USER_DATA)
         * @param {MiningApiGetMiningHashTransferProfitDetailsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningHashTransferProfitDetailsV1(requestParameters: MiningApiGetMiningHashTransferProfitDetailsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningHashTransferProfitDetailsV1Resp> {
            return localVarFp.getMiningHashTransferProfitDetailsV1(requestParameters.configId, requestParameters.userName, requestParameters.timestamp, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Earnings List
         * @summary Earnings List(USER_DATA)
         * @param {MiningApiGetMiningPaymentListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPaymentListV1(requestParameters: MiningApiGetMiningPaymentListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPaymentListV1Resp> {
            return localVarFp.getMiningPaymentListV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.coin, requestParameters.startDate, requestParameters.endDate, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Extra Bonus List
         * @summary Extra Bonus List(USER_DATA)
         * @param {MiningApiGetMiningPaymentOtherV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPaymentOtherV1(requestParameters: MiningApiGetMiningPaymentOtherV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPaymentOtherV1Resp> {
            return localVarFp.getMiningPaymentOtherV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.coin, requestParameters.startDate, requestParameters.endDate, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Mining Account Earning
         * @summary Mining Account Earning(USER_DATA)
         * @param {MiningApiGetMiningPaymentUidV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPaymentUidV1(requestParameters: MiningApiGetMiningPaymentUidV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPaymentUidV1Resp> {
            return localVarFp.getMiningPaymentUidV1(requestParameters.algo, requestParameters.timestamp, requestParameters.startDate, requestParameters.endDate, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Acquiring Algorithm
         * @summary Acquiring Algorithm(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPubAlgoListV1(options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPubAlgoListV1Resp> {
            return localVarFp.getMiningPubAlgoListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Acquiring CoinName
         * @summary Acquiring CoinName(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningPubCoinListV1(options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPubCoinListV1Resp> {
            return localVarFp.getMiningPubCoinListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Query Account List
         * @summary Account List(USER_DATA)
         * @param {MiningApiGetMiningStatisticsUserListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningStatisticsUserListV1(requestParameters: MiningApiGetMiningStatisticsUserListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningStatisticsUserListV1Resp> {
            return localVarFp.getMiningStatisticsUserListV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Statistic List
         * @summary Statistic List(USER_DATA)
         * @param {MiningApiGetMiningStatisticsUserStatusV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningStatisticsUserStatusV1(requestParameters: MiningApiGetMiningStatisticsUserStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningStatisticsUserStatusV1Resp> {
            return localVarFp.getMiningStatisticsUserStatusV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Request for Detail Miner List
         * @summary Request for Detail Miner List(USER_DATA)
         * @param {MiningApiGetMiningWorkerDetailV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningWorkerDetailV1(requestParameters: MiningApiGetMiningWorkerDetailV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningWorkerDetailV1Resp> {
            return localVarFp.getMiningWorkerDetailV1(requestParameters.algo, requestParameters.userName, requestParameters.workerName, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Request for Miner List
         * @summary Request for Miner List(USER_DATA)
         * @param {MiningApiGetMiningWorkerListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiningWorkerListV1(requestParameters: MiningApiGetMiningWorkerListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningWorkerListV1Resp> {
            return localVarFp.getMiningWorkerListV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.pageIndex, requestParameters.sort, requestParameters.sortColumn, requestParameters.workerStatus, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiningApi - interface
 * @export
 * @interface MiningApi
 */
export interface MiningApiInterface {
    /**
     * 
     * @summary Cancel hashrate resale configuration(USER_DATA)
     * @param {MiningApiCreateMiningHashTransferConfigCancelV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    createMiningHashTransferConfigCancelV1(requestParameters: MiningApiCreateMiningHashTransferConfigCancelV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMiningHashTransferConfigCancelV1Resp>;

    /**
     * Hashrate Resale Request
     * @summary Hashrate Resale Request(USER_DATA)
     * @param {MiningApiCreateMiningHashTransferConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    createMiningHashTransferConfigV1(requestParameters: MiningApiCreateMiningHashTransferConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMiningHashTransferConfigV1Resp>;

    /**
     * Hashrate Resale List
     * @summary Hashrate Resale List (USER_DATA)
     * @param {MiningApiGetMiningHashTransferConfigDetailsListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningHashTransferConfigDetailsListV1(requestParameters: MiningApiGetMiningHashTransferConfigDetailsListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningHashTransferConfigDetailsListV1Resp>;

    /**
     * Hashrate Resale Detail(USER_DATA)
     * @summary Hashrate Resale Detail(USER_DATA)
     * @param {MiningApiGetMiningHashTransferProfitDetailsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningHashTransferProfitDetailsV1(requestParameters: MiningApiGetMiningHashTransferProfitDetailsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningHashTransferProfitDetailsV1Resp>;

    /**
     * Query Earnings List
     * @summary Earnings List(USER_DATA)
     * @param {MiningApiGetMiningPaymentListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningPaymentListV1(requestParameters: MiningApiGetMiningPaymentListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPaymentListV1Resp>;

    /**
     * Extra Bonus List
     * @summary Extra Bonus List(USER_DATA)
     * @param {MiningApiGetMiningPaymentOtherV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningPaymentOtherV1(requestParameters: MiningApiGetMiningPaymentOtherV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPaymentOtherV1Resp>;

    /**
     * Mining Account Earning
     * @summary Mining Account Earning(USER_DATA)
     * @param {MiningApiGetMiningPaymentUidV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningPaymentUidV1(requestParameters: MiningApiGetMiningPaymentUidV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPaymentUidV1Resp>;

    /**
     * Acquiring Algorithm
     * @summary Acquiring Algorithm(MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningPubAlgoListV1(options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPubAlgoListV1Resp>;

    /**
     * Acquiring CoinName
     * @summary Acquiring CoinName(MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningPubCoinListV1(options?: RawAxiosRequestConfig): AxiosPromise<GetMiningPubCoinListV1Resp>;

    /**
     * Query Account List
     * @summary Account List(USER_DATA)
     * @param {MiningApiGetMiningStatisticsUserListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningStatisticsUserListV1(requestParameters: MiningApiGetMiningStatisticsUserListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningStatisticsUserListV1Resp>;

    /**
     * Statistic List
     * @summary Statistic List(USER_DATA)
     * @param {MiningApiGetMiningStatisticsUserStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningStatisticsUserStatusV1(requestParameters: MiningApiGetMiningStatisticsUserStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningStatisticsUserStatusV1Resp>;

    /**
     * Request for Detail Miner List
     * @summary Request for Detail Miner List(USER_DATA)
     * @param {MiningApiGetMiningWorkerDetailV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningWorkerDetailV1(requestParameters: MiningApiGetMiningWorkerDetailV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningWorkerDetailV1Resp>;

    /**
     * Request for Miner List
     * @summary Request for Miner List(USER_DATA)
     * @param {MiningApiGetMiningWorkerListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApiInterface
     */
    getMiningWorkerListV1(requestParameters: MiningApiGetMiningWorkerListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMiningWorkerListV1Resp>;

}

/**
 * Request parameters for createMiningHashTransferConfigCancelV1 operation in MiningApi.
 * @export
 * @interface MiningApiCreateMiningHashTransferConfigCancelV1Request
 */
export interface MiningApiCreateMiningHashTransferConfigCancelV1Request {
    /**
     * 
     * @type {number}
     * @memberof MiningApiCreateMiningHashTransferConfigCancelV1
     */
    readonly configId: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiCreateMiningHashTransferConfigCancelV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MiningApiCreateMiningHashTransferConfigCancelV1
     */
    readonly userName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiCreateMiningHashTransferConfigCancelV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMiningHashTransferConfigV1 operation in MiningApi.
 * @export
 * @interface MiningApiCreateMiningHashTransferConfigV1Request
 */
export interface MiningApiCreateMiningHashTransferConfigV1Request {
    /**
     * 
     * @type {string}
     * @memberof MiningApiCreateMiningHashTransferConfigV1
     */
    readonly algo: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiCreateMiningHashTransferConfigV1
     */
    readonly endDate: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiCreateMiningHashTransferConfigV1
     */
    readonly hashRate: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiCreateMiningHashTransferConfigV1
     */
    readonly startDate: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiCreateMiningHashTransferConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MiningApiCreateMiningHashTransferConfigV1
     */
    readonly toPoolUser: string

    /**
     * 
     * @type {string}
     * @memberof MiningApiCreateMiningHashTransferConfigV1
     */
    readonly userName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiCreateMiningHashTransferConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningHashTransferConfigDetailsListV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningHashTransferConfigDetailsListV1Request
 */
export interface MiningApiGetMiningHashTransferConfigDetailsListV1Request {
    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferConfigDetailsListV1
     */
    readonly timestamp: number

    /**
     * Page number, empty default first page, starting from 1
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferConfigDetailsListV1
     */
    readonly pageIndex?: number

    /**
     * Number of pages, minimum 10, maximum 200
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferConfigDetailsListV1
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferConfigDetailsListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningHashTransferProfitDetailsV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningHashTransferProfitDetailsV1Request
 */
export interface MiningApiGetMiningHashTransferProfitDetailsV1Request {
    /**
     * Mining ID
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferProfitDetailsV1
     */
    readonly configId: number

    /**
     * Mining Account
     * @type {string}
     * @memberof MiningApiGetMiningHashTransferProfitDetailsV1
     */
    readonly userName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferProfitDetailsV1
     */
    readonly timestamp: number

    /**
     * Page number, empty default first page, starting from 1
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferProfitDetailsV1
     */
    readonly pageIndex?: number

    /**
     * Number of pages, minimum 10, maximum 200
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferProfitDetailsV1
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningHashTransferProfitDetailsV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningPaymentListV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningPaymentListV1Request
 */
export interface MiningApiGetMiningPaymentListV1Request {
    /**
     * Transfer algorithm(sha256)
     * @type {string}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly algo: string

    /**
     * Mining account
     * @type {string}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly userName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly timestamp: number

    /**
     * Coin name
     * @type {string}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly coin?: string

    /**
     * Search date, millisecond timestamp, while empty query all
     * @type {number}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly startDate?: number

    /**
     * Search date, millisecond timestamp, while empty query all
     * @type {number}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly endDate?: number

    /**
     * Page number, empty default first page, starting from 1
     * @type {number}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly pageIndex?: number

    /**
     * Number of pages, minimum 10, maximum 200
     * @type {number}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningPaymentListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningPaymentOtherV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningPaymentOtherV1Request
 */
export interface MiningApiGetMiningPaymentOtherV1Request {
    /**
     * Transfer algorithm(sha256)
     * @type {string}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly algo: string

    /**
     * Mining Account
     * @type {string}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly userName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly timestamp: number

    /**
     * Coin Name
     * @type {string}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly coin?: string

    /**
     * Search date, millisecond timestamp, while empty query all
     * @type {number}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly startDate?: number

    /**
     * Search date, millisecond timestamp, while empty query all
     * @type {number}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly endDate?: number

    /**
     * Page number, empty default first page, starting from 1
     * @type {number}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly pageIndex?: number

    /**
     * Number of pages, minimum 10, maximum 200
     * @type {number}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningPaymentOtherV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningPaymentUidV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningPaymentUidV1Request
 */
export interface MiningApiGetMiningPaymentUidV1Request {
    /**
     * Algorithm(sha256)
     * @type {string}
     * @memberof MiningApiGetMiningPaymentUidV1
     */
    readonly algo: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningPaymentUidV1
     */
    readonly timestamp: number

    /**
     * Millisecond timestamp
     * @type {number}
     * @memberof MiningApiGetMiningPaymentUidV1
     */
    readonly startDate?: number

    /**
     * Millisecond timestamp
     * @type {number}
     * @memberof MiningApiGetMiningPaymentUidV1
     */
    readonly endDate?: number

    /**
     * Default 1
     * @type {number}
     * @memberof MiningApiGetMiningPaymentUidV1
     */
    readonly pageIndex?: number

    /**
     * Min 10,Max 200
     * @type {number}
     * @memberof MiningApiGetMiningPaymentUidV1
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningPaymentUidV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningStatisticsUserListV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningStatisticsUserListV1Request
 */
export interface MiningApiGetMiningStatisticsUserListV1Request {
    /**
     * Algorithm(sha256)
     * @type {string}
     * @memberof MiningApiGetMiningStatisticsUserListV1
     */
    readonly algo: string

    /**
     * Mining account
     * @type {string}
     * @memberof MiningApiGetMiningStatisticsUserListV1
     */
    readonly userName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningStatisticsUserListV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningStatisticsUserListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningStatisticsUserStatusV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningStatisticsUserStatusV1Request
 */
export interface MiningApiGetMiningStatisticsUserStatusV1Request {
    /**
     * Algorithm(sha256)
     * @type {string}
     * @memberof MiningApiGetMiningStatisticsUserStatusV1
     */
    readonly algo: string

    /**
     * Mining account
     * @type {string}
     * @memberof MiningApiGetMiningStatisticsUserStatusV1
     */
    readonly userName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningStatisticsUserStatusV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningStatisticsUserStatusV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningWorkerDetailV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningWorkerDetailV1Request
 */
export interface MiningApiGetMiningWorkerDetailV1Request {
    /**
     * Algorithm(sha256)
     * @type {string}
     * @memberof MiningApiGetMiningWorkerDetailV1
     */
    readonly algo: string

    /**
     * Mining account
     * @type {string}
     * @memberof MiningApiGetMiningWorkerDetailV1
     */
    readonly userName: string

    /**
     * Miner’s name(required)
     * @type {string}
     * @memberof MiningApiGetMiningWorkerDetailV1
     */
    readonly workerName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningWorkerDetailV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningWorkerDetailV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMiningWorkerListV1 operation in MiningApi.
 * @export
 * @interface MiningApiGetMiningWorkerListV1Request
 */
export interface MiningApiGetMiningWorkerListV1Request {
    /**
     * Algorithm(sha256)
     * @type {string}
     * @memberof MiningApiGetMiningWorkerListV1
     */
    readonly algo: string

    /**
     * Mining account
     * @type {string}
     * @memberof MiningApiGetMiningWorkerListV1
     */
    readonly userName: string

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningWorkerListV1
     */
    readonly timestamp: number

    /**
     * Page number，default is first page，start form 1
     * @type {number}
     * @memberof MiningApiGetMiningWorkerListV1
     */
    readonly pageIndex?: number

    /**
     * sort sequence(default&#x3D;0)0 positive sequence，1 negative sequence
     * @type {number}
     * @memberof MiningApiGetMiningWorkerListV1
     */
    readonly sort?: number

    /**
     * Sort by( default 1): &lt;br/&gt;&lt;br/&gt;1: miner name, &lt;br/&gt;&lt;br/&gt;2: real-time computing power, &lt;br/&gt;&lt;br/&gt;3: daily average computing power, &lt;br/&gt;&lt;br/&gt;4: real-time rejection rate, &lt;br/&gt;&lt;br/&gt;5: last submission time
     * @type {number}
     * @memberof MiningApiGetMiningWorkerListV1
     */
    readonly sortColumn?: number

    /**
     * miners status(default&#x3D;0),0 all，1 valid，2 invalid，3 failure
     * @type {number}
     * @memberof MiningApiGetMiningWorkerListV1
     */
    readonly workerStatus?: number

    /**
     * 
     * @type {number}
     * @memberof MiningApiGetMiningWorkerListV1
     */
    readonly recvWindow?: number
}

/**
 * MiningApi - object-oriented interface
 * @export
 * @class MiningApi
 * @extends {BaseAPI}
 */
export class MiningApi extends BaseAPI implements MiningApiInterface {
    /**
     * 
     * @summary Cancel hashrate resale configuration(USER_DATA)
     * @param {MiningApiCreateMiningHashTransferConfigCancelV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public createMiningHashTransferConfigCancelV1(requestParameters: MiningApiCreateMiningHashTransferConfigCancelV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).createMiningHashTransferConfigCancelV1(requestParameters.configId, requestParameters.timestamp, requestParameters.userName, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hashrate Resale Request
     * @summary Hashrate Resale Request(USER_DATA)
     * @param {MiningApiCreateMiningHashTransferConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public createMiningHashTransferConfigV1(requestParameters: MiningApiCreateMiningHashTransferConfigV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).createMiningHashTransferConfigV1(requestParameters.algo, requestParameters.endDate, requestParameters.hashRate, requestParameters.startDate, requestParameters.timestamp, requestParameters.toPoolUser, requestParameters.userName, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hashrate Resale List
     * @summary Hashrate Resale List (USER_DATA)
     * @param {MiningApiGetMiningHashTransferConfigDetailsListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningHashTransferConfigDetailsListV1(requestParameters: MiningApiGetMiningHashTransferConfigDetailsListV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningHashTransferConfigDetailsListV1(requestParameters.timestamp, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hashrate Resale Detail(USER_DATA)
     * @summary Hashrate Resale Detail(USER_DATA)
     * @param {MiningApiGetMiningHashTransferProfitDetailsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningHashTransferProfitDetailsV1(requestParameters: MiningApiGetMiningHashTransferProfitDetailsV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningHashTransferProfitDetailsV1(requestParameters.configId, requestParameters.userName, requestParameters.timestamp, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Earnings List
     * @summary Earnings List(USER_DATA)
     * @param {MiningApiGetMiningPaymentListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningPaymentListV1(requestParameters: MiningApiGetMiningPaymentListV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningPaymentListV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.coin, requestParameters.startDate, requestParameters.endDate, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extra Bonus List
     * @summary Extra Bonus List(USER_DATA)
     * @param {MiningApiGetMiningPaymentOtherV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningPaymentOtherV1(requestParameters: MiningApiGetMiningPaymentOtherV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningPaymentOtherV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.coin, requestParameters.startDate, requestParameters.endDate, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mining Account Earning
     * @summary Mining Account Earning(USER_DATA)
     * @param {MiningApiGetMiningPaymentUidV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningPaymentUidV1(requestParameters: MiningApiGetMiningPaymentUidV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningPaymentUidV1(requestParameters.algo, requestParameters.timestamp, requestParameters.startDate, requestParameters.endDate, requestParameters.pageIndex, requestParameters.pageSize, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Acquiring Algorithm
     * @summary Acquiring Algorithm(MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningPubAlgoListV1(options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningPubAlgoListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Acquiring CoinName
     * @summary Acquiring CoinName(MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningPubCoinListV1(options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningPubCoinListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Account List
     * @summary Account List(USER_DATA)
     * @param {MiningApiGetMiningStatisticsUserListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningStatisticsUserListV1(requestParameters: MiningApiGetMiningStatisticsUserListV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningStatisticsUserListV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Statistic List
     * @summary Statistic List(USER_DATA)
     * @param {MiningApiGetMiningStatisticsUserStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningStatisticsUserStatusV1(requestParameters: MiningApiGetMiningStatisticsUserStatusV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningStatisticsUserStatusV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request for Detail Miner List
     * @summary Request for Detail Miner List(USER_DATA)
     * @param {MiningApiGetMiningWorkerDetailV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningWorkerDetailV1(requestParameters: MiningApiGetMiningWorkerDetailV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningWorkerDetailV1(requestParameters.algo, requestParameters.userName, requestParameters.workerName, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request for Miner List
     * @summary Request for Miner List(USER_DATA)
     * @param {MiningApiGetMiningWorkerListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public getMiningWorkerListV1(requestParameters: MiningApiGetMiningWorkerListV1Request, options?: RawAxiosRequestConfig) {
        return MiningApiFp(this.configuration).getMiningWorkerListV1(requestParameters.algo, requestParameters.userName, requestParameters.timestamp, requestParameters.pageIndex, requestParameters.sort, requestParameters.sortColumn, requestParameters.workerStatus, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

