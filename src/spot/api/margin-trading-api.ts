/* tslint:disable */
/* eslint-disable */
/**
 * Binance Spot API
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.2.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CreateMarginApiKeyV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginBorrowRepayV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginIsolatedAccountV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginListenKeyV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginManualLiquidationV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginMaxLeverageV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginOrderOcoV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginOrderOtoV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginOrderOtocoV1Resp } from '../model';
// @ts-ignore
import type { CreateUserDataStreamIsolatedV1Resp } from '../model';
// @ts-ignore
import type { CreateUserDataStreamV1Resp } from '../model';
// @ts-ignore
import type { DeleteMarginIsolatedAccountV1Resp } from '../model';
// @ts-ignore
import type { DeleteMarginOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { DeleteMarginOrderListV1Resp } from '../model';
// @ts-ignore
import type { DeleteMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { GetBnbBurnV1Resp } from '../model';
// @ts-ignore
import type { GetMarginAccountV1Resp } from '../model';
// @ts-ignore
import type { GetMarginAllAssetsV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginAllOrderListV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginAllPairsV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginApiKeyListV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginApiKeyV1Resp } from '../model';
// @ts-ignore
import type { GetMarginBorrowRepayV1Resp } from '../model';
// @ts-ignore
import type { GetMarginCapitalFlowV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginCrossMarginCollateralRatioV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginCrossMarginDataV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginDelistScheduleV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginExchangeSmallLiabilityHistoryV1Resp } from '../model';
// @ts-ignore
import type { GetMarginExchangeSmallLiabilityV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginForceLiquidationRecV1Resp } from '../model';
// @ts-ignore
import type { GetMarginInterestHistoryV1Resp } from '../model';
// @ts-ignore
import type { GetMarginInterestRateHistoryV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginIsolatedAccountLimitV1Resp } from '../model';
// @ts-ignore
import type { GetMarginIsolatedAccountV1Resp } from '../model';
// @ts-ignore
import type { GetMarginIsolatedAllPairsV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginIsolatedMarginDataV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginIsolatedMarginTierV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginLeverageBracketV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginMaxBorrowableV1Resp } from '../model';
// @ts-ignore
import type { GetMarginMaxTransferableV1Resp } from '../model';
// @ts-ignore
import type { GetMarginMyTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginNextHourlyInterestRateV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginOpenOrderListV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginOrderListV1Resp } from '../model';
// @ts-ignore
import type { GetMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { GetMarginPriceIndexV1Resp } from '../model';
// @ts-ignore
import type { GetMarginRateLimitOrderV1RespItem } from '../model';
// @ts-ignore
import type { GetMarginTradeCoeffV1Resp } from '../model';
// @ts-ignore
import type { GetMarginTransferV1Resp } from '../model';
// @ts-ignore
import type { MarginCreateMarginExchangeSmallLiabilityV1Resp } from '../model';
// @ts-ignore
import type { MarginCreateMarginOrderV1Resp } from '../model';
// @ts-ignore
import type { MarginGetMarginAvailableInventoryV1Resp } from '../model';
// @ts-ignore
import type { MarginGetMarginOpenOrdersV1RespItem } from '../model';
/**
 * MarginTradingApi - axios parameter creator
 * @export
 */
export const MarginTradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **
         * @summary Create Special Key(Low-Latency Trading)(TRADE)
         * @param {string} apiName 
         * @param {number} timestamp 
         * @param {string} [ip] 
         * @param {string} [permissionMode] 
         * @param {string} [publicKey] 
         * @param {number} [recvWindow] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginApiKeyV1: async (apiName: string, timestamp: number, ip?: string, permissionMode?: string, publicKey?: string, recvWindow?: number, symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('createMarginApiKeyV1', 'apiName', apiName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginApiKeyV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/apiKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (apiName !== undefined) { 
                localVarFormParams.set('apiName', apiName as any);
            }
    
            if (ip !== undefined) { 
                localVarFormParams.set('ip', ip as any);
            }
    
            if (permissionMode !== undefined) { 
                localVarFormParams.set('permissionMode', permissionMode as any);
            }
    
            if (publicKey !== undefined) { 
                localVarFormParams.set('publicKey', publicKey as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Margin account borrow/repay(MARGIN)
         * @summary Margin account borrow/repay(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {string} isIsolated 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginBorrowRepayV1: async (amount: string, asset: string, isIsolated: string, symbol: string, timestamp: number, type: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createMarginBorrowRepayV1', 'amount', amount)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('createMarginBorrowRepayV1', 'asset', asset)
            // verify required parameter 'isIsolated' is not null or undefined
            assertParamExists('createMarginBorrowRepayV1', 'isIsolated', isIsolated)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginBorrowRepayV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginBorrowRepayV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createMarginBorrowRepayV1', 'type', type)
            const localVarPath = `/sapi/v1/margin/borrow-repay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (asset !== undefined) { 
                localVarFormParams.set('asset', asset as any);
            }
    
            if (isIsolated !== undefined) { 
                localVarFormParams.set('isIsolated', isIsolated as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Small Liability Exchange
         * @summary Small Liability Exchange (MARGIN)
         * @param {Array<string>} assetNames 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginExchangeSmallLiabilityV1: async (assetNames: Array<string>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetNames' is not null or undefined
            assertParamExists('createMarginExchangeSmallLiabilityV1', 'assetNames', assetNames)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginExchangeSmallLiabilityV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/exchange-small-liability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (assetNames) {
                localVarFormParams.set('assetNames', assetNames.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).
         * @summary Enable Isolated Margin Account (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginIsolatedAccountV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginIsolatedAccountV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginIsolatedAccountV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/isolated/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new user data stream.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/margin/listen-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Margin Manual Liquidation
         * @summary Margin Manual Liquidation(MARGIN)
         * @param {number} timestamp 
         * @param {string} type 
         * @param {number} [recvWindow] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginManualLiquidationV1: async (timestamp: number, type: string, recvWindow?: number, symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginManualLiquidationV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createMarginManualLiquidationV1', 'type', type)
            const localVarPath = `/sapi/v1/margin/manual-liquidation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adjust cross margin max leverage
         * @summary Adjust cross margin max leverage (USER_DATA)
         * @param {number} maxLeverage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginMaxLeverageV1: async (maxLeverage: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'maxLeverage' is not null or undefined
            assertParamExists('createMarginMaxLeverageV1', 'maxLeverage', maxLeverage)
            const localVarPath = `/sapi/v1/margin/max-leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (maxLeverage !== undefined) { 
                localVarFormParams.set('maxLeverage', maxLeverage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [isIsolated] 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderOcoV1: async (price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, autoRepayAtCancel?: boolean, isIsolated?: string, limitClientOrderId?: string, limitIcebergQty?: string, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, selfTradePreventionMode?: string, sideEffectType?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'side', side)
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'stopPrice', stopPrice)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginOrderOcoV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/order/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (autoRepayAtCancel !== undefined) { 
                localVarFormParams.set('autoRepayAtCancel', autoRepayAtCancel as any);
            }
    
            if (isIsolated !== undefined) { 
                localVarFormParams.set('isIsolated', isIsolated as any);
            }
    
            if (limitClientOrderId !== undefined) { 
                localVarFormParams.set('limitClientOrderId', limitClientOrderId as any);
            }
    
            if (limitIcebergQty !== undefined) { 
                localVarFormParams.set('limitIcebergQty', limitIcebergQty as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (sideEffectType !== undefined) { 
                localVarFormParams.set('sideEffectType', sideEffectType as any);
            }
    
            if (stopClientOrderId !== undefined) { 
                localVarFormParams.set('stopClientOrderId', stopClientOrderId as any);
            }
    
            if (stopIcebergQty !== undefined) { 
                localVarFormParams.set('stopIcebergQty', stopIcebergQty as any);
            }
    
            if (stopLimitPrice !== undefined) { 
                localVarFormParams.set('stopLimitPrice', stopLimitPrice as any);
            }
    
            if (stopLimitTimeInForce !== undefined) { 
                localVarFormParams.set('stopLimitTimeInForce', stopLimitTimeInForce as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post a new OTO order for margin account:
         * @summary Margin Account New OTO (TRADE)
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} pendingType 
         * @param {string} symbol 
         * @param {string} workingIcebergQty 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {CreateMarginOrderOtoV1WorkingTypeEnum} workingType 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [isIsolated] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingClientOrderId] 
         * @param {string} [pendingIcebergQty] 
         * @param {string} [pendingPrice] 
         * @param {string} [pendingStopPrice] 
         * @param {string} [pendingTimeInForce] 
         * @param {string} [pendingTrailingDelta] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderOtoV1: async (pendingQuantity: string, pendingSide: string, pendingType: string, symbol: string, workingIcebergQty: string, workingPrice: string, workingQuantity: string, workingSide: string, workingType: CreateMarginOrderOtoV1WorkingTypeEnum, autoRepayAtCancel?: boolean, isIsolated?: string, listClientOrderId?: string, newOrderRespType?: string, pendingClientOrderId?: string, pendingIcebergQty?: string, pendingPrice?: string, pendingStopPrice?: string, pendingTimeInForce?: string, pendingTrailingDelta?: string, selfTradePreventionMode?: string, sideEffectType?: string, workingClientOrderId?: string, workingTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'pendingQuantity', pendingQuantity)
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'pendingSide', pendingSide)
            // verify required parameter 'pendingType' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'pendingType', pendingType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'symbol', symbol)
            // verify required parameter 'workingIcebergQty' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'workingIcebergQty', workingIcebergQty)
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'workingPrice', workingPrice)
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'workingQuantity', workingQuantity)
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'workingSide', workingSide)
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('createMarginOrderOtoV1', 'workingType', workingType)
            const localVarPath = `/sapi/v1/margin/order/oto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (autoRepayAtCancel !== undefined) { 
                localVarFormParams.set('autoRepayAtCancel', autoRepayAtCancel as any);
            }
    
            if (isIsolated !== undefined) { 
                localVarFormParams.set('isIsolated', isIsolated as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (pendingClientOrderId !== undefined) { 
                localVarFormParams.set('pendingClientOrderId', pendingClientOrderId as any);
            }
    
            if (pendingIcebergQty !== undefined) { 
                localVarFormParams.set('pendingIcebergQty', pendingIcebergQty as any);
            }
    
            if (pendingPrice !== undefined) { 
                localVarFormParams.set('pendingPrice', pendingPrice as any);
            }
    
            if (pendingQuantity !== undefined) { 
                localVarFormParams.set('pendingQuantity', pendingQuantity as any);
            }
    
            if (pendingSide !== undefined) { 
                localVarFormParams.set('pendingSide', pendingSide as any);
            }
    
            if (pendingStopPrice !== undefined) { 
                localVarFormParams.set('pendingStopPrice', pendingStopPrice as any);
            }
    
            if (pendingTimeInForce !== undefined) { 
                localVarFormParams.set('pendingTimeInForce', pendingTimeInForce as any);
            }
    
            if (pendingTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingTrailingDelta', pendingTrailingDelta as any);
            }
    
            if (pendingType !== undefined) { 
                localVarFormParams.set('pendingType', pendingType as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (sideEffectType !== undefined) { 
                localVarFormParams.set('sideEffectType', sideEffectType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (workingClientOrderId !== undefined) { 
                localVarFormParams.set('workingClientOrderId', workingClientOrderId as any);
            }
    
            if (workingIcebergQty !== undefined) { 
                localVarFormParams.set('workingIcebergQty', workingIcebergQty as any);
            }
    
            if (workingPrice !== undefined) { 
                localVarFormParams.set('workingPrice', workingPrice as any);
            }
    
            if (workingQuantity !== undefined) { 
                localVarFormParams.set('workingQuantity', workingQuantity as any);
            }
    
            if (workingSide !== undefined) { 
                localVarFormParams.set('workingSide', workingSide as any);
            }
    
            if (workingTimeInForce !== undefined) { 
                localVarFormParams.set('workingTimeInForce', workingTimeInForce as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post a new OTOCO order for margin account：
         * @summary Margin Account New OTOCO (TRADE)
         * @param {CreateMarginOrderOtocoV1PendingAboveTypeEnum} pendingAboveType 
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} symbol 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {CreateMarginOrderOtocoV1WorkingTypeEnum} workingType 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [isIsolated] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingAboveClientOrderId] 
         * @param {string} [pendingAboveIcebergQty] 
         * @param {string} [pendingAbovePrice] 
         * @param {string} [pendingAboveStopPrice] 
         * @param {string} [pendingAboveTimeInForce] 
         * @param {string} [pendingAboveTrailingDelta] 
         * @param {string} [pendingBelowClientOrderId] 
         * @param {string} [pendingBelowIcebergQty] 
         * @param {string} [pendingBelowPrice] 
         * @param {string} [pendingBelowStopPrice] 
         * @param {string} [pendingBelowTimeInForce] 
         * @param {string} [pendingBelowTrailingDelta] 
         * @param {CreateMarginOrderOtocoV1PendingBelowTypeEnum} [pendingBelowType] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderOtocoV1: async (pendingAboveType: CreateMarginOrderOtocoV1PendingAboveTypeEnum, pendingQuantity: string, pendingSide: string, symbol: string, workingPrice: string, workingQuantity: string, workingSide: string, workingType: CreateMarginOrderOtocoV1WorkingTypeEnum, autoRepayAtCancel?: boolean, isIsolated?: string, listClientOrderId?: string, newOrderRespType?: string, pendingAboveClientOrderId?: string, pendingAboveIcebergQty?: string, pendingAbovePrice?: string, pendingAboveStopPrice?: string, pendingAboveTimeInForce?: string, pendingAboveTrailingDelta?: string, pendingBelowClientOrderId?: string, pendingBelowIcebergQty?: string, pendingBelowPrice?: string, pendingBelowStopPrice?: string, pendingBelowTimeInForce?: string, pendingBelowTrailingDelta?: string, pendingBelowType?: CreateMarginOrderOtocoV1PendingBelowTypeEnum, selfTradePreventionMode?: string, sideEffectType?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingAboveType' is not null or undefined
            assertParamExists('createMarginOrderOtocoV1', 'pendingAboveType', pendingAboveType)
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('createMarginOrderOtocoV1', 'pendingQuantity', pendingQuantity)
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('createMarginOrderOtocoV1', 'pendingSide', pendingSide)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginOrderOtocoV1', 'symbol', symbol)
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('createMarginOrderOtocoV1', 'workingPrice', workingPrice)
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('createMarginOrderOtocoV1', 'workingQuantity', workingQuantity)
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('createMarginOrderOtocoV1', 'workingSide', workingSide)
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('createMarginOrderOtocoV1', 'workingType', workingType)
            const localVarPath = `/sapi/v1/margin/order/otoco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (autoRepayAtCancel !== undefined) { 
                localVarFormParams.set('autoRepayAtCancel', autoRepayAtCancel as any);
            }
    
            if (isIsolated !== undefined) { 
                localVarFormParams.set('isIsolated', isIsolated as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (pendingAboveClientOrderId !== undefined) { 
                localVarFormParams.set('pendingAboveClientOrderId', pendingAboveClientOrderId as any);
            }
    
            if (pendingAboveIcebergQty !== undefined) { 
                localVarFormParams.set('pendingAboveIcebergQty', pendingAboveIcebergQty as any);
            }
    
            if (pendingAbovePrice !== undefined) { 
                localVarFormParams.set('pendingAbovePrice', pendingAbovePrice as any);
            }
    
            if (pendingAboveStopPrice !== undefined) { 
                localVarFormParams.set('pendingAboveStopPrice', pendingAboveStopPrice as any);
            }
    
            if (pendingAboveTimeInForce !== undefined) { 
                localVarFormParams.set('pendingAboveTimeInForce', pendingAboveTimeInForce as any);
            }
    
            if (pendingAboveTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingAboveTrailingDelta', pendingAboveTrailingDelta as any);
            }
    
            if (pendingAboveType !== undefined) { 
                localVarFormParams.set('pendingAboveType', pendingAboveType as any);
            }
    
            if (pendingBelowClientOrderId !== undefined) { 
                localVarFormParams.set('pendingBelowClientOrderId', pendingBelowClientOrderId as any);
            }
    
            if (pendingBelowIcebergQty !== undefined) { 
                localVarFormParams.set('pendingBelowIcebergQty', pendingBelowIcebergQty as any);
            }
    
            if (pendingBelowPrice !== undefined) { 
                localVarFormParams.set('pendingBelowPrice', pendingBelowPrice as any);
            }
    
            if (pendingBelowStopPrice !== undefined) { 
                localVarFormParams.set('pendingBelowStopPrice', pendingBelowStopPrice as any);
            }
    
            if (pendingBelowTimeInForce !== undefined) { 
                localVarFormParams.set('pendingBelowTimeInForce', pendingBelowTimeInForce as any);
            }
    
            if (pendingBelowTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingBelowTrailingDelta', pendingBelowTrailingDelta as any);
            }
    
            if (pendingBelowType !== undefined) { 
                localVarFormParams.set('pendingBelowType', pendingBelowType as any);
            }
    
            if (pendingQuantity !== undefined) { 
                localVarFormParams.set('pendingQuantity', pendingQuantity as any);
            }
    
            if (pendingSide !== undefined) { 
                localVarFormParams.set('pendingSide', pendingSide as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (sideEffectType !== undefined) { 
                localVarFormParams.set('sideEffectType', sideEffectType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (workingClientOrderId !== undefined) { 
                localVarFormParams.set('workingClientOrderId', workingClientOrderId as any);
            }
    
            if (workingIcebergQty !== undefined) { 
                localVarFormParams.set('workingIcebergQty', workingIcebergQty as any);
            }
    
            if (workingPrice !== undefined) { 
                localVarFormParams.set('workingPrice', workingPrice as any);
            }
    
            if (workingQuantity !== undefined) { 
                localVarFormParams.set('workingQuantity', workingQuantity as any);
            }
    
            if (workingSide !== undefined) { 
                localVarFormParams.set('workingSide', workingSide as any);
            }
    
            if (workingTimeInForce !== undefined) { 
                localVarFormParams.set('workingTimeInForce', workingTimeInForce as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post a new order for margin account.
         * @summary Margin Account New Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [icebergQty] 
         * @param {string} [isIsolated] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderV1: async (side: string, symbol: string, timestamp: number, type: string, autoRepayAtCancel?: boolean, icebergQty?: string, isIsolated?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, sideEffectType?: string, stopPrice?: string, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createMarginOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createMarginOrderV1', 'type', type)
            const localVarPath = `/sapi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (autoRepayAtCancel !== undefined) { 
                localVarFormParams.set('autoRepayAtCancel', autoRepayAtCancel as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (isIsolated !== undefined) { 
                localVarFormParams.set('isIsolated', isIsolated as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (sideEffectType !== undefined) { 
                localVarFormParams.set('sideEffectType', sideEffectType as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new isolated margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start Isolated Margin User Data Stream (USER_STREAM)
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDataStreamIsolatedV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createUserDataStreamIsolatedV1', 'symbol', symbol)
            const localVarPath = `/sapi/v1/userDataStream/isolated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start Margin User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDataStreamV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/userDataStream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This only applies to Special Key for Low Latency Trading.
         * @summary Delete Special Key(Low-Latency Trading)(TRADE)
         * @param {number} timestamp 
         * @param {string} [apiKey] 
         * @param {string} [apiName] 
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginApiKeyV1: async (timestamp: number, apiKey?: string, apiName?: string, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMarginApiKeyV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/apiKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            if (apiName !== undefined) {
                localVarQueryParameter['apiName'] = apiName;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours.
         * @summary Disable Isolated Margin Account (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginIsolatedAccountV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteMarginIsolatedAccountV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMarginIsolatedAccountV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/isolated/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/margin/listen-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels all active orders on a symbol for margin account. This includes OCO orders.
         * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOpenOrdersV1: async (symbol: string, timestamp: number, isIsolated?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteMarginOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMarginOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an entire Order List for a margin account.
         * @summary Margin Account Cancel OCO (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOrderListV1: async (symbol: string, timestamp: number, isIsolated?: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteMarginOrderListV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMarginOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (listClientOrderId !== undefined) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order for margin account.
         * @summary Margin Account Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOrderV1: async (symbol: string, timestamp: number, isIsolated?: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMarginOrderV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a isolated margin user data stream.
         * @summary Close Isolated Margin User Data Stream (USER_STREAM)
         * @param {string} symbol 
         * @param {string} listenkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDataStreamIsolatedV1: async (symbol: string, listenkey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteUserDataStreamIsolatedV1', 'symbol', symbol)
            // verify required parameter 'listenkey' is not null or undefined
            assertParamExists('deleteUserDataStreamIsolatedV1', 'listenkey', listenkey)
            const localVarPath = `/sapi/v1/userDataStream/isolated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listenkey !== undefined) {
                localVarQueryParameter['listenkey'] = listenkey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a Margin user data stream.
         * @summary Close Margin User Data Stream (USER_STREAM)
         * @param {string} listenkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDataStreamV1: async (listenkey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listenkey' is not null or undefined
            assertParamExists('deleteUserDataStreamV1', 'listenkey', listenkey)
            const localVarPath = `/sapi/v1/userDataStream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (listenkey !== undefined) {
                localVarQueryParameter['listenkey'] = listenkey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get BNB Burn Status
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnbBurnV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBnbBurnV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/bnbBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Cross Margin Account Details
         * @summary Query Cross Margin Account Details (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAccountV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginAccountV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get All Margin Assets.
         * @summary Get All Margin Assets (MARKET_DATA)
         * @param {string} [asset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllAssetsV1: async (asset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/margin/allAssets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {string} [symbol] mandatory for isolated margin, not supported for cross margin
         * @param {number} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllOrderListV1: async (timestamp: number, isIsolated?: string, symbol?: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginAllOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/allOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account\'s All Orders
         * @summary Query Margin Account\'s All Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllOrdersV1: async (symbol: string, timestamp: number, isIsolated?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get All Cross Margin Pairs
         * @summary Get All Cross Margin Pairs (MARKET_DATA)
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllPairsV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/margin/allPairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This only applies to Special Key for Low Latency Trading.
         * @summary Query Special key List(Low Latency Trading)(TRADE)
         * @param {number} timestamp 
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginApiKeyListV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginApiKeyListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/api-key-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Special Key Information.
         * @summary Query Special key(Low Latency Trading)(TRADE)
         * @param {string} apiKey 
         * @param {number} timestamp 
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginApiKeyV1: async (apiKey: string, timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getMarginApiKeyV1', 'apiKey', apiKey)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginApiKeyV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/apiKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Margin available Inventory query
         * @summary Query Margin Available Inventory(USER_DATA)
         * @param {string} type MARGIN,ISOLATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAvailableInventoryV1: async (type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getMarginAvailableInventoryV1', 'type', type)
            const localVarPath = `/sapi/v1/margin/available-inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query borrow/repay records in Margin account
         * @summary Query borrow/repay records in Margin account(USER_DATA)
         * @param {string} type &#x60;BORROW&#x60; or &#x60;REPAY&#x60;
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {string} [isolatedSymbol] Symbol in Isolated Margin
         * @param {number} [txId] &#x60;tranId&#x60; in &#x60;POST /sapi/v1/margin/loan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginBorrowRepayV1: async (type: string, timestamp: number, asset?: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getMarginBorrowRepayV1', 'type', type)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginBorrowRepayV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/borrow-repay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (isolatedSymbol !== undefined) {
                localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
            }

            if (txId !== undefined) {
                localVarQueryParameter['txId'] = txId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Cross Isolated Margin Capital Flow
         * @summary Query Cross Isolated Margin Capital Flow (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {string} [symbol] 查询逐仓数据时必填
         * @param {string} [type] 
         * @param {number} [startTime] 只支持查询最近90天的数据
         * @param {number} [endTime] 
         * @param {number} [fromId] 如设置fromId, 将返回id &amp;gt; fromId的数据。否则将返回最新数据
         * @param {number} [limit] 每次返回的数据条数限制。默认 500; 最大 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginCapitalFlowV1: async (timestamp: number, asset?: string, symbol?: string, type?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginCapitalFlowV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/capital-flow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cross margin collateral ratio
         * @summary Cross margin collateral ratio (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginCrossMarginCollateralRatioV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/margin/crossMarginCollateralRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get cross margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
         * @summary Query Cross Margin Fee Data (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [vipLevel] User&amp;#39;s current specific margin data will be returned if vipLevel is omitted
         * @param {string} [coin] 
         * @param {number} [recvWindow] No more than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginCrossMarginDataV1: async (timestamp: number, vipLevel?: number, coin?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginCrossMarginDataV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/crossMarginData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (vipLevel !== undefined) {
                localVarQueryParameter['vipLevel'] = vipLevel;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tokens or symbols delist schedule for cross margin and isolated margin
         * @summary Get Delist Schedule (MARKET_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginDelistScheduleV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginDelistScheduleV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/delist-schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Small liability Exchange History
         * @summary Get Small Liability Exchange History (USER_DATA)
         * @param {number} current Currently querying page. Start from 1. Default:1
         * @param {number} size Default:10, Max:100
         * @param {number} timestamp 
         * @param {number} [startTime] Default: 30 days from current timestamp
         * @param {number} [endTime] Default: present timestamp
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginExchangeSmallLiabilityHistoryV1: async (current: number, size: number, timestamp: number, startTime?: number, endTime?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'current' is not null or undefined
            assertParamExists('getMarginExchangeSmallLiabilityHistoryV1', 'current', current)
            // verify required parameter 'size' is not null or undefined
            assertParamExists('getMarginExchangeSmallLiabilityHistoryV1', 'size', size)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginExchangeSmallLiabilityHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/exchange-small-liability-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the coins which can be small liability exchange
         * @summary Get Small Liability Exchange Coin List (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginExchangeSmallLiabilityV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginExchangeSmallLiabilityV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/exchange-small-liability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Force Liquidation Record
         * @summary Get Force Liquidation Record (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {string} [isolatedSymbol] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginForceLiquidationRecV1: async (timestamp: number, startTime?: number, endTime?: number, isolatedSymbol?: string, current?: number, size?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginForceLiquidationRecV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/forceLiquidationRec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (isolatedSymbol !== undefined) {
                localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Interest History
         * @summary Get Interest History (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {string} [isolatedSymbol] isolated symbol
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginInterestHistoryV1: async (timestamp: number, asset?: string, isolatedSymbol?: string, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginInterestHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/interestHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (isolatedSymbol !== undefined) {
                localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Interest Rate History
         * @summary Query Margin Interest Rate History (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [vipLevel] Default: user&amp;#39;s vip level
         * @param {number} [startTime] Default: 7 days ago
         * @param {number} [endTime] Default: present. Maximum range: 1 months.
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginInterestRateHistoryV1: async (asset: string, timestamp: number, vipLevel?: number, startTime?: number, endTime?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getMarginInterestRateHistoryV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginInterestRateHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/interestRateHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (vipLevel !== undefined) {
                localVarQueryParameter['vipLevel'] = vipLevel;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query enabled isolated margin account limit.
         * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedAccountLimitV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginIsolatedAccountLimitV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/isolated/accountLimit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Isolated Margin Account Info
         * @summary Query Isolated Margin Account Info (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbols] Max 5 symbols can be sent; separated by &amp;#34;,&amp;#34;. e.g. &amp;#34;BTCUSDT,BNBUSDT,ADAUSDT&amp;#34;
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedAccountV1: async (timestamp: number, symbols?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginIsolatedAccountV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/isolated/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get All Isolated Margin Symbol
         * @summary Get All Isolated Margin Symbol(MARKET_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedAllPairsV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginIsolatedAllPairsV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/isolated/allPairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get isolated margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
         * @summary Query Isolated Margin Fee Data (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [vipLevel] User&amp;#39;s current specific margin data will be returned if vipLevel is omitted
         * @param {string} [symbol] 
         * @param {number} [recvWindow] No more than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedMarginDataV1: async (timestamp: number, vipLevel?: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginIsolatedMarginDataV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/isolatedMarginData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (vipLevel !== undefined) {
                localVarQueryParameter['vipLevel'] = vipLevel;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data
         * @summary Query Isolated Margin Tier Data (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [tier] All margin tier data will be returned if tier is omitted
         * @param {number} [recvWindow] No more than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedMarginTierV1: async (symbol: string, timestamp: number, tier?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginIsolatedMarginTierV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginIsolatedMarginTierV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/isolatedMarginTier`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (tier !== undefined) {
                localVarQueryParameter['tier'] = tier;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Liability Coin Leverage Bracket in Cross Margin Pro Mode
         * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginLeverageBracketV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/margin/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Max Borrow
         * @summary Query Max Borrow (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {string} [isolatedSymbol] isolated symbol
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMaxBorrowableV1: async (asset: string, timestamp: number, isolatedSymbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getMarginMaxBorrowableV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginMaxBorrowableV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/maxBorrowable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (isolatedSymbol !== undefined) {
                localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Max Transfer-Out Amount
         * @summary Query Max Transfer-Out Amount (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {string} [isolatedSymbol] isolated symbol
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMaxTransferableV1: async (asset: string, timestamp: number, isolatedSymbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getMarginMaxTransferableV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginMaxTransferableV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/maxTransferable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (isolatedSymbol !== undefined) {
                localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account\'s Trade List
         * @summary Query Margin Account\'s Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMyTradesV1: async (symbol: string, timestamp: number, isIsolated?: string, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginMyTradesV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginMyTradesV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/myTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get future hourly interest rate
         * @summary Get future hourly interest rate (USER_DATA)
         * @param {string} assets List of assets, separated by commas, up to 20
         * @param {boolean} isIsolated for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginNextHourlyInterestRateV1: async (assets: string, isIsolated: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assets' is not null or undefined
            assertParamExists('getMarginNextHourlyInterestRateV1', 'assets', assets)
            // verify required parameter 'isIsolated' is not null or undefined
            assertParamExists('getMarginNextHourlyInterestRateV1', 'isIsolated', isIsolated)
            const localVarPath = `/sapi/v1/margin/next-hourly-interest-rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {string} [symbol] mandatory for isolated margin, not supported for cross margin
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOpenOrderListV1: async (timestamp: number, isIsolated?: string, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginOpenOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/openOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account\'s Open Orders
         * @summary Query Margin Account\'s Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOpenOrdersV1: async (timestamp: number, symbol?: string, isIsolated?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {string} [symbol] mandatory for isolated margin, not supported for cross margin
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
         * @param {string} [origClientOrderId] Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOrderListV1: async (timestamp: number, isIsolated?: string, symbol?: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginOrderListV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin Account\'s Order
         * @summary Query Margin Account\'s Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOrderV1: async (symbol: string, timestamp: number, isIsolated?: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginOrderV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Margin PriceIndex
         * @summary Query Margin PriceIndex (MARKET_DATA)
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginPriceIndexV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarginPriceIndexV1', 'symbol', symbol)
            const localVarPath = `/sapi/v1/margin/priceIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Displays the user\'s current margin order count usage for all intervals.
         * @summary Query Current Margin Order Count Usage (TRADE)
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {string} [symbol] isolated symbol, mandatory for isolated margin
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginRateLimitOrderV1: async (timestamp: number, isIsolated?: string, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginRateLimitOrderV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/rateLimit/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (isIsolated !== undefined) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get personal margin level information
         * @summary Get Summary of Margin account (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginTradeCoeffV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginTradeCoeffV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/tradeCoeff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Cross Margin Transfer History
         * @summary Get Cross Margin Transfer History (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {string} [type] Transfer Type: ROLL_IN, ROLL_OUT
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [isolatedSymbol] Symbol in Isolated Margin
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginTransferV1: async (timestamp: number, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, isolatedSymbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMarginTransferV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (isolatedSymbol !== undefined) {
                localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit ip restriction. This only applies to Special Key for Low Latency Trading.
         * @summary Edit ip for Special Key(Low-Latency Trading)(TRADE)
         * @param {string} apiKey 
         * @param {string} ip 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMarginApiKeyIpV1: async (apiKey: string, ip: string, timestamp: number, recvWindow?: number, symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('updateMarginApiKeyIpV1', 'apiKey', apiKey)
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('updateMarginApiKeyIpV1', 'ip', ip)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateMarginApiKeyIpV1', 'timestamp', timestamp)
            const localVarPath = `/sapi/v1/margin/apiKey/ip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (apiKey !== undefined) { 
                localVarFormParams.set('apiKey', apiKey as any);
            }
    
            if (ip !== undefined) { 
                localVarFormParams.set('ip', ip as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a user data stream to prevent a time out.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMarginListenKeyV1: async (listenKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listenKey' is not null or undefined
            assertParamExists('updateMarginListenKeyV1', 'listenKey', listenKey)
            const localVarPath = `/sapi/v1/margin/listen-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (listenKey !== undefined) { 
                localVarFormParams.set('listenKey', listenKey as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive an isolated margin user data stream to prevent a time out.
         * @summary Keepalive Isolated Margin User Data Stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDataStreamIsolatedV1: async (listenKey: string, symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listenKey' is not null or undefined
            assertParamExists('updateUserDataStreamIsolatedV1', 'listenKey', listenKey)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('updateUserDataStreamIsolatedV1', 'symbol', symbol)
            const localVarPath = `/sapi/v1/userDataStream/isolated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (listenKey !== undefined) { 
                localVarFormParams.set('listenKey', listenKey as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a margin user data stream to prevent a time out.
         * @summary Keepalive Margin User Data Stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDataStreamV1: async (listenKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listenKey' is not null or undefined
            assertParamExists('updateUserDataStreamV1', 'listenKey', listenKey)
            const localVarPath = `/sapi/v1/userDataStream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (listenKey !== undefined) { 
                localVarFormParams.set('listenKey', listenKey as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarginTradingApi - functional programming interface
 * @export
 */
export const MarginTradingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarginTradingApiAxiosParamCreator(configuration)
    return {
        /**
         * **Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **
         * @summary Create Special Key(Low-Latency Trading)(TRADE)
         * @param {string} apiName 
         * @param {number} timestamp 
         * @param {string} [ip] 
         * @param {string} [permissionMode] 
         * @param {string} [publicKey] 
         * @param {number} [recvWindow] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginApiKeyV1(apiName: string, timestamp: number, ip?: string, permissionMode?: string, publicKey?: string, recvWindow?: number, symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginApiKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginApiKeyV1(apiName, timestamp, ip, permissionMode, publicKey, recvWindow, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginApiKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Margin account borrow/repay(MARGIN)
         * @summary Margin account borrow/repay(MARGIN)
         * @param {string} amount 
         * @param {string} asset 
         * @param {string} isIsolated 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginBorrowRepayV1(amount: string, asset: string, isIsolated: string, symbol: string, timestamp: number, type: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginBorrowRepayV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginBorrowRepayV1(amount, asset, isIsolated, symbol, timestamp, type, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginBorrowRepayV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Small Liability Exchange
         * @summary Small Liability Exchange (MARGIN)
         * @param {Array<string>} assetNames 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginExchangeSmallLiabilityV1(assetNames: Array<string>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarginCreateMarginExchangeSmallLiabilityV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginExchangeSmallLiabilityV1(assetNames, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginExchangeSmallLiabilityV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).
         * @summary Enable Isolated Margin Account (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginIsolatedAccountV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginIsolatedAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginIsolatedAccountV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginIsolatedAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new user data stream.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Margin Manual Liquidation
         * @summary Margin Manual Liquidation(MARGIN)
         * @param {number} timestamp 
         * @param {string} type 
         * @param {number} [recvWindow] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginManualLiquidationV1(timestamp: number, type: string, recvWindow?: number, symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginManualLiquidationV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginManualLiquidationV1(timestamp, type, recvWindow, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginManualLiquidationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adjust cross margin max leverage
         * @summary Adjust cross margin max leverage (USER_DATA)
         * @param {number} maxLeverage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginMaxLeverageV1(maxLeverage: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginMaxLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginMaxLeverageV1(maxLeverage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginMaxLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [isIsolated] 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginOrderOcoV1(price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, autoRepayAtCancel?: boolean, isIsolated?: string, limitClientOrderId?: string, limitIcebergQty?: string, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, selfTradePreventionMode?: string, sideEffectType?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginOrderOcoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginOrderOcoV1(price, quantity, side, stopPrice, symbol, timestamp, autoRepayAtCancel, isIsolated, limitClientOrderId, limitIcebergQty, listClientOrderId, newOrderRespType, recvWindow, selfTradePreventionMode, sideEffectType, stopClientOrderId, stopIcebergQty, stopLimitPrice, stopLimitTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginOrderOcoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Post a new OTO order for margin account:
         * @summary Margin Account New OTO (TRADE)
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} pendingType 
         * @param {string} symbol 
         * @param {string} workingIcebergQty 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {CreateMarginOrderOtoV1WorkingTypeEnum} workingType 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [isIsolated] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingClientOrderId] 
         * @param {string} [pendingIcebergQty] 
         * @param {string} [pendingPrice] 
         * @param {string} [pendingStopPrice] 
         * @param {string} [pendingTimeInForce] 
         * @param {string} [pendingTrailingDelta] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginOrderOtoV1(pendingQuantity: string, pendingSide: string, pendingType: string, symbol: string, workingIcebergQty: string, workingPrice: string, workingQuantity: string, workingSide: string, workingType: CreateMarginOrderOtoV1WorkingTypeEnum, autoRepayAtCancel?: boolean, isIsolated?: string, listClientOrderId?: string, newOrderRespType?: string, pendingClientOrderId?: string, pendingIcebergQty?: string, pendingPrice?: string, pendingStopPrice?: string, pendingTimeInForce?: string, pendingTrailingDelta?: string, selfTradePreventionMode?: string, sideEffectType?: string, workingClientOrderId?: string, workingTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginOrderOtoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginOrderOtoV1(pendingQuantity, pendingSide, pendingType, symbol, workingIcebergQty, workingPrice, workingQuantity, workingSide, workingType, autoRepayAtCancel, isIsolated, listClientOrderId, newOrderRespType, pendingClientOrderId, pendingIcebergQty, pendingPrice, pendingStopPrice, pendingTimeInForce, pendingTrailingDelta, selfTradePreventionMode, sideEffectType, workingClientOrderId, workingTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginOrderOtoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Post a new OTOCO order for margin account：
         * @summary Margin Account New OTOCO (TRADE)
         * @param {CreateMarginOrderOtocoV1PendingAboveTypeEnum} pendingAboveType 
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} symbol 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {CreateMarginOrderOtocoV1WorkingTypeEnum} workingType 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [isIsolated] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingAboveClientOrderId] 
         * @param {string} [pendingAboveIcebergQty] 
         * @param {string} [pendingAbovePrice] 
         * @param {string} [pendingAboveStopPrice] 
         * @param {string} [pendingAboveTimeInForce] 
         * @param {string} [pendingAboveTrailingDelta] 
         * @param {string} [pendingBelowClientOrderId] 
         * @param {string} [pendingBelowIcebergQty] 
         * @param {string} [pendingBelowPrice] 
         * @param {string} [pendingBelowStopPrice] 
         * @param {string} [pendingBelowTimeInForce] 
         * @param {string} [pendingBelowTrailingDelta] 
         * @param {CreateMarginOrderOtocoV1PendingBelowTypeEnum} [pendingBelowType] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginOrderOtocoV1(pendingAboveType: CreateMarginOrderOtocoV1PendingAboveTypeEnum, pendingQuantity: string, pendingSide: string, symbol: string, workingPrice: string, workingQuantity: string, workingSide: string, workingType: CreateMarginOrderOtocoV1WorkingTypeEnum, autoRepayAtCancel?: boolean, isIsolated?: string, listClientOrderId?: string, newOrderRespType?: string, pendingAboveClientOrderId?: string, pendingAboveIcebergQty?: string, pendingAbovePrice?: string, pendingAboveStopPrice?: string, pendingAboveTimeInForce?: string, pendingAboveTrailingDelta?: string, pendingBelowClientOrderId?: string, pendingBelowIcebergQty?: string, pendingBelowPrice?: string, pendingBelowStopPrice?: string, pendingBelowTimeInForce?: string, pendingBelowTrailingDelta?: string, pendingBelowType?: CreateMarginOrderOtocoV1PendingBelowTypeEnum, selfTradePreventionMode?: string, sideEffectType?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginOrderOtocoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginOrderOtocoV1(pendingAboveType, pendingQuantity, pendingSide, symbol, workingPrice, workingQuantity, workingSide, workingType, autoRepayAtCancel, isIsolated, listClientOrderId, newOrderRespType, pendingAboveClientOrderId, pendingAboveIcebergQty, pendingAbovePrice, pendingAboveStopPrice, pendingAboveTimeInForce, pendingAboveTrailingDelta, pendingBelowClientOrderId, pendingBelowIcebergQty, pendingBelowPrice, pendingBelowStopPrice, pendingBelowTimeInForce, pendingBelowTrailingDelta, pendingBelowType, selfTradePreventionMode, sideEffectType, workingClientOrderId, workingIcebergQty, workingTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginOrderOtocoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Post a new order for margin account.
         * @summary Margin Account New Order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [autoRepayAtCancel] 
         * @param {string} [icebergQty] 
         * @param {string} [isIsolated] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [sideEffectType] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginOrderV1(side: string, symbol: string, timestamp: number, type: string, autoRepayAtCancel?: boolean, icebergQty?: string, isIsolated?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, sideEffectType?: string, stopPrice?: string, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarginCreateMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginOrderV1(side, symbol, timestamp, type, autoRepayAtCancel, icebergQty, isIsolated, newClientOrderId, newOrderRespType, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, sideEffectType, stopPrice, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new isolated margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start Isolated Margin User Data Stream (USER_STREAM)
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserDataStreamIsolatedV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDataStreamIsolatedV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserDataStreamIsolatedV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createUserDataStreamIsolatedV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start Margin User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserDataStreamV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDataStreamV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserDataStreamV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.createUserDataStreamV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This only applies to Special Key for Low Latency Trading.
         * @summary Delete Special Key(Low-Latency Trading)(TRADE)
         * @param {number} timestamp 
         * @param {string} [apiKey] 
         * @param {string} [apiName] 
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginApiKeyV1(timestamp: number, apiKey?: string, apiName?: string, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginApiKeyV1(timestamp, apiKey, apiName, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.deleteMarginApiKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours.
         * @summary Disable Isolated Margin Account (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginIsolatedAccountV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMarginIsolatedAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginIsolatedAccountV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.deleteMarginIsolatedAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.deleteMarginListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancels all active orders on a symbol for margin account. This includes OCO orders.
         * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginOpenOrdersV1(symbol: string, timestamp: number, isIsolated?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeleteMarginOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginOpenOrdersV1(symbol, timestamp, isIsolated, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.deleteMarginOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an entire Order List for a margin account.
         * @summary Margin Account Cancel OCO (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginOrderListV1(symbol: string, timestamp: number, isIsolated?: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMarginOrderListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginOrderListV1(symbol, timestamp, isIsolated, orderListId, listClientOrderId, newClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.deleteMarginOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order for margin account.
         * @summary Margin Account Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarginOrderV1(symbol: string, timestamp: number, isIsolated?: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarginOrderV1(symbol, timestamp, isIsolated, orderId, origClientOrderId, newClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.deleteMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a isolated margin user data stream.
         * @summary Close Isolated Margin User Data Stream (USER_STREAM)
         * @param {string} symbol 
         * @param {string} listenkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserDataStreamIsolatedV1(symbol: string, listenkey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserDataStreamIsolatedV1(symbol, listenkey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.deleteUserDataStreamIsolatedV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a Margin user data stream.
         * @summary Close Margin User Data Stream (USER_STREAM)
         * @param {string} listenkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserDataStreamV1(listenkey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserDataStreamV1(listenkey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.deleteUserDataStreamV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get BNB Burn Status
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBnbBurnV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBnbBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBnbBurnV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getBnbBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Cross Margin Account Details
         * @summary Query Cross Margin Account Details (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAccountV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAccountV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get All Margin Assets.
         * @summary Get All Margin Assets (MARKET_DATA)
         * @param {string} [asset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAllAssetsV1(asset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginAllAssetsV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAllAssetsV1(asset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginAllAssetsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {string} [symbol] mandatory for isolated margin, not supported for cross margin
         * @param {number} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAllOrderListV1(timestamp: number, isIsolated?: string, symbol?: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginAllOrderListV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAllOrderListV1(timestamp, isIsolated, symbol, fromId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginAllOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account\'s All Orders
         * @summary Query Margin Account\'s All Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 500.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAllOrdersV1(symbol: string, timestamp: number, isIsolated?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAllOrdersV1(symbol, timestamp, isIsolated, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get All Cross Margin Pairs
         * @summary Get All Cross Margin Pairs (MARKET_DATA)
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAllPairsV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginAllPairsV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAllPairsV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginAllPairsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This only applies to Special Key for Low Latency Trading.
         * @summary Query Special key List(Low Latency Trading)(TRADE)
         * @param {number} timestamp 
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginApiKeyListV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginApiKeyListV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginApiKeyListV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginApiKeyListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Special Key Information.
         * @summary Query Special key(Low Latency Trading)(TRADE)
         * @param {string} apiKey 
         * @param {number} timestamp 
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginApiKeyV1(apiKey: string, timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginApiKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginApiKeyV1(apiKey, timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginApiKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Margin available Inventory query
         * @summary Query Margin Available Inventory(USER_DATA)
         * @param {string} type MARGIN,ISOLATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginAvailableInventoryV1(type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarginGetMarginAvailableInventoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginAvailableInventoryV1(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginAvailableInventoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query borrow/repay records in Margin account
         * @summary Query borrow/repay records in Margin account(USER_DATA)
         * @param {string} type &#x60;BORROW&#x60; or &#x60;REPAY&#x60;
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {string} [isolatedSymbol] Symbol in Isolated Margin
         * @param {number} [txId] &#x60;tranId&#x60; in &#x60;POST /sapi/v1/margin/loan&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginBorrowRepayV1(type: string, timestamp: number, asset?: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginBorrowRepayV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginBorrowRepayV1(type, timestamp, asset, isolatedSymbol, txId, startTime, endTime, current, size, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginBorrowRepayV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Cross Isolated Margin Capital Flow
         * @summary Query Cross Isolated Margin Capital Flow (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {string} [symbol] 查询逐仓数据时必填
         * @param {string} [type] 
         * @param {number} [startTime] 只支持查询最近90天的数据
         * @param {number} [endTime] 
         * @param {number} [fromId] 如设置fromId, 将返回id &amp;gt; fromId的数据。否则将返回最新数据
         * @param {number} [limit] 每次返回的数据条数限制。默认 500; 最大 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginCapitalFlowV1(timestamp: number, asset?: string, symbol?: string, type?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginCapitalFlowV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginCapitalFlowV1(timestamp, asset, symbol, type, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginCapitalFlowV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cross margin collateral ratio
         * @summary Cross margin collateral ratio (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginCrossMarginCollateralRatioV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginCrossMarginCollateralRatioV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginCrossMarginCollateralRatioV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginCrossMarginCollateralRatioV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get cross margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
         * @summary Query Cross Margin Fee Data (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [vipLevel] User&amp;#39;s current specific margin data will be returned if vipLevel is omitted
         * @param {string} [coin] 
         * @param {number} [recvWindow] No more than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginCrossMarginDataV1(timestamp: number, vipLevel?: number, coin?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginCrossMarginDataV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginCrossMarginDataV1(timestamp, vipLevel, coin, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginCrossMarginDataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tokens or symbols delist schedule for cross margin and isolated margin
         * @summary Get Delist Schedule (MARKET_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginDelistScheduleV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginDelistScheduleV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginDelistScheduleV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginDelistScheduleV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Small liability Exchange History
         * @summary Get Small Liability Exchange History (USER_DATA)
         * @param {number} current Currently querying page. Start from 1. Default:1
         * @param {number} size Default:10, Max:100
         * @param {number} timestamp 
         * @param {number} [startTime] Default: 30 days from current timestamp
         * @param {number} [endTime] Default: present timestamp
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginExchangeSmallLiabilityHistoryV1(current: number, size: number, timestamp: number, startTime?: number, endTime?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginExchangeSmallLiabilityHistoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginExchangeSmallLiabilityHistoryV1(current, size, timestamp, startTime, endTime, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginExchangeSmallLiabilityHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query the coins which can be small liability exchange
         * @summary Get Small Liability Exchange Coin List (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginExchangeSmallLiabilityV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginExchangeSmallLiabilityV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginExchangeSmallLiabilityV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginExchangeSmallLiabilityV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Force Liquidation Record
         * @summary Get Force Liquidation Record (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {string} [isolatedSymbol] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginForceLiquidationRecV1(timestamp: number, startTime?: number, endTime?: number, isolatedSymbol?: string, current?: number, size?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginForceLiquidationRecV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginForceLiquidationRecV1(timestamp, startTime, endTime, isolatedSymbol, current, size, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginForceLiquidationRecV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Interest History
         * @summary Get Interest History (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {string} [isolatedSymbol] isolated symbol
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginInterestHistoryV1(timestamp: number, asset?: string, isolatedSymbol?: string, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginInterestHistoryV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginInterestHistoryV1(timestamp, asset, isolatedSymbol, startTime, endTime, current, size, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginInterestHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Interest Rate History
         * @summary Query Margin Interest Rate History (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [vipLevel] Default: user&amp;#39;s vip level
         * @param {number} [startTime] Default: 7 days ago
         * @param {number} [endTime] Default: present. Maximum range: 1 months.
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginInterestRateHistoryV1(asset: string, timestamp: number, vipLevel?: number, startTime?: number, endTime?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginInterestRateHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginInterestRateHistoryV1(asset, timestamp, vipLevel, startTime, endTime, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginInterestRateHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query enabled isolated margin account limit.
         * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginIsolatedAccountLimitV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginIsolatedAccountLimitV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginIsolatedAccountLimitV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginIsolatedAccountLimitV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Isolated Margin Account Info
         * @summary Query Isolated Margin Account Info (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbols] Max 5 symbols can be sent; separated by &amp;#34;,&amp;#34;. e.g. &amp;#34;BTCUSDT,BNBUSDT,ADAUSDT&amp;#34;
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginIsolatedAccountV1(timestamp: number, symbols?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginIsolatedAccountV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginIsolatedAccountV1(timestamp, symbols, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginIsolatedAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get All Isolated Margin Symbol
         * @summary Get All Isolated Margin Symbol(MARKET_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] No more than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginIsolatedAllPairsV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginIsolatedAllPairsV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginIsolatedAllPairsV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginIsolatedAllPairsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get isolated margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
         * @summary Query Isolated Margin Fee Data (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [vipLevel] User&amp;#39;s current specific margin data will be returned if vipLevel is omitted
         * @param {string} [symbol] 
         * @param {number} [recvWindow] No more than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginIsolatedMarginDataV1(timestamp: number, vipLevel?: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginIsolatedMarginDataV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginIsolatedMarginDataV1(timestamp, vipLevel, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginIsolatedMarginDataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data
         * @summary Query Isolated Margin Tier Data (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [tier] All margin tier data will be returned if tier is omitted
         * @param {number} [recvWindow] No more than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginIsolatedMarginTierV1(symbol: string, timestamp: number, tier?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginIsolatedMarginTierV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginIsolatedMarginTierV1(symbol, timestamp, tier, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginIsolatedMarginTierV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Liability Coin Leverage Bracket in Cross Margin Pro Mode
         * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginLeverageBracketV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginLeverageBracketV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginLeverageBracketV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Max Borrow
         * @summary Query Max Borrow (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {string} [isolatedSymbol] isolated symbol
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginMaxBorrowableV1(asset: string, timestamp: number, isolatedSymbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginMaxBorrowableV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginMaxBorrowableV1(asset, timestamp, isolatedSymbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginMaxBorrowableV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Max Transfer-Out Amount
         * @summary Query Max Transfer-Out Amount (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {string} [isolatedSymbol] isolated symbol
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginMaxTransferableV1(asset: string, timestamp: number, isolatedSymbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginMaxTransferableV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginMaxTransferableV1(asset, timestamp, isolatedSymbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginMaxTransferableV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account\'s Trade List
         * @summary Query Margin Account\'s Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginMyTradesV1(symbol: string, timestamp: number, isIsolated?: string, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginMyTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginMyTradesV1(symbol, timestamp, isIsolated, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginMyTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get future hourly interest rate
         * @summary Get future hourly interest rate (USER_DATA)
         * @param {string} assets List of assets, separated by commas, up to 20
         * @param {boolean} isIsolated for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginNextHourlyInterestRateV1(assets: string, isIsolated: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginNextHourlyInterestRateV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginNextHourlyInterestRateV1(assets, isIsolated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginNextHourlyInterestRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {string} [symbol] mandatory for isolated margin, not supported for cross margin
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginOpenOrderListV1(timestamp: number, isIsolated?: string, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginOpenOrderListV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginOpenOrderListV1(timestamp, isIsolated, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginOpenOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account\'s Open Orders
         * @summary Query Margin Account\'s Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginOpenOrdersV1(timestamp: number, symbol?: string, isIsolated?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MarginGetMarginOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginOpenOrdersV1(timestamp, symbol, isIsolated, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {string} [symbol] mandatory for isolated margin, not supported for cross margin
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
         * @param {string} [origClientOrderId] Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginOrderListV1(timestamp: number, isIsolated?: string, symbol?: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginOrderListV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginOrderListV1(timestamp, isIsolated, symbol, orderListId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginOrderListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin Account\'s Order
         * @summary Query Margin Account\'s Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginOrderV1(symbol: string, timestamp: number, isIsolated?: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginOrderV1(symbol, timestamp, isIsolated, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query Margin PriceIndex
         * @summary Query Margin PriceIndex (MARKET_DATA)
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginPriceIndexV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginPriceIndexV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginPriceIndexV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginPriceIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Displays the user\'s current margin order count usage for all intervals.
         * @summary Query Current Margin Order Count Usage (TRADE)
         * @param {number} timestamp 
         * @param {string} [isIsolated] for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
         * @param {string} [symbol] isolated symbol, mandatory for isolated margin
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginRateLimitOrderV1(timestamp: number, isIsolated?: string, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarginRateLimitOrderV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginRateLimitOrderV1(timestamp, isIsolated, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginRateLimitOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get personal margin level information
         * @summary Get Summary of Margin account (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginTradeCoeffV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginTradeCoeffV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginTradeCoeffV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginTradeCoeffV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Cross Margin Transfer History
         * @summary Get Cross Margin Transfer History (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [asset] 
         * @param {string} [type] Transfer Type: ROLL_IN, ROLL_OUT
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [isolatedSymbol] Symbol in Isolated Margin
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarginTransferV1(timestamp: number, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, isolatedSymbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarginTransferV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarginTransferV1(timestamp, asset, type, startTime, endTime, current, size, isolatedSymbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.getMarginTransferV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit ip restriction. This only applies to Special Key for Low Latency Trading.
         * @summary Edit ip for Special Key(Low-Latency Trading)(TRADE)
         * @param {string} apiKey 
         * @param {string} ip 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMarginApiKeyIpV1(apiKey: string, ip: string, timestamp: number, recvWindow?: number, symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMarginApiKeyIpV1(apiKey, ip, timestamp, recvWindow, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.updateMarginApiKeyIpV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a user data stream to prevent a time out.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMarginListenKeyV1(listenKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMarginListenKeyV1(listenKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.updateMarginListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive an isolated margin user data stream to prevent a time out.
         * @summary Keepalive Isolated Margin User Data Stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserDataStreamIsolatedV1(listenKey: string, symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserDataStreamIsolatedV1(listenKey, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.updateUserDataStreamIsolatedV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a margin user data stream to prevent a time out.
         * @summary Keepalive Margin User Data Stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserDataStreamV1(listenKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserDataStreamV1(listenKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarginTradingApi.updateUserDataStreamV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarginTradingApi - factory interface
 * @export
 */
export const MarginTradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarginTradingApiFp(configuration)
    return {
        /**
         * **Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **
         * @summary Create Special Key(Low-Latency Trading)(TRADE)
         * @param {MarginTradingApiCreateMarginApiKeyV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginApiKeyV1(requestParameters: MarginTradingApiCreateMarginApiKeyV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginApiKeyV1Resp> {
            return localVarFp.createMarginApiKeyV1(requestParameters.apiName, requestParameters.timestamp, requestParameters.ip, requestParameters.permissionMode, requestParameters.publicKey, requestParameters.recvWindow, requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Margin account borrow/repay(MARGIN)
         * @summary Margin account borrow/repay(MARGIN)
         * @param {MarginTradingApiCreateMarginBorrowRepayV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginBorrowRepayV1(requestParameters: MarginTradingApiCreateMarginBorrowRepayV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginBorrowRepayV1Resp> {
            return localVarFp.createMarginBorrowRepayV1(requestParameters.amount, requestParameters.asset, requestParameters.isIsolated, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Small Liability Exchange
         * @summary Small Liability Exchange (MARGIN)
         * @param {MarginTradingApiCreateMarginExchangeSmallLiabilityV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginExchangeSmallLiabilityV1(requestParameters: MarginTradingApiCreateMarginExchangeSmallLiabilityV1Request, options?: RawAxiosRequestConfig): AxiosPromise<MarginCreateMarginExchangeSmallLiabilityV1Resp> {
            return localVarFp.createMarginExchangeSmallLiabilityV1(requestParameters.assetNames, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).
         * @summary Enable Isolated Margin Account (TRADE)
         * @param {MarginTradingApiCreateMarginIsolatedAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginIsolatedAccountV1(requestParameters: MarginTradingApiCreateMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginIsolatedAccountV1Resp> {
            return localVarFp.createMarginIsolatedAccountV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new user data stream.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginListenKeyV1Resp> {
            return localVarFp.createMarginListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Margin Manual Liquidation
         * @summary Margin Manual Liquidation(MARGIN)
         * @param {MarginTradingApiCreateMarginManualLiquidationV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginManualLiquidationV1(requestParameters: MarginTradingApiCreateMarginManualLiquidationV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginManualLiquidationV1Resp> {
            return localVarFp.createMarginManualLiquidationV1(requestParameters.timestamp, requestParameters.type, requestParameters.recvWindow, requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Adjust cross margin max leverage
         * @summary Adjust cross margin max leverage (USER_DATA)
         * @param {MarginTradingApiCreateMarginMaxLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginMaxLeverageV1(requestParameters: MarginTradingApiCreateMarginMaxLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginMaxLeverageV1Resp> {
            return localVarFp.createMarginMaxLeverageV1(requestParameters.maxLeverage, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new OCO for a margin account
         * @summary Margin Account New OCO (TRADE)
         * @param {MarginTradingApiCreateMarginOrderOcoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderOcoV1(requestParameters: MarginTradingApiCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderOcoV1Resp> {
            return localVarFp.createMarginOrderOcoV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.autoRepayAtCancel, requestParameters.isIsolated, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Post a new OTO order for margin account:
         * @summary Margin Account New OTO (TRADE)
         * @param {MarginTradingApiCreateMarginOrderOtoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderOtoV1(requestParameters: MarginTradingApiCreateMarginOrderOtoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderOtoV1Resp> {
            return localVarFp.createMarginOrderOtoV1(requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.pendingType, requestParameters.symbol, requestParameters.workingIcebergQty, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.autoRepayAtCancel, requestParameters.isIsolated, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingClientOrderId, requestParameters.pendingIcebergQty, requestParameters.pendingPrice, requestParameters.pendingStopPrice, requestParameters.pendingTimeInForce, requestParameters.pendingTrailingDelta, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.workingClientOrderId, requestParameters.workingTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Post a new OTOCO order for margin account：
         * @summary Margin Account New OTOCO (TRADE)
         * @param {MarginTradingApiCreateMarginOrderOtocoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderOtocoV1(requestParameters: MarginTradingApiCreateMarginOrderOtocoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderOtocoV1Resp> {
            return localVarFp.createMarginOrderOtocoV1(requestParameters.pendingAboveType, requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.symbol, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.autoRepayAtCancel, requestParameters.isIsolated, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingAboveClientOrderId, requestParameters.pendingAboveIcebergQty, requestParameters.pendingAbovePrice, requestParameters.pendingAboveStopPrice, requestParameters.pendingAboveTimeInForce, requestParameters.pendingAboveTrailingDelta, requestParameters.pendingBelowClientOrderId, requestParameters.pendingBelowIcebergQty, requestParameters.pendingBelowPrice, requestParameters.pendingBelowStopPrice, requestParameters.pendingBelowTimeInForce, requestParameters.pendingBelowTrailingDelta, requestParameters.pendingBelowType, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Post a new order for margin account.
         * @summary Margin Account New Order (TRADE)
         * @param {MarginTradingApiCreateMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginOrderV1(requestParameters: MarginTradingApiCreateMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<MarginCreateMarginOrderV1Resp> {
            return localVarFp.createMarginOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.autoRepayAtCancel, requestParameters.icebergQty, requestParameters.isIsolated, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.stopPrice, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new isolated margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start Isolated Margin User Data Stream (USER_STREAM)
         * @param {MarginTradingApiCreateUserDataStreamIsolatedV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDataStreamIsolatedV1(requestParameters: MarginTradingApiCreateUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDataStreamIsolatedV1Resp> {
            return localVarFp.createUserDataStreamIsolatedV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start Margin User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDataStreamV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDataStreamV1Resp> {
            return localVarFp.createUserDataStreamV1(options).then((request) => request(axios, basePath));
        },
        /**
         * This only applies to Special Key for Low Latency Trading.
         * @summary Delete Special Key(Low-Latency Trading)(TRADE)
         * @param {MarginTradingApiDeleteMarginApiKeyV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginApiKeyV1(requestParameters: MarginTradingApiDeleteMarginApiKeyV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteMarginApiKeyV1(requestParameters.timestamp, requestParameters.apiKey, requestParameters.apiName, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours.
         * @summary Disable Isolated Margin Account (TRADE)
         * @param {MarginTradingApiDeleteMarginIsolatedAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginIsolatedAccountV1(requestParameters: MarginTradingApiDeleteMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginIsolatedAccountV1Resp> {
            return localVarFp.deleteMarginIsolatedAccountV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteMarginListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels all active orders on a symbol for margin account. This includes OCO orders.
         * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
         * @param {MarginTradingApiDeleteMarginOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOpenOrdersV1(requestParameters: MarginTradingApiDeleteMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<DeleteMarginOpenOrdersV1RespItem>> {
            return localVarFp.deleteMarginOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an entire Order List for a margin account.
         * @summary Margin Account Cancel OCO (TRADE)
         * @param {MarginTradingApiDeleteMarginOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOrderListV1(requestParameters: MarginTradingApiDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginOrderListV1Resp> {
            return localVarFp.deleteMarginOrderListV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order for margin account.
         * @summary Margin Account Cancel Order (TRADE)
         * @param {MarginTradingApiDeleteMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarginOrderV1(requestParameters: MarginTradingApiDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginOrderV1Resp> {
            return localVarFp.deleteMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a isolated margin user data stream.
         * @summary Close Isolated Margin User Data Stream (USER_STREAM)
         * @param {MarginTradingApiDeleteUserDataStreamIsolatedV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDataStreamIsolatedV1(requestParameters: MarginTradingApiDeleteUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteUserDataStreamIsolatedV1(requestParameters.symbol, requestParameters.listenkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a Margin user data stream.
         * @summary Close Margin User Data Stream (USER_STREAM)
         * @param {MarginTradingApiDeleteUserDataStreamV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDataStreamV1(requestParameters: MarginTradingApiDeleteUserDataStreamV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteUserDataStreamV1(requestParameters.listenkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get BNB Burn Status
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {MarginTradingApiGetBnbBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnbBurnV1(requestParameters: MarginTradingApiGetBnbBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetBnbBurnV1Resp> {
            return localVarFp.getBnbBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Cross Margin Account Details
         * @summary Query Cross Margin Account Details (USER_DATA)
         * @param {MarginTradingApiGetMarginAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAccountV1(requestParameters: MarginTradingApiGetMarginAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginAccountV1Resp> {
            return localVarFp.getMarginAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get All Margin Assets.
         * @summary Get All Margin Assets (MARKET_DATA)
         * @param {MarginTradingApiGetMarginAllAssetsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllAssetsV1(requestParameters: MarginTradingApiGetMarginAllAssetsV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllAssetsV1RespItem>> {
            return localVarFp.getMarginAllAssetsV1(requestParameters.asset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all OCO for a specific margin account based on provided optional parameters
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {MarginTradingApiGetMarginAllOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllOrderListV1(requestParameters: MarginTradingApiGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllOrderListV1RespItem>> {
            return localVarFp.getMarginAllOrderListV1(requestParameters.timestamp, requestParameters.isIsolated, requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account\'s All Orders
         * @summary Query Margin Account\'s All Orders (USER_DATA)
         * @param {MarginTradingApiGetMarginAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllOrdersV1(requestParameters: MarginTradingApiGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllOrdersV1RespItem>> {
            return localVarFp.getMarginAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get All Cross Margin Pairs
         * @summary Get All Cross Margin Pairs (MARKET_DATA)
         * @param {MarginTradingApiGetMarginAllPairsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAllPairsV1(requestParameters: MarginTradingApiGetMarginAllPairsV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllPairsV1RespItem>> {
            return localVarFp.getMarginAllPairsV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * This only applies to Special Key for Low Latency Trading.
         * @summary Query Special key List(Low Latency Trading)(TRADE)
         * @param {MarginTradingApiGetMarginApiKeyListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginApiKeyListV1(requestParameters: MarginTradingApiGetMarginApiKeyListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginApiKeyListV1RespItem>> {
            return localVarFp.getMarginApiKeyListV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Special Key Information.
         * @summary Query Special key(Low Latency Trading)(TRADE)
         * @param {MarginTradingApiGetMarginApiKeyV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginApiKeyV1(requestParameters: MarginTradingApiGetMarginApiKeyV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginApiKeyV1Resp> {
            return localVarFp.getMarginApiKeyV1(requestParameters.apiKey, requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Margin available Inventory query
         * @summary Query Margin Available Inventory(USER_DATA)
         * @param {MarginTradingApiGetMarginAvailableInventoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginAvailableInventoryV1(requestParameters: MarginTradingApiGetMarginAvailableInventoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<MarginGetMarginAvailableInventoryV1Resp> {
            return localVarFp.getMarginAvailableInventoryV1(requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Query borrow/repay records in Margin account
         * @summary Query borrow/repay records in Margin account(USER_DATA)
         * @param {MarginTradingApiGetMarginBorrowRepayV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginBorrowRepayV1(requestParameters: MarginTradingApiGetMarginBorrowRepayV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginBorrowRepayV1Resp> {
            return localVarFp.getMarginBorrowRepayV1(requestParameters.type, requestParameters.timestamp, requestParameters.asset, requestParameters.isolatedSymbol, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Cross Isolated Margin Capital Flow
         * @summary Query Cross Isolated Margin Capital Flow (USER_DATA)
         * @param {MarginTradingApiGetMarginCapitalFlowV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginCapitalFlowV1(requestParameters: MarginTradingApiGetMarginCapitalFlowV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginCapitalFlowV1RespItem>> {
            return localVarFp.getMarginCapitalFlowV1(requestParameters.timestamp, requestParameters.asset, requestParameters.symbol, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cross margin collateral ratio
         * @summary Cross margin collateral ratio (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginCrossMarginCollateralRatioV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginCrossMarginCollateralRatioV1RespItem>> {
            return localVarFp.getMarginCrossMarginCollateralRatioV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get cross margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
         * @summary Query Cross Margin Fee Data (USER_DATA)
         * @param {MarginTradingApiGetMarginCrossMarginDataV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginCrossMarginDataV1(requestParameters: MarginTradingApiGetMarginCrossMarginDataV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginCrossMarginDataV1RespItem>> {
            return localVarFp.getMarginCrossMarginDataV1(requestParameters.timestamp, requestParameters.vipLevel, requestParameters.coin, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tokens or symbols delist schedule for cross margin and isolated margin
         * @summary Get Delist Schedule (MARKET_DATA)
         * @param {MarginTradingApiGetMarginDelistScheduleV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginDelistScheduleV1(requestParameters: MarginTradingApiGetMarginDelistScheduleV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginDelistScheduleV1RespItem>> {
            return localVarFp.getMarginDelistScheduleV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Small liability Exchange History
         * @summary Get Small Liability Exchange History (USER_DATA)
         * @param {MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginExchangeSmallLiabilityHistoryV1(requestParameters: MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginExchangeSmallLiabilityHistoryV1Resp> {
            return localVarFp.getMarginExchangeSmallLiabilityHistoryV1(requestParameters.current, requestParameters.size, requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query the coins which can be small liability exchange
         * @summary Get Small Liability Exchange Coin List (USER_DATA)
         * @param {MarginTradingApiGetMarginExchangeSmallLiabilityV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginExchangeSmallLiabilityV1(requestParameters: MarginTradingApiGetMarginExchangeSmallLiabilityV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginExchangeSmallLiabilityV1RespItem>> {
            return localVarFp.getMarginExchangeSmallLiabilityV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Force Liquidation Record
         * @summary Get Force Liquidation Record (USER_DATA)
         * @param {MarginTradingApiGetMarginForceLiquidationRecV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginForceLiquidationRecV1(requestParameters: MarginTradingApiGetMarginForceLiquidationRecV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginForceLiquidationRecV1Resp> {
            return localVarFp.getMarginForceLiquidationRecV1(requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.isolatedSymbol, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Interest History
         * @summary Get Interest History (USER_DATA)
         * @param {MarginTradingApiGetMarginInterestHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginInterestHistoryV1(requestParameters: MarginTradingApiGetMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginInterestHistoryV1Resp> {
            return localVarFp.getMarginInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.isolatedSymbol, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Interest Rate History
         * @summary Query Margin Interest Rate History (USER_DATA)
         * @param {MarginTradingApiGetMarginInterestRateHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginInterestRateHistoryV1(requestParameters: MarginTradingApiGetMarginInterestRateHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginInterestRateHistoryV1RespItem>> {
            return localVarFp.getMarginInterestRateHistoryV1(requestParameters.asset, requestParameters.timestamp, requestParameters.vipLevel, requestParameters.startTime, requestParameters.endTime, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query enabled isolated margin account limit.
         * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
         * @param {MarginTradingApiGetMarginIsolatedAccountLimitV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedAccountLimitV1(requestParameters: MarginTradingApiGetMarginIsolatedAccountLimitV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginIsolatedAccountLimitV1Resp> {
            return localVarFp.getMarginIsolatedAccountLimitV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Isolated Margin Account Info
         * @summary Query Isolated Margin Account Info (USER_DATA)
         * @param {MarginTradingApiGetMarginIsolatedAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedAccountV1(requestParameters: MarginTradingApiGetMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginIsolatedAccountV1Resp> {
            return localVarFp.getMarginIsolatedAccountV1(requestParameters.timestamp, requestParameters.symbols, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get All Isolated Margin Symbol
         * @summary Get All Isolated Margin Symbol(MARKET_DATA)
         * @param {MarginTradingApiGetMarginIsolatedAllPairsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedAllPairsV1(requestParameters: MarginTradingApiGetMarginIsolatedAllPairsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginIsolatedAllPairsV1RespItem>> {
            return localVarFp.getMarginIsolatedAllPairsV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get isolated margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
         * @summary Query Isolated Margin Fee Data (USER_DATA)
         * @param {MarginTradingApiGetMarginIsolatedMarginDataV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedMarginDataV1(requestParameters: MarginTradingApiGetMarginIsolatedMarginDataV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginIsolatedMarginDataV1RespItem>> {
            return localVarFp.getMarginIsolatedMarginDataV1(requestParameters.timestamp, requestParameters.vipLevel, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data
         * @summary Query Isolated Margin Tier Data (USER_DATA)
         * @param {MarginTradingApiGetMarginIsolatedMarginTierV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginIsolatedMarginTierV1(requestParameters: MarginTradingApiGetMarginIsolatedMarginTierV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginIsolatedMarginTierV1RespItem>> {
            return localVarFp.getMarginIsolatedMarginTierV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.tier, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Liability Coin Leverage Bracket in Cross Margin Pro Mode
         * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode(MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginLeverageBracketV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginLeverageBracketV1RespItem>> {
            return localVarFp.getMarginLeverageBracketV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Query Max Borrow
         * @summary Query Max Borrow (USER_DATA)
         * @param {MarginTradingApiGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMaxBorrowableV1(requestParameters: MarginTradingApiGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMaxBorrowableV1Resp> {
            return localVarFp.getMarginMaxBorrowableV1(requestParameters.asset, requestParameters.timestamp, requestParameters.isolatedSymbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Max Transfer-Out Amount
         * @summary Query Max Transfer-Out Amount (USER_DATA)
         * @param {MarginTradingApiGetMarginMaxTransferableV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMaxTransferableV1(requestParameters: MarginTradingApiGetMarginMaxTransferableV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMaxTransferableV1Resp> {
            return localVarFp.getMarginMaxTransferableV1(requestParameters.asset, requestParameters.timestamp, requestParameters.isolatedSymbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account\'s Trade List
         * @summary Query Margin Account\'s Trade List (USER_DATA)
         * @param {MarginTradingApiGetMarginMyTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginMyTradesV1(requestParameters: MarginTradingApiGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginMyTradesV1RespItem>> {
            return localVarFp.getMarginMyTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get future hourly interest rate
         * @summary Get future hourly interest rate (USER_DATA)
         * @param {MarginTradingApiGetMarginNextHourlyInterestRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginNextHourlyInterestRateV1(requestParameters: MarginTradingApiGetMarginNextHourlyInterestRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginNextHourlyInterestRateV1RespItem>> {
            return localVarFp.getMarginNextHourlyInterestRateV1(requestParameters.assets, requestParameters.isIsolated, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account\'s Open OCO
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {MarginTradingApiGetMarginOpenOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOpenOrderListV1(requestParameters: MarginTradingApiGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginOpenOrderListV1RespItem>> {
            return localVarFp.getMarginOpenOrderListV1(requestParameters.timestamp, requestParameters.isIsolated, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account\'s Open Orders
         * @summary Query Margin Account\'s Open Orders (USER_DATA)
         * @param {MarginTradingApiGetMarginOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOpenOrdersV1(requestParameters: MarginTradingApiGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<MarginGetMarginOpenOrdersV1RespItem>> {
            return localVarFp.getMarginOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.isIsolated, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {MarginTradingApiGetMarginOrderListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOrderListV1(requestParameters: MarginTradingApiGetMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginOrderListV1Resp> {
            return localVarFp.getMarginOrderListV1(requestParameters.timestamp, requestParameters.isIsolated, requestParameters.symbol, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin Account\'s Order
         * @summary Query Margin Account\'s Order (USER_DATA)
         * @param {MarginTradingApiGetMarginOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginOrderV1(requestParameters: MarginTradingApiGetMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginOrderV1Resp> {
            return localVarFp.getMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Margin PriceIndex
         * @summary Query Margin PriceIndex (MARKET_DATA)
         * @param {MarginTradingApiGetMarginPriceIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginPriceIndexV1(requestParameters: MarginTradingApiGetMarginPriceIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginPriceIndexV1Resp> {
            return localVarFp.getMarginPriceIndexV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Displays the user\'s current margin order count usage for all intervals.
         * @summary Query Current Margin Order Count Usage (TRADE)
         * @param {MarginTradingApiGetMarginRateLimitOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginRateLimitOrderV1(requestParameters: MarginTradingApiGetMarginRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginRateLimitOrderV1RespItem>> {
            return localVarFp.getMarginRateLimitOrderV1(requestParameters.timestamp, requestParameters.isIsolated, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get personal margin level information
         * @summary Get Summary of Margin account (USER_DATA)
         * @param {MarginTradingApiGetMarginTradeCoeffV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginTradeCoeffV1(requestParameters: MarginTradingApiGetMarginTradeCoeffV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginTradeCoeffV1Resp> {
            return localVarFp.getMarginTradeCoeffV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Cross Margin Transfer History
         * @summary Get Cross Margin Transfer History (USER_DATA)
         * @param {MarginTradingApiGetMarginTransferV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarginTransferV1(requestParameters: MarginTradingApiGetMarginTransferV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginTransferV1Resp> {
            return localVarFp.getMarginTransferV1(requestParameters.timestamp, requestParameters.asset, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.isolatedSymbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit ip restriction. This only applies to Special Key for Low Latency Trading.
         * @summary Edit ip for Special Key(Low-Latency Trading)(TRADE)
         * @param {MarginTradingApiUpdateMarginApiKeyIpV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMarginApiKeyIpV1(requestParameters: MarginTradingApiUpdateMarginApiKeyIpV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateMarginApiKeyIpV1(requestParameters.apiKey, requestParameters.ip, requestParameters.timestamp, requestParameters.recvWindow, requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a user data stream to prevent a time out.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {MarginTradingApiUpdateMarginListenKeyV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMarginListenKeyV1(requestParameters: MarginTradingApiUpdateMarginListenKeyV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateMarginListenKeyV1(requestParameters.listenKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive an isolated margin user data stream to prevent a time out.
         * @summary Keepalive Isolated Margin User Data Stream (USER_STREAM)
         * @param {MarginTradingApiUpdateUserDataStreamIsolatedV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDataStreamIsolatedV1(requestParameters: MarginTradingApiUpdateUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateUserDataStreamIsolatedV1(requestParameters.listenKey, requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a margin user data stream to prevent a time out.
         * @summary Keepalive Margin User Data Stream (USER_STREAM)
         * @param {MarginTradingApiUpdateUserDataStreamV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDataStreamV1(requestParameters: MarginTradingApiUpdateUserDataStreamV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateUserDataStreamV1(requestParameters.listenKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarginTradingApi - interface
 * @export
 * @interface MarginTradingApi
 */
export interface MarginTradingApiInterface {
    /**
     * **Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **
     * @summary Create Special Key(Low-Latency Trading)(TRADE)
     * @param {MarginTradingApiCreateMarginApiKeyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginApiKeyV1(requestParameters: MarginTradingApiCreateMarginApiKeyV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginApiKeyV1Resp>;

    /**
     * Margin account borrow/repay(MARGIN)
     * @summary Margin account borrow/repay(MARGIN)
     * @param {MarginTradingApiCreateMarginBorrowRepayV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginBorrowRepayV1(requestParameters: MarginTradingApiCreateMarginBorrowRepayV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginBorrowRepayV1Resp>;

    /**
     * Small Liability Exchange
     * @summary Small Liability Exchange (MARGIN)
     * @param {MarginTradingApiCreateMarginExchangeSmallLiabilityV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginExchangeSmallLiabilityV1(requestParameters: MarginTradingApiCreateMarginExchangeSmallLiabilityV1Request, options?: RawAxiosRequestConfig): AxiosPromise<MarginCreateMarginExchangeSmallLiabilityV1Resp>;

    /**
     * Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).
     * @summary Enable Isolated Margin Account (TRADE)
     * @param {MarginTradingApiCreateMarginIsolatedAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginIsolatedAccountV1(requestParameters: MarginTradingApiCreateMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginIsolatedAccountV1Resp>;

    /**
     * Start a new user data stream.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginListenKeyV1Resp>;

    /**
     * Margin Manual Liquidation
     * @summary Margin Manual Liquidation(MARGIN)
     * @param {MarginTradingApiCreateMarginManualLiquidationV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginManualLiquidationV1(requestParameters: MarginTradingApiCreateMarginManualLiquidationV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginManualLiquidationV1Resp>;

    /**
     * Adjust cross margin max leverage
     * @summary Adjust cross margin max leverage (USER_DATA)
     * @param {MarginTradingApiCreateMarginMaxLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginMaxLeverageV1(requestParameters: MarginTradingApiCreateMarginMaxLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginMaxLeverageV1Resp>;

    /**
     * Send in a new OCO for a margin account
     * @summary Margin Account New OCO (TRADE)
     * @param {MarginTradingApiCreateMarginOrderOcoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginOrderOcoV1(requestParameters: MarginTradingApiCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderOcoV1Resp>;

    /**
     * Post a new OTO order for margin account:
     * @summary Margin Account New OTO (TRADE)
     * @param {MarginTradingApiCreateMarginOrderOtoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginOrderOtoV1(requestParameters: MarginTradingApiCreateMarginOrderOtoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderOtoV1Resp>;

    /**
     * Post a new OTOCO order for margin account：
     * @summary Margin Account New OTOCO (TRADE)
     * @param {MarginTradingApiCreateMarginOrderOtocoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginOrderOtocoV1(requestParameters: MarginTradingApiCreateMarginOrderOtocoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginOrderOtocoV1Resp>;

    /**
     * Post a new order for margin account.
     * @summary Margin Account New Order (TRADE)
     * @param {MarginTradingApiCreateMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createMarginOrderV1(requestParameters: MarginTradingApiCreateMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<MarginCreateMarginOrderV1Resp>;

    /**
     * Start a new isolated margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start Isolated Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiCreateUserDataStreamIsolatedV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createUserDataStreamIsolatedV1(requestParameters: MarginTradingApiCreateUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDataStreamIsolatedV1Resp>;

    /**
     * Start a new margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start Margin User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    createUserDataStreamV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDataStreamV1Resp>;

    /**
     * This only applies to Special Key for Low Latency Trading.
     * @summary Delete Special Key(Low-Latency Trading)(TRADE)
     * @param {MarginTradingApiDeleteMarginApiKeyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    deleteMarginApiKeyV1(requestParameters: MarginTradingApiDeleteMarginApiKeyV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours.
     * @summary Disable Isolated Margin Account (TRADE)
     * @param {MarginTradingApiDeleteMarginIsolatedAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    deleteMarginIsolatedAccountV1(requestParameters: MarginTradingApiDeleteMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginIsolatedAccountV1Resp>;

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    deleteMarginListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Cancels all active orders on a symbol for margin account. This includes OCO orders.
     * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
     * @param {MarginTradingApiDeleteMarginOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    deleteMarginOpenOrdersV1(requestParameters: MarginTradingApiDeleteMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<DeleteMarginOpenOrdersV1RespItem>>;

    /**
     * Cancel an entire Order List for a margin account.
     * @summary Margin Account Cancel OCO (TRADE)
     * @param {MarginTradingApiDeleteMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    deleteMarginOrderListV1(requestParameters: MarginTradingApiDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginOrderListV1Resp>;

    /**
     * Cancel an active order for margin account.
     * @summary Margin Account Cancel Order (TRADE)
     * @param {MarginTradingApiDeleteMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    deleteMarginOrderV1(requestParameters: MarginTradingApiDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarginOrderV1Resp>;

    /**
     * Close out a isolated margin user data stream.
     * @summary Close Isolated Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiDeleteUserDataStreamIsolatedV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    deleteUserDataStreamIsolatedV1(requestParameters: MarginTradingApiDeleteUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Close out a Margin user data stream.
     * @summary Close Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiDeleteUserDataStreamV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    deleteUserDataStreamV1(requestParameters: MarginTradingApiDeleteUserDataStreamV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Get BNB Burn Status
     * @summary Get BNB Burn Status (USER_DATA)
     * @param {MarginTradingApiGetBnbBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getBnbBurnV1(requestParameters: MarginTradingApiGetBnbBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetBnbBurnV1Resp>;

    /**
     * Query Cross Margin Account Details
     * @summary Query Cross Margin Account Details (USER_DATA)
     * @param {MarginTradingApiGetMarginAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginAccountV1(requestParameters: MarginTradingApiGetMarginAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginAccountV1Resp>;

    /**
     * Get All Margin Assets.
     * @summary Get All Margin Assets (MARKET_DATA)
     * @param {MarginTradingApiGetMarginAllAssetsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginAllAssetsV1(requestParameters?: MarginTradingApiGetMarginAllAssetsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllAssetsV1RespItem>>;

    /**
     * Retrieves all OCO for a specific margin account based on provided optional parameters
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {MarginTradingApiGetMarginAllOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginAllOrderListV1(requestParameters: MarginTradingApiGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllOrderListV1RespItem>>;

    /**
     * Query Margin Account\'s All Orders
     * @summary Query Margin Account\'s All Orders (USER_DATA)
     * @param {MarginTradingApiGetMarginAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginAllOrdersV1(requestParameters: MarginTradingApiGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllOrdersV1RespItem>>;

    /**
     * Get All Cross Margin Pairs
     * @summary Get All Cross Margin Pairs (MARKET_DATA)
     * @param {MarginTradingApiGetMarginAllPairsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginAllPairsV1(requestParameters?: MarginTradingApiGetMarginAllPairsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginAllPairsV1RespItem>>;

    /**
     * This only applies to Special Key for Low Latency Trading.
     * @summary Query Special key List(Low Latency Trading)(TRADE)
     * @param {MarginTradingApiGetMarginApiKeyListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginApiKeyListV1(requestParameters: MarginTradingApiGetMarginApiKeyListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginApiKeyListV1RespItem>>;

    /**
     * Query Special Key Information.
     * @summary Query Special key(Low Latency Trading)(TRADE)
     * @param {MarginTradingApiGetMarginApiKeyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginApiKeyV1(requestParameters: MarginTradingApiGetMarginApiKeyV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginApiKeyV1Resp>;

    /**
     * Margin available Inventory query
     * @summary Query Margin Available Inventory(USER_DATA)
     * @param {MarginTradingApiGetMarginAvailableInventoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginAvailableInventoryV1(requestParameters: MarginTradingApiGetMarginAvailableInventoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<MarginGetMarginAvailableInventoryV1Resp>;

    /**
     * Query borrow/repay records in Margin account
     * @summary Query borrow/repay records in Margin account(USER_DATA)
     * @param {MarginTradingApiGetMarginBorrowRepayV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginBorrowRepayV1(requestParameters: MarginTradingApiGetMarginBorrowRepayV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginBorrowRepayV1Resp>;

    /**
     * Query Cross Isolated Margin Capital Flow
     * @summary Query Cross Isolated Margin Capital Flow (USER_DATA)
     * @param {MarginTradingApiGetMarginCapitalFlowV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginCapitalFlowV1(requestParameters: MarginTradingApiGetMarginCapitalFlowV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginCapitalFlowV1RespItem>>;

    /**
     * Cross margin collateral ratio
     * @summary Cross margin collateral ratio (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginCrossMarginCollateralRatioV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginCrossMarginCollateralRatioV1RespItem>>;

    /**
     * Get cross margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
     * @summary Query Cross Margin Fee Data (USER_DATA)
     * @param {MarginTradingApiGetMarginCrossMarginDataV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginCrossMarginDataV1(requestParameters: MarginTradingApiGetMarginCrossMarginDataV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginCrossMarginDataV1RespItem>>;

    /**
     * Get tokens or symbols delist schedule for cross margin and isolated margin
     * @summary Get Delist Schedule (MARKET_DATA)
     * @param {MarginTradingApiGetMarginDelistScheduleV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginDelistScheduleV1(requestParameters: MarginTradingApiGetMarginDelistScheduleV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginDelistScheduleV1RespItem>>;

    /**
     * Get Small liability Exchange History
     * @summary Get Small Liability Exchange History (USER_DATA)
     * @param {MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginExchangeSmallLiabilityHistoryV1(requestParameters: MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginExchangeSmallLiabilityHistoryV1Resp>;

    /**
     * Query the coins which can be small liability exchange
     * @summary Get Small Liability Exchange Coin List (USER_DATA)
     * @param {MarginTradingApiGetMarginExchangeSmallLiabilityV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginExchangeSmallLiabilityV1(requestParameters: MarginTradingApiGetMarginExchangeSmallLiabilityV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginExchangeSmallLiabilityV1RespItem>>;

    /**
     * Get Force Liquidation Record
     * @summary Get Force Liquidation Record (USER_DATA)
     * @param {MarginTradingApiGetMarginForceLiquidationRecV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginForceLiquidationRecV1(requestParameters: MarginTradingApiGetMarginForceLiquidationRecV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginForceLiquidationRecV1Resp>;

    /**
     * Get Interest History
     * @summary Get Interest History (USER_DATA)
     * @param {MarginTradingApiGetMarginInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginInterestHistoryV1(requestParameters: MarginTradingApiGetMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginInterestHistoryV1Resp>;

    /**
     * Query Margin Interest Rate History
     * @summary Query Margin Interest Rate History (USER_DATA)
     * @param {MarginTradingApiGetMarginInterestRateHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginInterestRateHistoryV1(requestParameters: MarginTradingApiGetMarginInterestRateHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginInterestRateHistoryV1RespItem>>;

    /**
     * Query enabled isolated margin account limit.
     * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
     * @param {MarginTradingApiGetMarginIsolatedAccountLimitV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginIsolatedAccountLimitV1(requestParameters: MarginTradingApiGetMarginIsolatedAccountLimitV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginIsolatedAccountLimitV1Resp>;

    /**
     * Query Isolated Margin Account Info
     * @summary Query Isolated Margin Account Info (USER_DATA)
     * @param {MarginTradingApiGetMarginIsolatedAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginIsolatedAccountV1(requestParameters: MarginTradingApiGetMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginIsolatedAccountV1Resp>;

    /**
     * Get All Isolated Margin Symbol
     * @summary Get All Isolated Margin Symbol(MARKET_DATA)
     * @param {MarginTradingApiGetMarginIsolatedAllPairsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginIsolatedAllPairsV1(requestParameters: MarginTradingApiGetMarginIsolatedAllPairsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginIsolatedAllPairsV1RespItem>>;

    /**
     * Get isolated margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
     * @summary Query Isolated Margin Fee Data (USER_DATA)
     * @param {MarginTradingApiGetMarginIsolatedMarginDataV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginIsolatedMarginDataV1(requestParameters: MarginTradingApiGetMarginIsolatedMarginDataV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginIsolatedMarginDataV1RespItem>>;

    /**
     * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data
     * @summary Query Isolated Margin Tier Data (USER_DATA)
     * @param {MarginTradingApiGetMarginIsolatedMarginTierV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginIsolatedMarginTierV1(requestParameters: MarginTradingApiGetMarginIsolatedMarginTierV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginIsolatedMarginTierV1RespItem>>;

    /**
     * Liability Coin Leverage Bracket in Cross Margin Pro Mode
     * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode(MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginLeverageBracketV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginLeverageBracketV1RespItem>>;

    /**
     * Query Max Borrow
     * @summary Query Max Borrow (USER_DATA)
     * @param {MarginTradingApiGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginMaxBorrowableV1(requestParameters: MarginTradingApiGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMaxBorrowableV1Resp>;

    /**
     * Query Max Transfer-Out Amount
     * @summary Query Max Transfer-Out Amount (USER_DATA)
     * @param {MarginTradingApiGetMarginMaxTransferableV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginMaxTransferableV1(requestParameters: MarginTradingApiGetMarginMaxTransferableV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginMaxTransferableV1Resp>;

    /**
     * Query Margin Account\'s Trade List
     * @summary Query Margin Account\'s Trade List (USER_DATA)
     * @param {MarginTradingApiGetMarginMyTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginMyTradesV1(requestParameters: MarginTradingApiGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginMyTradesV1RespItem>>;

    /**
     * Get future hourly interest rate
     * @summary Get future hourly interest rate (USER_DATA)
     * @param {MarginTradingApiGetMarginNextHourlyInterestRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginNextHourlyInterestRateV1(requestParameters: MarginTradingApiGetMarginNextHourlyInterestRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginNextHourlyInterestRateV1RespItem>>;

    /**
     * Query Margin Account\'s Open OCO
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {MarginTradingApiGetMarginOpenOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginOpenOrderListV1(requestParameters: MarginTradingApiGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginOpenOrderListV1RespItem>>;

    /**
     * Query Margin Account\'s Open Orders
     * @summary Query Margin Account\'s Open Orders (USER_DATA)
     * @param {MarginTradingApiGetMarginOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginOpenOrdersV1(requestParameters: MarginTradingApiGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<MarginGetMarginOpenOrdersV1RespItem>>;

    /**
     * Retrieves a specific OCO based on provided optional parameters
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {MarginTradingApiGetMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginOrderListV1(requestParameters: MarginTradingApiGetMarginOrderListV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginOrderListV1Resp>;

    /**
     * Query Margin Account\'s Order
     * @summary Query Margin Account\'s Order (USER_DATA)
     * @param {MarginTradingApiGetMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginOrderV1(requestParameters: MarginTradingApiGetMarginOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginOrderV1Resp>;

    /**
     * Query Margin PriceIndex
     * @summary Query Margin PriceIndex (MARKET_DATA)
     * @param {MarginTradingApiGetMarginPriceIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginPriceIndexV1(requestParameters: MarginTradingApiGetMarginPriceIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginPriceIndexV1Resp>;

    /**
     * Displays the user\'s current margin order count usage for all intervals.
     * @summary Query Current Margin Order Count Usage (TRADE)
     * @param {MarginTradingApiGetMarginRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginRateLimitOrderV1(requestParameters: MarginTradingApiGetMarginRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarginRateLimitOrderV1RespItem>>;

    /**
     * Get personal margin level information
     * @summary Get Summary of Margin account (USER_DATA)
     * @param {MarginTradingApiGetMarginTradeCoeffV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginTradeCoeffV1(requestParameters: MarginTradingApiGetMarginTradeCoeffV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginTradeCoeffV1Resp>;

    /**
     * Get Cross Margin Transfer History
     * @summary Get Cross Margin Transfer History (USER_DATA)
     * @param {MarginTradingApiGetMarginTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    getMarginTransferV1(requestParameters: MarginTradingApiGetMarginTransferV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMarginTransferV1Resp>;

    /**
     * Edit ip restriction. This only applies to Special Key for Low Latency Trading.
     * @summary Edit ip for Special Key(Low-Latency Trading)(TRADE)
     * @param {MarginTradingApiUpdateMarginApiKeyIpV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    updateMarginApiKeyIpV1(requestParameters: MarginTradingApiUpdateMarginApiKeyIpV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Keepalive a user data stream to prevent a time out.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {MarginTradingApiUpdateMarginListenKeyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    updateMarginListenKeyV1(requestParameters: MarginTradingApiUpdateMarginListenKeyV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Keepalive an isolated margin user data stream to prevent a time out.
     * @summary Keepalive Isolated Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiUpdateUserDataStreamIsolatedV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    updateUserDataStreamIsolatedV1(requestParameters: MarginTradingApiUpdateUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Keepalive a margin user data stream to prevent a time out.
     * @summary Keepalive Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiUpdateUserDataStreamV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApiInterface
     */
    updateUserDataStreamV1(requestParameters: MarginTradingApiUpdateUserDataStreamV1Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

}

/**
 * Request parameters for createMarginApiKeyV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginApiKeyV1Request
 */
export interface MarginTradingApiCreateMarginApiKeyV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginApiKeyV1
     */
    readonly apiName: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginApiKeyV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginApiKeyV1
     */
    readonly ip?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginApiKeyV1
     */
    readonly permissionMode?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginApiKeyV1
     */
    readonly publicKey?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginApiKeyV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginApiKeyV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for createMarginBorrowRepayV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginBorrowRepayV1Request
 */
export interface MarginTradingApiCreateMarginBorrowRepayV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginBorrowRepayV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginBorrowRepayV1
     */
    readonly asset: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginBorrowRepayV1
     */
    readonly isIsolated: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginBorrowRepayV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginBorrowRepayV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginBorrowRepayV1
     */
    readonly type: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginBorrowRepayV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginExchangeSmallLiabilityV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginExchangeSmallLiabilityV1Request
 */
export interface MarginTradingApiCreateMarginExchangeSmallLiabilityV1Request {
    /**
     * 
     * @type {Array<string>}
     * @memberof MarginTradingApiCreateMarginExchangeSmallLiabilityV1
     */
    readonly assetNames: Array<string>

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginExchangeSmallLiabilityV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginExchangeSmallLiabilityV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginIsolatedAccountV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginIsolatedAccountV1Request
 */
export interface MarginTradingApiCreateMarginIsolatedAccountV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginIsolatedAccountV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginIsolatedAccountV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginIsolatedAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginManualLiquidationV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginManualLiquidationV1Request
 */
export interface MarginTradingApiCreateMarginManualLiquidationV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginManualLiquidationV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginManualLiquidationV1
     */
    readonly type: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginManualLiquidationV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginManualLiquidationV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for createMarginMaxLeverageV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginMaxLeverageV1Request
 */
export interface MarginTradingApiCreateMarginMaxLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginMaxLeverageV1
     */
    readonly maxLeverage: number
}

/**
 * Request parameters for createMarginOrderOcoV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginOrderOcoV1Request
 */
export interface MarginTradingApiCreateMarginOrderOcoV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly stopPrice: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {boolean}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly autoRepayAtCancel?: boolean

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly isIsolated?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly limitClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly limitIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly sideEffectType?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly stopClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly stopIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly stopLimitPrice?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOcoV1
     */
    readonly stopLimitTimeInForce?: string
}

/**
 * Request parameters for createMarginOrderOtoV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginOrderOtoV1Request
 */
export interface MarginTradingApiCreateMarginOrderOtoV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingSide: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingType: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly workingIcebergQty: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly workingPrice: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly workingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly workingSide: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly workingType: CreateMarginOrderOtoV1WorkingTypeEnum

    /**
     * 
     * @type {boolean}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly autoRepayAtCancel?: boolean

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly isIsolated?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingPrice?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingStopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly pendingTrailingDelta?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly sideEffectType?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly workingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtoV1
     */
    readonly workingTimeInForce?: string
}

/**
 * Request parameters for createMarginOrderOtocoV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginOrderOtocoV1Request
 */
export interface MarginTradingApiCreateMarginOrderOtocoV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingAboveType: CreateMarginOrderOtocoV1PendingAboveTypeEnum

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingSide: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly workingPrice: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly workingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly workingSide: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly workingType: CreateMarginOrderOtocoV1WorkingTypeEnum

    /**
     * 
     * @type {boolean}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly autoRepayAtCancel?: boolean

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly isIsolated?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingAboveClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingAboveIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingAbovePrice?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingAboveStopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingAboveTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingAboveTrailingDelta?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingBelowClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingBelowIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingBelowPrice?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingBelowStopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingBelowTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingBelowTrailingDelta?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly pendingBelowType?: CreateMarginOrderOtocoV1PendingBelowTypeEnum

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly sideEffectType?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly workingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly workingIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderOtocoV1
     */
    readonly workingTimeInForce?: string
}

/**
 * Request parameters for createMarginOrderV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateMarginOrderV1Request
 */
export interface MarginTradingApiCreateMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {boolean}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly autoRepayAtCancel?: boolean

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly isIsolated?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly sideEffectType?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateMarginOrderV1
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for createUserDataStreamIsolatedV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiCreateUserDataStreamIsolatedV1Request
 */
export interface MarginTradingApiCreateUserDataStreamIsolatedV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiCreateUserDataStreamIsolatedV1
     */
    readonly symbol: string
}

/**
 * Request parameters for deleteMarginApiKeyV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiDeleteMarginApiKeyV1Request
 */
export interface MarginTradingApiDeleteMarginApiKeyV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginApiKeyV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginApiKeyV1
     */
    readonly apiKey?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginApiKeyV1
     */
    readonly apiName?: string

    /**
     * isolated margin pair
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginApiKeyV1
     */
    readonly symbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginApiKeyV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteMarginIsolatedAccountV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiDeleteMarginIsolatedAccountV1Request
 */
export interface MarginTradingApiDeleteMarginIsolatedAccountV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginIsolatedAccountV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginIsolatedAccountV1
     */
    readonly timestamp: number

    /**
     * No more than 60000
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginIsolatedAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteMarginOpenOrdersV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiDeleteMarginOpenOrdersV1Request
 */
export interface MarginTradingApiDeleteMarginOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOpenOrdersV1
     */
    readonly isIsolated?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteMarginOrderListV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiDeleteMarginOrderListV1Request
 */
export interface MarginTradingApiDeleteMarginOrderListV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOrderListV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginOrderListV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOrderListV1
     */
    readonly isIsolated?: string

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginOrderListV1
     */
    readonly orderListId?: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOrderListV1
     */
    readonly listClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOrderListV1
     */
    readonly newClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteMarginOrderV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiDeleteMarginOrderV1Request
 */
export interface MarginTradingApiDeleteMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginOrderV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOrderV1
     */
    readonly isIsolated?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default.
     * @type {string}
     * @memberof MarginTradingApiDeleteMarginOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiDeleteMarginOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteUserDataStreamIsolatedV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiDeleteUserDataStreamIsolatedV1Request
 */
export interface MarginTradingApiDeleteUserDataStreamIsolatedV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteUserDataStreamIsolatedV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteUserDataStreamIsolatedV1
     */
    readonly listenkey: string
}

/**
 * Request parameters for deleteUserDataStreamV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiDeleteUserDataStreamV1Request
 */
export interface MarginTradingApiDeleteUserDataStreamV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiDeleteUserDataStreamV1
     */
    readonly listenkey: string
}

/**
 * Request parameters for getBnbBurnV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetBnbBurnV1Request
 */
export interface MarginTradingApiGetBnbBurnV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetBnbBurnV1
     */
    readonly timestamp: number

    /**
     * No more than 60000
     * @type {number}
     * @memberof MarginTradingApiGetBnbBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginAccountV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginAccountV1Request
 */
export interface MarginTradingApiGetMarginAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginAccountV1
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginAllAssetsV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginAllAssetsV1Request
 */
export interface MarginTradingApiGetMarginAllAssetsV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginAllAssetsV1
     */
    readonly asset?: string
}

/**
 * Request parameters for getMarginAllOrderListV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginAllOrderListV1Request
 */
export interface MarginTradingApiGetMarginAllOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrderListV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginAllOrderListV1
     */
    readonly isIsolated?: string

    /**
     * mandatory for isolated margin, not supported for cross margin
     * @type {string}
     * @memberof MarginTradingApiGetMarginAllOrderListV1
     */
    readonly symbol?: string

    /**
     * If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrderListV1
     */
    readonly fromId?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrderListV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrderListV1
     */
    readonly endTime?: number

    /**
     * Default Value: 500; Max Value: 1000
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrderListV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginAllOrdersV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginAllOrdersV1Request
 */
export interface MarginTradingApiGetMarginAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrdersV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginAllOrdersV1
     */
    readonly isIsolated?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 500.
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrdersV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginAllPairsV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginAllPairsV1Request
 */
export interface MarginTradingApiGetMarginAllPairsV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginAllPairsV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getMarginApiKeyListV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginApiKeyListV1Request
 */
export interface MarginTradingApiGetMarginApiKeyListV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginApiKeyListV1
     */
    readonly timestamp: number

    /**
     * isolated margin pair
     * @type {string}
     * @memberof MarginTradingApiGetMarginApiKeyListV1
     */
    readonly symbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginApiKeyListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginApiKeyV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginApiKeyV1Request
 */
export interface MarginTradingApiGetMarginApiKeyV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginApiKeyV1
     */
    readonly apiKey: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginApiKeyV1
     */
    readonly timestamp: number

    /**
     * isolated margin pair
     * @type {string}
     * @memberof MarginTradingApiGetMarginApiKeyV1
     */
    readonly symbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginApiKeyV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginAvailableInventoryV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginAvailableInventoryV1Request
 */
export interface MarginTradingApiGetMarginAvailableInventoryV1Request {
    /**
     * MARGIN,ISOLATED
     * @type {string}
     * @memberof MarginTradingApiGetMarginAvailableInventoryV1
     */
    readonly type: string
}

/**
 * Request parameters for getMarginBorrowRepayV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginBorrowRepayV1Request
 */
export interface MarginTradingApiGetMarginBorrowRepayV1Request {
    /**
     * &#x60;BORROW&#x60; or &#x60;REPAY&#x60;
     * @type {string}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly type: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly asset?: string

    /**
     * Symbol in Isolated Margin
     * @type {string}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly isolatedSymbol?: string

    /**
     * &#x60;tranId&#x60; in &#x60;POST /sapi/v1/margin/loan&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly txId?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly endTime?: number

    /**
     * Current querying page. Start from 1. Default:1
     * @type {number}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly size?: number

    /**
     * The value cannot be greater than 60000
     * @type {number}
     * @memberof MarginTradingApiGetMarginBorrowRepayV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginCapitalFlowV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginCapitalFlowV1Request
 */
export interface MarginTradingApiGetMarginCapitalFlowV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly asset?: string

    /**
     * 查询逐仓数据时必填
     * @type {string}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly type?: string

    /**
     * 只支持查询最近90天的数据
     * @type {number}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly endTime?: number

    /**
     * 如设置fromId, 将返回id &amp;gt; fromId的数据。否则将返回最新数据
     * @type {number}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly fromId?: number

    /**
     * 每次返回的数据条数限制。默认 500; 最大 1000.
     * @type {number}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginCapitalFlowV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginCrossMarginDataV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginCrossMarginDataV1Request
 */
export interface MarginTradingApiGetMarginCrossMarginDataV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginCrossMarginDataV1
     */
    readonly timestamp: number

    /**
     * User&amp;#39;s current specific margin data will be returned if vipLevel is omitted
     * @type {number}
     * @memberof MarginTradingApiGetMarginCrossMarginDataV1
     */
    readonly vipLevel?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginCrossMarginDataV1
     */
    readonly coin?: string

    /**
     * No more than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginCrossMarginDataV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginDelistScheduleV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginDelistScheduleV1Request
 */
export interface MarginTradingApiGetMarginDelistScheduleV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginDelistScheduleV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginDelistScheduleV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginExchangeSmallLiabilityHistoryV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1Request
 */
export interface MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1Request {
    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1
     */
    readonly current: number

    /**
     * Default:10, Max:100
     * @type {number}
     * @memberof MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1
     */
    readonly size: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1
     */
    readonly timestamp: number

    /**
     * Default: 30 days from current timestamp
     * @type {number}
     * @memberof MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1
     */
    readonly startTime?: number

    /**
     * Default: present timestamp
     * @type {number}
     * @memberof MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginExchangeSmallLiabilityV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginExchangeSmallLiabilityV1Request
 */
export interface MarginTradingApiGetMarginExchangeSmallLiabilityV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginExchangeSmallLiabilityV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginExchangeSmallLiabilityV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginForceLiquidationRecV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginForceLiquidationRecV1Request
 */
export interface MarginTradingApiGetMarginForceLiquidationRecV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginForceLiquidationRecV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginForceLiquidationRecV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginForceLiquidationRecV1
     */
    readonly endTime?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginForceLiquidationRecV1
     */
    readonly isolatedSymbol?: string

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof MarginTradingApiGetMarginForceLiquidationRecV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof MarginTradingApiGetMarginForceLiquidationRecV1
     */
    readonly size?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginForceLiquidationRecV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginInterestHistoryV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginInterestHistoryV1Request
 */
export interface MarginTradingApiGetMarginInterestHistoryV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestHistoryV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginInterestHistoryV1
     */
    readonly asset?: string

    /**
     * isolated symbol
     * @type {string}
     * @memberof MarginTradingApiGetMarginInterestHistoryV1
     */
    readonly isolatedSymbol?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestHistoryV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestHistoryV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestHistoryV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestHistoryV1
     */
    readonly size?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginInterestRateHistoryV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginInterestRateHistoryV1Request
 */
export interface MarginTradingApiGetMarginInterestRateHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginInterestRateHistoryV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestRateHistoryV1
     */
    readonly timestamp: number

    /**
     * Default: user&amp;#39;s vip level
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestRateHistoryV1
     */
    readonly vipLevel?: number

    /**
     * Default: 7 days ago
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestRateHistoryV1
     */
    readonly startTime?: number

    /**
     * Default: present. Maximum range: 1 months.
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestRateHistoryV1
     */
    readonly endTime?: number

    /**
     * No more than 60000
     * @type {number}
     * @memberof MarginTradingApiGetMarginInterestRateHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginIsolatedAccountLimitV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginIsolatedAccountLimitV1Request
 */
export interface MarginTradingApiGetMarginIsolatedAccountLimitV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedAccountLimitV1
     */
    readonly timestamp: number

    /**
     * No more than 60000
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedAccountLimitV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginIsolatedAccountV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginIsolatedAccountV1Request
 */
export interface MarginTradingApiGetMarginIsolatedAccountV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedAccountV1
     */
    readonly timestamp: number

    /**
     * Max 5 symbols can be sent; separated by &amp;#34;,&amp;#34;. e.g. &amp;#34;BTCUSDT,BNBUSDT,ADAUSDT&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginIsolatedAccountV1
     */
    readonly symbols?: string

    /**
     * No more than 60000
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedAccountV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginIsolatedAllPairsV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginIsolatedAllPairsV1Request
 */
export interface MarginTradingApiGetMarginIsolatedAllPairsV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedAllPairsV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginIsolatedAllPairsV1
     */
    readonly symbol?: string

    /**
     * No more than 60000
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedAllPairsV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginIsolatedMarginDataV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginIsolatedMarginDataV1Request
 */
export interface MarginTradingApiGetMarginIsolatedMarginDataV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedMarginDataV1
     */
    readonly timestamp: number

    /**
     * User&amp;#39;s current specific margin data will be returned if vipLevel is omitted
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedMarginDataV1
     */
    readonly vipLevel?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginIsolatedMarginDataV1
     */
    readonly symbol?: string

    /**
     * No more than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedMarginDataV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginIsolatedMarginTierV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginIsolatedMarginTierV1Request
 */
export interface MarginTradingApiGetMarginIsolatedMarginTierV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginIsolatedMarginTierV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedMarginTierV1
     */
    readonly timestamp: number

    /**
     * All margin tier data will be returned if tier is omitted
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedMarginTierV1
     */
    readonly tier?: number

    /**
     * No more than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginIsolatedMarginTierV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginMaxBorrowableV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginMaxBorrowableV1Request
 */
export interface MarginTradingApiGetMarginMaxBorrowableV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginMaxBorrowableV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginMaxBorrowableV1
     */
    readonly timestamp: number

    /**
     * isolated symbol
     * @type {string}
     * @memberof MarginTradingApiGetMarginMaxBorrowableV1
     */
    readonly isolatedSymbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginMaxBorrowableV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginMaxTransferableV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginMaxTransferableV1Request
 */
export interface MarginTradingApiGetMarginMaxTransferableV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginMaxTransferableV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginMaxTransferableV1
     */
    readonly timestamp: number

    /**
     * isolated symbol
     * @type {string}
     * @memberof MarginTradingApiGetMarginMaxTransferableV1
     */
    readonly isolatedSymbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginMaxTransferableV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginMyTradesV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginMyTradesV1Request
 */
export interface MarginTradingApiGetMarginMyTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly isIsolated?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly endTime?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginMyTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginNextHourlyInterestRateV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginNextHourlyInterestRateV1Request
 */
export interface MarginTradingApiGetMarginNextHourlyInterestRateV1Request {
    /**
     * List of assets, separated by commas, up to 20
     * @type {string}
     * @memberof MarginTradingApiGetMarginNextHourlyInterestRateV1
     */
    readonly assets: string

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;
     * @type {boolean}
     * @memberof MarginTradingApiGetMarginNextHourlyInterestRateV1
     */
    readonly isIsolated: boolean
}

/**
 * Request parameters for getMarginOpenOrderListV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginOpenOrderListV1Request
 */
export interface MarginTradingApiGetMarginOpenOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginOpenOrderListV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginOpenOrderListV1
     */
    readonly isIsolated?: string

    /**
     * mandatory for isolated margin, not supported for cross margin
     * @type {string}
     * @memberof MarginTradingApiGetMarginOpenOrderListV1
     */
    readonly symbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginOpenOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginOpenOrdersV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginOpenOrdersV1Request
 */
export interface MarginTradingApiGetMarginOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginOpenOrdersV1
     */
    readonly isIsolated?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginOrderListV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginOrderListV1Request
 */
export interface MarginTradingApiGetMarginOrderListV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginOrderListV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginOrderListV1
     */
    readonly isIsolated?: string

    /**
     * mandatory for isolated margin, not supported for cross margin
     * @type {string}
     * @memberof MarginTradingApiGetMarginOrderListV1
     */
    readonly symbol?: string

    /**
     * Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
     * @type {number}
     * @memberof MarginTradingApiGetMarginOrderListV1
     */
    readonly orderListId?: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
     * @type {string}
     * @memberof MarginTradingApiGetMarginOrderListV1
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginOrderListV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginOrderV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginOrderV1Request
 */
export interface MarginTradingApiGetMarginOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginOrderV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginOrderV1
     */
    readonly isIsolated?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginPriceIndexV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginPriceIndexV1Request
 */
export interface MarginTradingApiGetMarginPriceIndexV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginPriceIndexV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getMarginRateLimitOrderV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginRateLimitOrderV1Request
 */
export interface MarginTradingApiGetMarginRateLimitOrderV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginRateLimitOrderV1
     */
    readonly timestamp: number

    /**
     * for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
     * @type {string}
     * @memberof MarginTradingApiGetMarginRateLimitOrderV1
     */
    readonly isIsolated?: string

    /**
     * isolated symbol, mandatory for isolated margin
     * @type {string}
     * @memberof MarginTradingApiGetMarginRateLimitOrderV1
     */
    readonly symbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginRateLimitOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginTradeCoeffV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginTradeCoeffV1Request
 */
export interface MarginTradingApiGetMarginTradeCoeffV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginTradeCoeffV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginTradeCoeffV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarginTransferV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiGetMarginTransferV1Request
 */
export interface MarginTradingApiGetMarginTransferV1Request {
    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly asset?: string

    /**
     * Transfer Type: ROLL_IN, ROLL_OUT
     * @type {string}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly type?: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly endTime?: number

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly current?: number

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly size?: number

    /**
     * Symbol in Isolated Margin
     * @type {string}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly isolatedSymbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof MarginTradingApiGetMarginTransferV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateMarginApiKeyIpV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiUpdateMarginApiKeyIpV1Request
 */
export interface MarginTradingApiUpdateMarginApiKeyIpV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiUpdateMarginApiKeyIpV1
     */
    readonly apiKey: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiUpdateMarginApiKeyIpV1
     */
    readonly ip: string

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiUpdateMarginApiKeyIpV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof MarginTradingApiUpdateMarginApiKeyIpV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiUpdateMarginApiKeyIpV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for updateMarginListenKeyV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiUpdateMarginListenKeyV1Request
 */
export interface MarginTradingApiUpdateMarginListenKeyV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiUpdateMarginListenKeyV1
     */
    readonly listenKey: string
}

/**
 * Request parameters for updateUserDataStreamIsolatedV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiUpdateUserDataStreamIsolatedV1Request
 */
export interface MarginTradingApiUpdateUserDataStreamIsolatedV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiUpdateUserDataStreamIsolatedV1
     */
    readonly listenKey: string

    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiUpdateUserDataStreamIsolatedV1
     */
    readonly symbol: string
}

/**
 * Request parameters for updateUserDataStreamV1 operation in MarginTradingApi.
 * @export
 * @interface MarginTradingApiUpdateUserDataStreamV1Request
 */
export interface MarginTradingApiUpdateUserDataStreamV1Request {
    /**
     * 
     * @type {string}
     * @memberof MarginTradingApiUpdateUserDataStreamV1
     */
    readonly listenKey: string
}

/**
 * MarginTradingApi - object-oriented interface
 * @export
 * @class MarginTradingApi
 * @extends {BaseAPI}
 */
export class MarginTradingApi extends BaseAPI implements MarginTradingApiInterface {
    /**
     * **Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **
     * @summary Create Special Key(Low-Latency Trading)(TRADE)
     * @param {MarginTradingApiCreateMarginApiKeyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginApiKeyV1(requestParameters: MarginTradingApiCreateMarginApiKeyV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginApiKeyV1(requestParameters.apiName, requestParameters.timestamp, requestParameters.ip, requestParameters.permissionMode, requestParameters.publicKey, requestParameters.recvWindow, requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Margin account borrow/repay(MARGIN)
     * @summary Margin account borrow/repay(MARGIN)
     * @param {MarginTradingApiCreateMarginBorrowRepayV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginBorrowRepayV1(requestParameters: MarginTradingApiCreateMarginBorrowRepayV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginBorrowRepayV1(requestParameters.amount, requestParameters.asset, requestParameters.isIsolated, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Small Liability Exchange
     * @summary Small Liability Exchange (MARGIN)
     * @param {MarginTradingApiCreateMarginExchangeSmallLiabilityV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginExchangeSmallLiabilityV1(requestParameters: MarginTradingApiCreateMarginExchangeSmallLiabilityV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginExchangeSmallLiabilityV1(requestParameters.assetNames, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).
     * @summary Enable Isolated Margin Account (TRADE)
     * @param {MarginTradingApiCreateMarginIsolatedAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginIsolatedAccountV1(requestParameters: MarginTradingApiCreateMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginIsolatedAccountV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new user data stream.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginListenKeyV1(options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Margin Manual Liquidation
     * @summary Margin Manual Liquidation(MARGIN)
     * @param {MarginTradingApiCreateMarginManualLiquidationV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginManualLiquidationV1(requestParameters: MarginTradingApiCreateMarginManualLiquidationV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginManualLiquidationV1(requestParameters.timestamp, requestParameters.type, requestParameters.recvWindow, requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adjust cross margin max leverage
     * @summary Adjust cross margin max leverage (USER_DATA)
     * @param {MarginTradingApiCreateMarginMaxLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginMaxLeverageV1(requestParameters: MarginTradingApiCreateMarginMaxLeverageV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginMaxLeverageV1(requestParameters.maxLeverage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new OCO for a margin account
     * @summary Margin Account New OCO (TRADE)
     * @param {MarginTradingApiCreateMarginOrderOcoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginOrderOcoV1(requestParameters: MarginTradingApiCreateMarginOrderOcoV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginOrderOcoV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.autoRepayAtCancel, requestParameters.isIsolated, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Post a new OTO order for margin account:
     * @summary Margin Account New OTO (TRADE)
     * @param {MarginTradingApiCreateMarginOrderOtoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginOrderOtoV1(requestParameters: MarginTradingApiCreateMarginOrderOtoV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginOrderOtoV1(requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.pendingType, requestParameters.symbol, requestParameters.workingIcebergQty, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.autoRepayAtCancel, requestParameters.isIsolated, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingClientOrderId, requestParameters.pendingIcebergQty, requestParameters.pendingPrice, requestParameters.pendingStopPrice, requestParameters.pendingTimeInForce, requestParameters.pendingTrailingDelta, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.workingClientOrderId, requestParameters.workingTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Post a new OTOCO order for margin account：
     * @summary Margin Account New OTOCO (TRADE)
     * @param {MarginTradingApiCreateMarginOrderOtocoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginOrderOtocoV1(requestParameters: MarginTradingApiCreateMarginOrderOtocoV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginOrderOtocoV1(requestParameters.pendingAboveType, requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.symbol, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.autoRepayAtCancel, requestParameters.isIsolated, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingAboveClientOrderId, requestParameters.pendingAboveIcebergQty, requestParameters.pendingAbovePrice, requestParameters.pendingAboveStopPrice, requestParameters.pendingAboveTimeInForce, requestParameters.pendingAboveTrailingDelta, requestParameters.pendingBelowClientOrderId, requestParameters.pendingBelowIcebergQty, requestParameters.pendingBelowPrice, requestParameters.pendingBelowStopPrice, requestParameters.pendingBelowTimeInForce, requestParameters.pendingBelowTrailingDelta, requestParameters.pendingBelowType, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Post a new order for margin account.
     * @summary Margin Account New Order (TRADE)
     * @param {MarginTradingApiCreateMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createMarginOrderV1(requestParameters: MarginTradingApiCreateMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createMarginOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.autoRepayAtCancel, requestParameters.icebergQty, requestParameters.isIsolated, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.sideEffectType, requestParameters.stopPrice, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new isolated margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start Isolated Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiCreateUserDataStreamIsolatedV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createUserDataStreamIsolatedV1(requestParameters: MarginTradingApiCreateUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createUserDataStreamIsolatedV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start Margin User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public createUserDataStreamV1(options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).createUserDataStreamV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This only applies to Special Key for Low Latency Trading.
     * @summary Delete Special Key(Low-Latency Trading)(TRADE)
     * @param {MarginTradingApiDeleteMarginApiKeyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public deleteMarginApiKeyV1(requestParameters: MarginTradingApiDeleteMarginApiKeyV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).deleteMarginApiKeyV1(requestParameters.timestamp, requestParameters.apiKey, requestParameters.apiName, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours.
     * @summary Disable Isolated Margin Account (TRADE)
     * @param {MarginTradingApiDeleteMarginIsolatedAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public deleteMarginIsolatedAccountV1(requestParameters: MarginTradingApiDeleteMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).deleteMarginIsolatedAccountV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public deleteMarginListenKeyV1(options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).deleteMarginListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels all active orders on a symbol for margin account. This includes OCO orders.
     * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
     * @param {MarginTradingApiDeleteMarginOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public deleteMarginOpenOrdersV1(requestParameters: MarginTradingApiDeleteMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).deleteMarginOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an entire Order List for a margin account.
     * @summary Margin Account Cancel OCO (TRADE)
     * @param {MarginTradingApiDeleteMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public deleteMarginOrderListV1(requestParameters: MarginTradingApiDeleteMarginOrderListV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).deleteMarginOrderListV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order for margin account.
     * @summary Margin Account Cancel Order (TRADE)
     * @param {MarginTradingApiDeleteMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public deleteMarginOrderV1(requestParameters: MarginTradingApiDeleteMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).deleteMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a isolated margin user data stream.
     * @summary Close Isolated Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiDeleteUserDataStreamIsolatedV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public deleteUserDataStreamIsolatedV1(requestParameters: MarginTradingApiDeleteUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).deleteUserDataStreamIsolatedV1(requestParameters.symbol, requestParameters.listenkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a Margin user data stream.
     * @summary Close Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiDeleteUserDataStreamV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public deleteUserDataStreamV1(requestParameters: MarginTradingApiDeleteUserDataStreamV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).deleteUserDataStreamV1(requestParameters.listenkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get BNB Burn Status
     * @summary Get BNB Burn Status (USER_DATA)
     * @param {MarginTradingApiGetBnbBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getBnbBurnV1(requestParameters: MarginTradingApiGetBnbBurnV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getBnbBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Cross Margin Account Details
     * @summary Query Cross Margin Account Details (USER_DATA)
     * @param {MarginTradingApiGetMarginAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginAccountV1(requestParameters: MarginTradingApiGetMarginAccountV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginAccountV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get All Margin Assets.
     * @summary Get All Margin Assets (MARKET_DATA)
     * @param {MarginTradingApiGetMarginAllAssetsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginAllAssetsV1(requestParameters: MarginTradingApiGetMarginAllAssetsV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginAllAssetsV1(requestParameters.asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all OCO for a specific margin account based on provided optional parameters
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {MarginTradingApiGetMarginAllOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginAllOrderListV1(requestParameters: MarginTradingApiGetMarginAllOrderListV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginAllOrderListV1(requestParameters.timestamp, requestParameters.isIsolated, requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account\'s All Orders
     * @summary Query Margin Account\'s All Orders (USER_DATA)
     * @param {MarginTradingApiGetMarginAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginAllOrdersV1(requestParameters: MarginTradingApiGetMarginAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get All Cross Margin Pairs
     * @summary Get All Cross Margin Pairs (MARKET_DATA)
     * @param {MarginTradingApiGetMarginAllPairsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginAllPairsV1(requestParameters: MarginTradingApiGetMarginAllPairsV1Request = {}, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginAllPairsV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This only applies to Special Key for Low Latency Trading.
     * @summary Query Special key List(Low Latency Trading)(TRADE)
     * @param {MarginTradingApiGetMarginApiKeyListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginApiKeyListV1(requestParameters: MarginTradingApiGetMarginApiKeyListV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginApiKeyListV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Special Key Information.
     * @summary Query Special key(Low Latency Trading)(TRADE)
     * @param {MarginTradingApiGetMarginApiKeyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginApiKeyV1(requestParameters: MarginTradingApiGetMarginApiKeyV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginApiKeyV1(requestParameters.apiKey, requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Margin available Inventory query
     * @summary Query Margin Available Inventory(USER_DATA)
     * @param {MarginTradingApiGetMarginAvailableInventoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginAvailableInventoryV1(requestParameters: MarginTradingApiGetMarginAvailableInventoryV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginAvailableInventoryV1(requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query borrow/repay records in Margin account
     * @summary Query borrow/repay records in Margin account(USER_DATA)
     * @param {MarginTradingApiGetMarginBorrowRepayV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginBorrowRepayV1(requestParameters: MarginTradingApiGetMarginBorrowRepayV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginBorrowRepayV1(requestParameters.type, requestParameters.timestamp, requestParameters.asset, requestParameters.isolatedSymbol, requestParameters.txId, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Cross Isolated Margin Capital Flow
     * @summary Query Cross Isolated Margin Capital Flow (USER_DATA)
     * @param {MarginTradingApiGetMarginCapitalFlowV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginCapitalFlowV1(requestParameters: MarginTradingApiGetMarginCapitalFlowV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginCapitalFlowV1(requestParameters.timestamp, requestParameters.asset, requestParameters.symbol, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cross margin collateral ratio
     * @summary Cross margin collateral ratio (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginCrossMarginCollateralRatioV1(options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginCrossMarginCollateralRatioV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get cross margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
     * @summary Query Cross Margin Fee Data (USER_DATA)
     * @param {MarginTradingApiGetMarginCrossMarginDataV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginCrossMarginDataV1(requestParameters: MarginTradingApiGetMarginCrossMarginDataV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginCrossMarginDataV1(requestParameters.timestamp, requestParameters.vipLevel, requestParameters.coin, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tokens or symbols delist schedule for cross margin and isolated margin
     * @summary Get Delist Schedule (MARKET_DATA)
     * @param {MarginTradingApiGetMarginDelistScheduleV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginDelistScheduleV1(requestParameters: MarginTradingApiGetMarginDelistScheduleV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginDelistScheduleV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Small liability Exchange History
     * @summary Get Small Liability Exchange History (USER_DATA)
     * @param {MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginExchangeSmallLiabilityHistoryV1(requestParameters: MarginTradingApiGetMarginExchangeSmallLiabilityHistoryV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginExchangeSmallLiabilityHistoryV1(requestParameters.current, requestParameters.size, requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query the coins which can be small liability exchange
     * @summary Get Small Liability Exchange Coin List (USER_DATA)
     * @param {MarginTradingApiGetMarginExchangeSmallLiabilityV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginExchangeSmallLiabilityV1(requestParameters: MarginTradingApiGetMarginExchangeSmallLiabilityV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginExchangeSmallLiabilityV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Force Liquidation Record
     * @summary Get Force Liquidation Record (USER_DATA)
     * @param {MarginTradingApiGetMarginForceLiquidationRecV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginForceLiquidationRecV1(requestParameters: MarginTradingApiGetMarginForceLiquidationRecV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginForceLiquidationRecV1(requestParameters.timestamp, requestParameters.startTime, requestParameters.endTime, requestParameters.isolatedSymbol, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Interest History
     * @summary Get Interest History (USER_DATA)
     * @param {MarginTradingApiGetMarginInterestHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginInterestHistoryV1(requestParameters: MarginTradingApiGetMarginInterestHistoryV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginInterestHistoryV1(requestParameters.timestamp, requestParameters.asset, requestParameters.isolatedSymbol, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Interest Rate History
     * @summary Query Margin Interest Rate History (USER_DATA)
     * @param {MarginTradingApiGetMarginInterestRateHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginInterestRateHistoryV1(requestParameters: MarginTradingApiGetMarginInterestRateHistoryV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginInterestRateHistoryV1(requestParameters.asset, requestParameters.timestamp, requestParameters.vipLevel, requestParameters.startTime, requestParameters.endTime, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query enabled isolated margin account limit.
     * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
     * @param {MarginTradingApiGetMarginIsolatedAccountLimitV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginIsolatedAccountLimitV1(requestParameters: MarginTradingApiGetMarginIsolatedAccountLimitV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginIsolatedAccountLimitV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Isolated Margin Account Info
     * @summary Query Isolated Margin Account Info (USER_DATA)
     * @param {MarginTradingApiGetMarginIsolatedAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginIsolatedAccountV1(requestParameters: MarginTradingApiGetMarginIsolatedAccountV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginIsolatedAccountV1(requestParameters.timestamp, requestParameters.symbols, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get All Isolated Margin Symbol
     * @summary Get All Isolated Margin Symbol(MARKET_DATA)
     * @param {MarginTradingApiGetMarginIsolatedAllPairsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginIsolatedAllPairsV1(requestParameters: MarginTradingApiGetMarginIsolatedAllPairsV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginIsolatedAllPairsV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get isolated margin fee data collection with any vip level or user\'s current specific data as https://www.binance.com/en/margin-fee
     * @summary Query Isolated Margin Fee Data (USER_DATA)
     * @param {MarginTradingApiGetMarginIsolatedMarginDataV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginIsolatedMarginDataV1(requestParameters: MarginTradingApiGetMarginIsolatedMarginDataV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginIsolatedMarginDataV1(requestParameters.timestamp, requestParameters.vipLevel, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data
     * @summary Query Isolated Margin Tier Data (USER_DATA)
     * @param {MarginTradingApiGetMarginIsolatedMarginTierV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginIsolatedMarginTierV1(requestParameters: MarginTradingApiGetMarginIsolatedMarginTierV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginIsolatedMarginTierV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.tier, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Liability Coin Leverage Bracket in Cross Margin Pro Mode
     * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode(MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginLeverageBracketV1(options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginLeverageBracketV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Max Borrow
     * @summary Query Max Borrow (USER_DATA)
     * @param {MarginTradingApiGetMarginMaxBorrowableV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginMaxBorrowableV1(requestParameters: MarginTradingApiGetMarginMaxBorrowableV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginMaxBorrowableV1(requestParameters.asset, requestParameters.timestamp, requestParameters.isolatedSymbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Max Transfer-Out Amount
     * @summary Query Max Transfer-Out Amount (USER_DATA)
     * @param {MarginTradingApiGetMarginMaxTransferableV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginMaxTransferableV1(requestParameters: MarginTradingApiGetMarginMaxTransferableV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginMaxTransferableV1(requestParameters.asset, requestParameters.timestamp, requestParameters.isolatedSymbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account\'s Trade List
     * @summary Query Margin Account\'s Trade List (USER_DATA)
     * @param {MarginTradingApiGetMarginMyTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginMyTradesV1(requestParameters: MarginTradingApiGetMarginMyTradesV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginMyTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get future hourly interest rate
     * @summary Get future hourly interest rate (USER_DATA)
     * @param {MarginTradingApiGetMarginNextHourlyInterestRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginNextHourlyInterestRateV1(requestParameters: MarginTradingApiGetMarginNextHourlyInterestRateV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginNextHourlyInterestRateV1(requestParameters.assets, requestParameters.isIsolated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account\'s Open OCO
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {MarginTradingApiGetMarginOpenOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginOpenOrderListV1(requestParameters: MarginTradingApiGetMarginOpenOrderListV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginOpenOrderListV1(requestParameters.timestamp, requestParameters.isIsolated, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account\'s Open Orders
     * @summary Query Margin Account\'s Open Orders (USER_DATA)
     * @param {MarginTradingApiGetMarginOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginOpenOrdersV1(requestParameters: MarginTradingApiGetMarginOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.isIsolated, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific OCO based on provided optional parameters
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {MarginTradingApiGetMarginOrderListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginOrderListV1(requestParameters: MarginTradingApiGetMarginOrderListV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginOrderListV1(requestParameters.timestamp, requestParameters.isIsolated, requestParameters.symbol, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin Account\'s Order
     * @summary Query Margin Account\'s Order (USER_DATA)
     * @param {MarginTradingApiGetMarginOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginOrderV1(requestParameters: MarginTradingApiGetMarginOrderV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.isIsolated, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query Margin PriceIndex
     * @summary Query Margin PriceIndex (MARKET_DATA)
     * @param {MarginTradingApiGetMarginPriceIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginPriceIndexV1(requestParameters: MarginTradingApiGetMarginPriceIndexV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginPriceIndexV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Displays the user\'s current margin order count usage for all intervals.
     * @summary Query Current Margin Order Count Usage (TRADE)
     * @param {MarginTradingApiGetMarginRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginRateLimitOrderV1(requestParameters: MarginTradingApiGetMarginRateLimitOrderV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginRateLimitOrderV1(requestParameters.timestamp, requestParameters.isIsolated, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get personal margin level information
     * @summary Get Summary of Margin account (USER_DATA)
     * @param {MarginTradingApiGetMarginTradeCoeffV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginTradeCoeffV1(requestParameters: MarginTradingApiGetMarginTradeCoeffV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginTradeCoeffV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Cross Margin Transfer History
     * @summary Get Cross Margin Transfer History (USER_DATA)
     * @param {MarginTradingApiGetMarginTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public getMarginTransferV1(requestParameters: MarginTradingApiGetMarginTransferV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).getMarginTransferV1(requestParameters.timestamp, requestParameters.asset, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.current, requestParameters.size, requestParameters.isolatedSymbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit ip restriction. This only applies to Special Key for Low Latency Trading.
     * @summary Edit ip for Special Key(Low-Latency Trading)(TRADE)
     * @param {MarginTradingApiUpdateMarginApiKeyIpV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public updateMarginApiKeyIpV1(requestParameters: MarginTradingApiUpdateMarginApiKeyIpV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).updateMarginApiKeyIpV1(requestParameters.apiKey, requestParameters.ip, requestParameters.timestamp, requestParameters.recvWindow, requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a user data stream to prevent a time out.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {MarginTradingApiUpdateMarginListenKeyV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public updateMarginListenKeyV1(requestParameters: MarginTradingApiUpdateMarginListenKeyV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).updateMarginListenKeyV1(requestParameters.listenKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive an isolated margin user data stream to prevent a time out.
     * @summary Keepalive Isolated Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiUpdateUserDataStreamIsolatedV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public updateUserDataStreamIsolatedV1(requestParameters: MarginTradingApiUpdateUserDataStreamIsolatedV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).updateUserDataStreamIsolatedV1(requestParameters.listenKey, requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a margin user data stream to prevent a time out.
     * @summary Keepalive Margin User Data Stream (USER_STREAM)
     * @param {MarginTradingApiUpdateUserDataStreamV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginTradingApi
     */
    public updateUserDataStreamV1(requestParameters: MarginTradingApiUpdateUserDataStreamV1Request, options?: RawAxiosRequestConfig) {
        return MarginTradingApiFp(this.configuration).updateUserDataStreamV1(requestParameters.listenKey, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateMarginOrderOtoV1WorkingTypeEnum = {
    Limit: 'LIMIT',
    LimitMaker: 'LIMIT_MAKER'
} as const;
export type CreateMarginOrderOtoV1WorkingTypeEnum = typeof CreateMarginOrderOtoV1WorkingTypeEnum[keyof typeof CreateMarginOrderOtoV1WorkingTypeEnum];
/**
 * @export
 */
export const CreateMarginOrderOtocoV1PendingAboveTypeEnum = {
    LimitMaker: 'LIMIT_MAKER',
    StopLoss: 'STOP_LOSS',
    AndStopLossLimit: 'and `STOP_LOSS_LIMIT'
} as const;
export type CreateMarginOrderOtocoV1PendingAboveTypeEnum = typeof CreateMarginOrderOtocoV1PendingAboveTypeEnum[keyof typeof CreateMarginOrderOtocoV1PendingAboveTypeEnum];
/**
 * @export
 */
export const CreateMarginOrderOtocoV1WorkingTypeEnum = {
    Limit: 'LIMIT',
    LimitMaker: 'LIMIT_MAKER'
} as const;
export type CreateMarginOrderOtocoV1WorkingTypeEnum = typeof CreateMarginOrderOtocoV1WorkingTypeEnum[keyof typeof CreateMarginOrderOtocoV1WorkingTypeEnum];
/**
 * @export
 */
export const CreateMarginOrderOtocoV1PendingBelowTypeEnum = {
    LimitMaker: 'LIMIT_MAKER',
    StopLoss: 'STOP_LOSS',
    AndStopLossLimit: 'and `STOP_LOSS_LIMIT'
} as const;
export type CreateMarginOrderOtocoV1PendingBelowTypeEnum = typeof CreateMarginOrderOtocoV1PendingBelowTypeEnum[keyof typeof CreateMarginOrderOtocoV1PendingBelowTypeEnum];
