/* tslint:disable */
/* eslint-disable */
/**
 * Binance Spot API
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { SpotCreateOrderCancelReplaceV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateOrderListOcoV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateOrderListOtoV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateOrderListOtocoV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateOrderOcoV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateOrderTestV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateOrderV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateSorOrderTestV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateSorOrderV3Resp } from '../model';
// @ts-ignore
import type { SpotDeleteOpenOrdersV3RespInner } from '../model';
// @ts-ignore
import type { SpotDeleteOrderListV3Resp } from '../model';
// @ts-ignore
import type { SpotDeleteOrderV3Resp } from '../model';
// @ts-ignore
import type { SpotGetAllOrderListV3RespItem } from '../model';
// @ts-ignore
import type { SpotGetAllOrdersV3RespItem } from '../model';
// @ts-ignore
import type { SpotGetOpenOrderListV3RespItem } from '../model';
// @ts-ignore
import type { SpotGetOpenOrdersV3RespItem } from '../model';
// @ts-ignore
import type { SpotGetOrderListV3Resp } from '../model';
// @ts-ignore
import type { SpotGetOrderV3Resp } from '../model';
/**
 * TradingApi - axios parameter creator
 * @export
 */
export const TradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
         * @summary Cancel an Existing Order and Send a New Order (TRADE)
         * @param {string} cancelReplaceMode 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [cancelNewClientOrderId] 
         * @param {number} [cancelOrderId] 
         * @param {string} [cancelOrigClientOrderId] 
         * @param {string} [cancelRestrictions] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [orderRateLimitExceededMode] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderCancelReplaceV3: async (cancelReplaceMode: string, side: string, symbol: string, timestamp: number, type: string, cancelNewClientOrderId?: string, cancelOrderId?: number, cancelOrigClientOrderId?: string, cancelRestrictions?: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, orderRateLimitExceededMode?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelReplaceMode' is not null or undefined
            assertParamExists('spotCreateOrderCancelReplaceV3', 'cancelReplaceMode', cancelReplaceMode)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('spotCreateOrderCancelReplaceV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateOrderCancelReplaceV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateOrderCancelReplaceV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('spotCreateOrderCancelReplaceV3', 'type', type)
            const localVarPath = `/api/v3/order/cancelReplace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (cancelNewClientOrderId !== undefined) { 
                localVarFormParams.set('cancelNewClientOrderId', cancelNewClientOrderId as any);
            }
    
            if (cancelOrderId !== undefined) { 
                localVarFormParams.set('cancelOrderId', cancelOrderId as any);
            }
    
            if (cancelOrigClientOrderId !== undefined) { 
                localVarFormParams.set('cancelOrigClientOrderId', cancelOrigClientOrderId as any);
            }
    
            if (cancelReplaceMode !== undefined) { 
                localVarFormParams.set('cancelReplaceMode', cancelReplaceMode as any);
            }
    
            if (cancelRestrictions !== undefined) { 
                localVarFormParams.set('cancelRestrictions', cancelRestrictions as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (orderRateLimitExceededMode !== undefined) { 
                localVarFormParams.set('orderRateLimitExceededMode', orderRateLimitExceededMode as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (trailingDelta !== undefined) { 
                localVarFormParams.set('trailingDelta', trailingDelta as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
         * @summary New Order list - OCO (TRADE)
         * @param {SpotCreateOrderListOcoV3AboveTypeEnum} aboveType 
         * @param {SpotCreateOrderListOcoV3BelowTypeEnum} belowType 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [aboveClientOrderId] 
         * @param {number} [aboveIcebergQty] 
         * @param {string} [abovePrice] 
         * @param {string} [aboveStopPrice] 
         * @param {number} [aboveStrategyId] 
         * @param {number} [aboveStrategyType] 
         * @param {string} [aboveTimeInForce] 
         * @param {number} [aboveTrailingDelta] 
         * @param {string} [belowClientOrderId] 
         * @param {number} [belowIcebergQty] 
         * @param {string} [belowPrice] 
         * @param {string} [belowStopPrice] 
         * @param {number} [belowStrategyId] 
         * @param {number} [belowStrategyType] 
         * @param {string} [belowTimeInForce] 
         * @param {number} [belowTrailingDelta] 
         * @param {string} [listClientOrderId] 
         * @param {SpotCreateOrderListOcoV3NewOrderRespTypeEnum} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderListOcoV3: async (aboveType: SpotCreateOrderListOcoV3AboveTypeEnum, belowType: SpotCreateOrderListOcoV3BelowTypeEnum, quantity: string, side: string, symbol: string, timestamp: number, aboveClientOrderId?: string, aboveIcebergQty?: number, abovePrice?: string, aboveStopPrice?: string, aboveStrategyId?: number, aboveStrategyType?: number, aboveTimeInForce?: string, aboveTrailingDelta?: number, belowClientOrderId?: string, belowIcebergQty?: number, belowPrice?: string, belowStopPrice?: string, belowStrategyId?: number, belowStrategyType?: number, belowTimeInForce?: string, belowTrailingDelta?: number, listClientOrderId?: string, newOrderRespType?: SpotCreateOrderListOcoV3NewOrderRespTypeEnum, recvWindow?: number, selfTradePreventionMode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aboveType' is not null or undefined
            assertParamExists('spotCreateOrderListOcoV3', 'aboveType', aboveType)
            // verify required parameter 'belowType' is not null or undefined
            assertParamExists('spotCreateOrderListOcoV3', 'belowType', belowType)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('spotCreateOrderListOcoV3', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('spotCreateOrderListOcoV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateOrderListOcoV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateOrderListOcoV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/orderList/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (aboveClientOrderId !== undefined) { 
                localVarFormParams.set('aboveClientOrderId', aboveClientOrderId as any);
            }
    
            if (aboveIcebergQty !== undefined) { 
                localVarFormParams.set('aboveIcebergQty', aboveIcebergQty as any);
            }
    
            if (abovePrice !== undefined) { 
                localVarFormParams.set('abovePrice', abovePrice as any);
            }
    
            if (aboveStopPrice !== undefined) { 
                localVarFormParams.set('aboveStopPrice', aboveStopPrice as any);
            }
    
            if (aboveStrategyId !== undefined) { 
                localVarFormParams.set('aboveStrategyId', aboveStrategyId as any);
            }
    
            if (aboveStrategyType !== undefined) { 
                localVarFormParams.set('aboveStrategyType', aboveStrategyType as any);
            }
    
            if (aboveTimeInForce !== undefined) { 
                localVarFormParams.set('aboveTimeInForce', aboveTimeInForce as any);
            }
    
            if (aboveTrailingDelta !== undefined) { 
                localVarFormParams.set('aboveTrailingDelta', aboveTrailingDelta as any);
            }
    
            if (aboveType !== undefined) { 
                localVarFormParams.set('aboveType', aboveType as any);
            }
    
            if (belowClientOrderId !== undefined) { 
                localVarFormParams.set('belowClientOrderId', belowClientOrderId as any);
            }
    
            if (belowIcebergQty !== undefined) { 
                localVarFormParams.set('belowIcebergQty', belowIcebergQty as any);
            }
    
            if (belowPrice !== undefined) { 
                localVarFormParams.set('belowPrice', belowPrice as any);
            }
    
            if (belowStopPrice !== undefined) { 
                localVarFormParams.set('belowStopPrice', belowStopPrice as any);
            }
    
            if (belowStrategyId !== undefined) { 
                localVarFormParams.set('belowStrategyId', belowStrategyId as any);
            }
    
            if (belowStrategyType !== undefined) { 
                localVarFormParams.set('belowStrategyType', belowStrategyType as any);
            }
    
            if (belowTimeInForce !== undefined) { 
                localVarFormParams.set('belowTimeInForce', belowTimeInForce as any);
            }
    
            if (belowTrailingDelta !== undefined) { 
                localVarFormParams.set('belowTrailingDelta', belowTrailingDelta as any);
            }
    
            if (belowType !== undefined) { 
                localVarFormParams.set('belowType', belowType as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTO (TRADE)
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} pendingType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {SpotCreateOrderListOtoV3WorkingTypeEnum} workingType 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingClientOrderId] 
         * @param {string} [pendingIcebergQty] 
         * @param {string} [pendingPrice] 
         * @param {string} [pendingStopPrice] 
         * @param {number} [pendingStrategyId] 
         * @param {number} [pendingStrategyType] 
         * @param {string} [pendingTimeInForce] 
         * @param {string} [pendingTrailingDelta] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {number} [workingStrategyId] 
         * @param {number} [workingStrategyType] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderListOtoV3: async (pendingQuantity: string, pendingSide: string, pendingType: string, symbol: string, timestamp: number, workingPrice: string, workingQuantity: string, workingSide: string, workingType: SpotCreateOrderListOtoV3WorkingTypeEnum, listClientOrderId?: string, newOrderRespType?: string, pendingClientOrderId?: string, pendingIcebergQty?: string, pendingPrice?: string, pendingStopPrice?: string, pendingStrategyId?: number, pendingStrategyType?: number, pendingTimeInForce?: string, pendingTrailingDelta?: string, recvWindow?: number, selfTradePreventionMode?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingStrategyId?: number, workingStrategyType?: number, workingTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'pendingQuantity', pendingQuantity)
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'pendingSide', pendingSide)
            // verify required parameter 'pendingType' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'pendingType', pendingType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'timestamp', timestamp)
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'workingPrice', workingPrice)
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'workingQuantity', workingQuantity)
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'workingSide', workingSide)
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('spotCreateOrderListOtoV3', 'workingType', workingType)
            const localVarPath = `/api/v3/orderList/oto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (pendingClientOrderId !== undefined) { 
                localVarFormParams.set('pendingClientOrderId', pendingClientOrderId as any);
            }
    
            if (pendingIcebergQty !== undefined) { 
                localVarFormParams.set('pendingIcebergQty', pendingIcebergQty as any);
            }
    
            if (pendingPrice !== undefined) { 
                localVarFormParams.set('pendingPrice', pendingPrice as any);
            }
    
            if (pendingQuantity !== undefined) { 
                localVarFormParams.set('pendingQuantity', pendingQuantity as any);
            }
    
            if (pendingSide !== undefined) { 
                localVarFormParams.set('pendingSide', pendingSide as any);
            }
    
            if (pendingStopPrice !== undefined) { 
                localVarFormParams.set('pendingStopPrice', pendingStopPrice as any);
            }
    
            if (pendingStrategyId !== undefined) { 
                localVarFormParams.set('pendingStrategyId', pendingStrategyId as any);
            }
    
            if (pendingStrategyType !== undefined) { 
                localVarFormParams.set('pendingStrategyType', pendingStrategyType as any);
            }
    
            if (pendingTimeInForce !== undefined) { 
                localVarFormParams.set('pendingTimeInForce', pendingTimeInForce as any);
            }
    
            if (pendingTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingTrailingDelta', pendingTrailingDelta as any);
            }
    
            if (pendingType !== undefined) { 
                localVarFormParams.set('pendingType', pendingType as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (workingClientOrderId !== undefined) { 
                localVarFormParams.set('workingClientOrderId', workingClientOrderId as any);
            }
    
            if (workingIcebergQty !== undefined) { 
                localVarFormParams.set('workingIcebergQty', workingIcebergQty as any);
            }
    
            if (workingPrice !== undefined) { 
                localVarFormParams.set('workingPrice', workingPrice as any);
            }
    
            if (workingQuantity !== undefined) { 
                localVarFormParams.set('workingQuantity', workingQuantity as any);
            }
    
            if (workingSide !== undefined) { 
                localVarFormParams.set('workingSide', workingSide as any);
            }
    
            if (workingStrategyId !== undefined) { 
                localVarFormParams.set('workingStrategyId', workingStrategyId as any);
            }
    
            if (workingStrategyType !== undefined) { 
                localVarFormParams.set('workingStrategyType', workingStrategyType as any);
            }
    
            if (workingTimeInForce !== undefined) { 
                localVarFormParams.set('workingTimeInForce', workingTimeInForce as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTOCO (TRADE)
         * @param {SpotCreateOrderListOtocoV3PendingAboveTypeEnum} pendingAboveType 
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {SpotCreateOrderListOtocoV3WorkingTypeEnum} workingType 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingAboveClientOrderId] 
         * @param {string} [pendingAboveIcebergQty] 
         * @param {string} [pendingAbovePrice] 
         * @param {string} [pendingAboveStopPrice] 
         * @param {number} [pendingAboveStrategyId] 
         * @param {number} [pendingAboveStrategyType] 
         * @param {string} [pendingAboveTimeInForce] 
         * @param {string} [pendingAboveTrailingDelta] 
         * @param {string} [pendingBelowClientOrderId] 
         * @param {string} [pendingBelowIcebergQty] 
         * @param {string} [pendingBelowPrice] 
         * @param {string} [pendingBelowStopPrice] 
         * @param {number} [pendingBelowStrategyId] 
         * @param {number} [pendingBelowStrategyType] 
         * @param {string} [pendingBelowTimeInForce] 
         * @param {string} [pendingBelowTrailingDelta] 
         * @param {SpotCreateOrderListOtocoV3PendingBelowTypeEnum} [pendingBelowType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {number} [workingStrategyId] 
         * @param {number} [workingStrategyType] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderListOtocoV3: async (pendingAboveType: SpotCreateOrderListOtocoV3PendingAboveTypeEnum, pendingQuantity: string, pendingSide: string, symbol: string, timestamp: number, workingPrice: string, workingQuantity: string, workingSide: string, workingType: SpotCreateOrderListOtocoV3WorkingTypeEnum, listClientOrderId?: string, newOrderRespType?: string, pendingAboveClientOrderId?: string, pendingAboveIcebergQty?: string, pendingAbovePrice?: string, pendingAboveStopPrice?: string, pendingAboveStrategyId?: number, pendingAboveStrategyType?: number, pendingAboveTimeInForce?: string, pendingAboveTrailingDelta?: string, pendingBelowClientOrderId?: string, pendingBelowIcebergQty?: string, pendingBelowPrice?: string, pendingBelowStopPrice?: string, pendingBelowStrategyId?: number, pendingBelowStrategyType?: number, pendingBelowTimeInForce?: string, pendingBelowTrailingDelta?: string, pendingBelowType?: SpotCreateOrderListOtocoV3PendingBelowTypeEnum, recvWindow?: number, selfTradePreventionMode?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingStrategyId?: number, workingStrategyType?: number, workingTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingAboveType' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'pendingAboveType', pendingAboveType)
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'pendingQuantity', pendingQuantity)
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'pendingSide', pendingSide)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'timestamp', timestamp)
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'workingPrice', workingPrice)
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'workingQuantity', workingQuantity)
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'workingSide', workingSide)
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('spotCreateOrderListOtocoV3', 'workingType', workingType)
            const localVarPath = `/api/v3/orderList/otoco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (pendingAboveClientOrderId !== undefined) { 
                localVarFormParams.set('pendingAboveClientOrderId', pendingAboveClientOrderId as any);
            }
    
            if (pendingAboveIcebergQty !== undefined) { 
                localVarFormParams.set('pendingAboveIcebergQty', pendingAboveIcebergQty as any);
            }
    
            if (pendingAbovePrice !== undefined) { 
                localVarFormParams.set('pendingAbovePrice', pendingAbovePrice as any);
            }
    
            if (pendingAboveStopPrice !== undefined) { 
                localVarFormParams.set('pendingAboveStopPrice', pendingAboveStopPrice as any);
            }
    
            if (pendingAboveStrategyId !== undefined) { 
                localVarFormParams.set('pendingAboveStrategyId', pendingAboveStrategyId as any);
            }
    
            if (pendingAboveStrategyType !== undefined) { 
                localVarFormParams.set('pendingAboveStrategyType', pendingAboveStrategyType as any);
            }
    
            if (pendingAboveTimeInForce !== undefined) { 
                localVarFormParams.set('pendingAboveTimeInForce', pendingAboveTimeInForce as any);
            }
    
            if (pendingAboveTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingAboveTrailingDelta', pendingAboveTrailingDelta as any);
            }
    
            if (pendingAboveType !== undefined) { 
                localVarFormParams.set('pendingAboveType', pendingAboveType as any);
            }
    
            if (pendingBelowClientOrderId !== undefined) { 
                localVarFormParams.set('pendingBelowClientOrderId', pendingBelowClientOrderId as any);
            }
    
            if (pendingBelowIcebergQty !== undefined) { 
                localVarFormParams.set('pendingBelowIcebergQty', pendingBelowIcebergQty as any);
            }
    
            if (pendingBelowPrice !== undefined) { 
                localVarFormParams.set('pendingBelowPrice', pendingBelowPrice as any);
            }
    
            if (pendingBelowStopPrice !== undefined) { 
                localVarFormParams.set('pendingBelowStopPrice', pendingBelowStopPrice as any);
            }
    
            if (pendingBelowStrategyId !== undefined) { 
                localVarFormParams.set('pendingBelowStrategyId', pendingBelowStrategyId as any);
            }
    
            if (pendingBelowStrategyType !== undefined) { 
                localVarFormParams.set('pendingBelowStrategyType', pendingBelowStrategyType as any);
            }
    
            if (pendingBelowTimeInForce !== undefined) { 
                localVarFormParams.set('pendingBelowTimeInForce', pendingBelowTimeInForce as any);
            }
    
            if (pendingBelowTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingBelowTrailingDelta', pendingBelowTrailingDelta as any);
            }
    
            if (pendingBelowType !== undefined) { 
                localVarFormParams.set('pendingBelowType', pendingBelowType as any);
            }
    
            if (pendingQuantity !== undefined) { 
                localVarFormParams.set('pendingQuantity', pendingQuantity as any);
            }
    
            if (pendingSide !== undefined) { 
                localVarFormParams.set('pendingSide', pendingSide as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (workingClientOrderId !== undefined) { 
                localVarFormParams.set('workingClientOrderId', workingClientOrderId as any);
            }
    
            if (workingIcebergQty !== undefined) { 
                localVarFormParams.set('workingIcebergQty', workingIcebergQty as any);
            }
    
            if (workingPrice !== undefined) { 
                localVarFormParams.set('workingPrice', workingPrice as any);
            }
    
            if (workingQuantity !== undefined) { 
                localVarFormParams.set('workingQuantity', workingQuantity as any);
            }
    
            if (workingSide !== undefined) { 
                localVarFormParams.set('workingSide', workingSide as any);
            }
    
            if (workingStrategyId !== undefined) { 
                localVarFormParams.set('workingStrategyId', workingStrategyId as any);
            }
    
            if (workingStrategyType !== undefined) { 
                localVarFormParams.set('workingStrategyType', workingStrategyType as any);
            }
    
            if (workingTimeInForce !== undefined) { 
                localVarFormParams.set('workingTimeInForce', workingTimeInForce as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
         * @summary New OCO - Deprecated (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {number} [limitStrategyId] 
         * @param {number} [limitStrategyType] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {number} [stopStrategyId] 
         * @param {number} [stopStrategyType] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderOcoV3: async (price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, limitClientOrderId?: string, limitIcebergQty?: string, limitStrategyId?: number, limitStrategyType?: number, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, selfTradePreventionMode?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, stopStrategyId?: number, stopStrategyType?: number, trailingDelta?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('spotCreateOrderOcoV3', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('spotCreateOrderOcoV3', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('spotCreateOrderOcoV3', 'side', side)
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('spotCreateOrderOcoV3', 'stopPrice', stopPrice)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateOrderOcoV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateOrderOcoV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/order/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (limitClientOrderId !== undefined) { 
                localVarFormParams.set('limitClientOrderId', limitClientOrderId as any);
            }
    
            if (limitIcebergQty !== undefined) { 
                localVarFormParams.set('limitIcebergQty', limitIcebergQty as any);
            }
    
            if (limitStrategyId !== undefined) { 
                localVarFormParams.set('limitStrategyId', limitStrategyId as any);
            }
    
            if (limitStrategyType !== undefined) { 
                localVarFormParams.set('limitStrategyType', limitStrategyType as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopClientOrderId !== undefined) { 
                localVarFormParams.set('stopClientOrderId', stopClientOrderId as any);
            }
    
            if (stopIcebergQty !== undefined) { 
                localVarFormParams.set('stopIcebergQty', stopIcebergQty as any);
            }
    
            if (stopLimitPrice !== undefined) { 
                localVarFormParams.set('stopLimitPrice', stopLimitPrice as any);
            }
    
            if (stopLimitTimeInForce !== undefined) { 
                localVarFormParams.set('stopLimitTimeInForce', stopLimitTimeInForce as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (stopStrategyId !== undefined) { 
                localVarFormParams.set('stopStrategyId', stopStrategyId as any);
            }
    
            if (stopStrategyType !== undefined) { 
                localVarFormParams.set('stopStrategyType', stopStrategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (trailingDelta !== undefined) { 
                localVarFormParams.set('trailingDelta', trailingDelta as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [computeCommissionRates] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderTestV3: async (side: string, symbol: string, timestamp: number, type: string, computeCommissionRates?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('spotCreateOrderTestV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateOrderTestV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateOrderTestV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('spotCreateOrderTestV3', 'type', type)
            const localVarPath = `/api/v3/order/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (computeCommissionRates !== undefined) { 
                localVarFormParams.set('computeCommissionRates', computeCommissionRates as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (trailingDelta !== undefined) { 
                localVarFormParams.set('trailingDelta', trailingDelta as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new order.
         * @summary New order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderV3: async (side: string, symbol: string, timestamp: number, type: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('spotCreateOrderV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateOrderV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateOrderV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('spotCreateOrderV3', 'type', type)
            const localVarPath = `/api/v3/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (trailingDelta !== undefined) { 
                localVarFormParams.set('trailingDelta', trailingDelta as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order using SOR (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [computeCommissionRates] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateSorOrderTestV3: async (quantity: string, side: string, symbol: string, timestamp: number, type: string, computeCommissionRates?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, recvWindow?: number, selfTradePreventionMode?: string, strategyId?: number, strategyType?: number, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('spotCreateSorOrderTestV3', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('spotCreateSorOrderTestV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateSorOrderTestV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateSorOrderTestV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('spotCreateSorOrderTestV3', 'type', type)
            const localVarPath = `/api/v3/sor/order/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (computeCommissionRates !== undefined) { 
                localVarFormParams.set('computeCommissionRates', computeCommissionRates as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Places an order using smart order routing (SOR).
         * @summary New order using SOR (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateSorOrderV3: async (quantity: string, side: string, symbol: string, timestamp: number, type: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, recvWindow?: number, selfTradePreventionMode?: string, strategyId?: number, strategyType?: number, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('spotCreateSorOrderV3', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('spotCreateSorOrderV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotCreateSorOrderV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotCreateSorOrderV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('spotCreateSorOrderV3', 'type', type)
            const localVarPath = `/api/v3/sor/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels all active orders on a symbol. This includes orders that are part of an order list.
         * @summary Cancel All Open Orders on a Symbol (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotDeleteOpenOrdersV3: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotDeleteOpenOrdersV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotDeleteOpenOrdersV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an entire Order list
         * @summary Cancel Order list (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotDeleteOrderListV3: async (symbol: string, timestamp: number, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotDeleteOrderListV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotDeleteOrderListV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (listClientOrderId !== undefined) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {string} [cancelRestrictions] Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotDeleteOrderV3: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, cancelRestrictions?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotDeleteOrderV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotDeleteOrderV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (cancelRestrictions !== undefined) {
                localVarQueryParameter['cancelRestrictions'] = cancelRestrictions;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
         * @summary Query all Order lists (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetAllOrderListV3: async (timestamp: number, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotGetAllOrderListV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/allOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetAllOrdersV3: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotGetAllOrdersV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotGetAllOrdersV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Open Order lists (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetOpenOrderListV3: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotGetOpenOrderListV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/openOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
         * @summary Current open orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetOpenOrdersV3: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotGetOpenOrdersV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific order list based on provided optional parameters.
         * @summary Query Order list (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [origClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetOrderListV3: async (timestamp: number, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotGetOrderListV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order\'s status.
         * @summary Query order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetOrderV3: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('spotGetOrderV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('spotGetOrderV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradingApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
         * @summary Cancel an Existing Order and Send a New Order (TRADE)
         * @param {string} cancelReplaceMode 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [cancelNewClientOrderId] 
         * @param {number} [cancelOrderId] 
         * @param {string} [cancelOrigClientOrderId] 
         * @param {string} [cancelRestrictions] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [orderRateLimitExceededMode] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateOrderCancelReplaceV3(cancelReplaceMode: string, side: string, symbol: string, timestamp: number, type: string, cancelNewClientOrderId?: string, cancelOrderId?: number, cancelOrigClientOrderId?: string, cancelRestrictions?: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, orderRateLimitExceededMode?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderCancelReplaceV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateOrderCancelReplaceV3(cancelReplaceMode, side, symbol, timestamp, type, cancelNewClientOrderId, cancelOrderId, cancelOrigClientOrderId, cancelRestrictions, icebergQty, newClientOrderId, newOrderRespType, orderRateLimitExceededMode, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, stopPrice, strategyId, strategyType, timeInForce, trailingDelta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateOrderCancelReplaceV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
         * @summary New Order list - OCO (TRADE)
         * @param {SpotCreateOrderListOcoV3AboveTypeEnum} aboveType 
         * @param {SpotCreateOrderListOcoV3BelowTypeEnum} belowType 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [aboveClientOrderId] 
         * @param {number} [aboveIcebergQty] 
         * @param {string} [abovePrice] 
         * @param {string} [aboveStopPrice] 
         * @param {number} [aboveStrategyId] 
         * @param {number} [aboveStrategyType] 
         * @param {string} [aboveTimeInForce] 
         * @param {number} [aboveTrailingDelta] 
         * @param {string} [belowClientOrderId] 
         * @param {number} [belowIcebergQty] 
         * @param {string} [belowPrice] 
         * @param {string} [belowStopPrice] 
         * @param {number} [belowStrategyId] 
         * @param {number} [belowStrategyType] 
         * @param {string} [belowTimeInForce] 
         * @param {number} [belowTrailingDelta] 
         * @param {string} [listClientOrderId] 
         * @param {SpotCreateOrderListOcoV3NewOrderRespTypeEnum} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateOrderListOcoV3(aboveType: SpotCreateOrderListOcoV3AboveTypeEnum, belowType: SpotCreateOrderListOcoV3BelowTypeEnum, quantity: string, side: string, symbol: string, timestamp: number, aboveClientOrderId?: string, aboveIcebergQty?: number, abovePrice?: string, aboveStopPrice?: string, aboveStrategyId?: number, aboveStrategyType?: number, aboveTimeInForce?: string, aboveTrailingDelta?: number, belowClientOrderId?: string, belowIcebergQty?: number, belowPrice?: string, belowStopPrice?: string, belowStrategyId?: number, belowStrategyType?: number, belowTimeInForce?: string, belowTrailingDelta?: number, listClientOrderId?: string, newOrderRespType?: SpotCreateOrderListOcoV3NewOrderRespTypeEnum, recvWindow?: number, selfTradePreventionMode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderListOcoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateOrderListOcoV3(aboveType, belowType, quantity, side, symbol, timestamp, aboveClientOrderId, aboveIcebergQty, abovePrice, aboveStopPrice, aboveStrategyId, aboveStrategyType, aboveTimeInForce, aboveTrailingDelta, belowClientOrderId, belowIcebergQty, belowPrice, belowStopPrice, belowStrategyId, belowStrategyType, belowTimeInForce, belowTrailingDelta, listClientOrderId, newOrderRespType, recvWindow, selfTradePreventionMode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateOrderListOcoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTO (TRADE)
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} pendingType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {SpotCreateOrderListOtoV3WorkingTypeEnum} workingType 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingClientOrderId] 
         * @param {string} [pendingIcebergQty] 
         * @param {string} [pendingPrice] 
         * @param {string} [pendingStopPrice] 
         * @param {number} [pendingStrategyId] 
         * @param {number} [pendingStrategyType] 
         * @param {string} [pendingTimeInForce] 
         * @param {string} [pendingTrailingDelta] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {number} [workingStrategyId] 
         * @param {number} [workingStrategyType] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateOrderListOtoV3(pendingQuantity: string, pendingSide: string, pendingType: string, symbol: string, timestamp: number, workingPrice: string, workingQuantity: string, workingSide: string, workingType: SpotCreateOrderListOtoV3WorkingTypeEnum, listClientOrderId?: string, newOrderRespType?: string, pendingClientOrderId?: string, pendingIcebergQty?: string, pendingPrice?: string, pendingStopPrice?: string, pendingStrategyId?: number, pendingStrategyType?: number, pendingTimeInForce?: string, pendingTrailingDelta?: string, recvWindow?: number, selfTradePreventionMode?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingStrategyId?: number, workingStrategyType?: number, workingTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderListOtoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateOrderListOtoV3(pendingQuantity, pendingSide, pendingType, symbol, timestamp, workingPrice, workingQuantity, workingSide, workingType, listClientOrderId, newOrderRespType, pendingClientOrderId, pendingIcebergQty, pendingPrice, pendingStopPrice, pendingStrategyId, pendingStrategyType, pendingTimeInForce, pendingTrailingDelta, recvWindow, selfTradePreventionMode, workingClientOrderId, workingIcebergQty, workingStrategyId, workingStrategyType, workingTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateOrderListOtoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTOCO (TRADE)
         * @param {SpotCreateOrderListOtocoV3PendingAboveTypeEnum} pendingAboveType 
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {SpotCreateOrderListOtocoV3WorkingTypeEnum} workingType 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingAboveClientOrderId] 
         * @param {string} [pendingAboveIcebergQty] 
         * @param {string} [pendingAbovePrice] 
         * @param {string} [pendingAboveStopPrice] 
         * @param {number} [pendingAboveStrategyId] 
         * @param {number} [pendingAboveStrategyType] 
         * @param {string} [pendingAboveTimeInForce] 
         * @param {string} [pendingAboveTrailingDelta] 
         * @param {string} [pendingBelowClientOrderId] 
         * @param {string} [pendingBelowIcebergQty] 
         * @param {string} [pendingBelowPrice] 
         * @param {string} [pendingBelowStopPrice] 
         * @param {number} [pendingBelowStrategyId] 
         * @param {number} [pendingBelowStrategyType] 
         * @param {string} [pendingBelowTimeInForce] 
         * @param {string} [pendingBelowTrailingDelta] 
         * @param {SpotCreateOrderListOtocoV3PendingBelowTypeEnum} [pendingBelowType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {number} [workingStrategyId] 
         * @param {number} [workingStrategyType] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateOrderListOtocoV3(pendingAboveType: SpotCreateOrderListOtocoV3PendingAboveTypeEnum, pendingQuantity: string, pendingSide: string, symbol: string, timestamp: number, workingPrice: string, workingQuantity: string, workingSide: string, workingType: SpotCreateOrderListOtocoV3WorkingTypeEnum, listClientOrderId?: string, newOrderRespType?: string, pendingAboveClientOrderId?: string, pendingAboveIcebergQty?: string, pendingAbovePrice?: string, pendingAboveStopPrice?: string, pendingAboveStrategyId?: number, pendingAboveStrategyType?: number, pendingAboveTimeInForce?: string, pendingAboveTrailingDelta?: string, pendingBelowClientOrderId?: string, pendingBelowIcebergQty?: string, pendingBelowPrice?: string, pendingBelowStopPrice?: string, pendingBelowStrategyId?: number, pendingBelowStrategyType?: number, pendingBelowTimeInForce?: string, pendingBelowTrailingDelta?: string, pendingBelowType?: SpotCreateOrderListOtocoV3PendingBelowTypeEnum, recvWindow?: number, selfTradePreventionMode?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingStrategyId?: number, workingStrategyType?: number, workingTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderListOtocoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateOrderListOtocoV3(pendingAboveType, pendingQuantity, pendingSide, symbol, timestamp, workingPrice, workingQuantity, workingSide, workingType, listClientOrderId, newOrderRespType, pendingAboveClientOrderId, pendingAboveIcebergQty, pendingAbovePrice, pendingAboveStopPrice, pendingAboveStrategyId, pendingAboveStrategyType, pendingAboveTimeInForce, pendingAboveTrailingDelta, pendingBelowClientOrderId, pendingBelowIcebergQty, pendingBelowPrice, pendingBelowStopPrice, pendingBelowStrategyId, pendingBelowStrategyType, pendingBelowTimeInForce, pendingBelowTrailingDelta, pendingBelowType, recvWindow, selfTradePreventionMode, workingClientOrderId, workingIcebergQty, workingStrategyId, workingStrategyType, workingTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateOrderListOtocoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
         * @summary New OCO - Deprecated (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {number} [limitStrategyId] 
         * @param {number} [limitStrategyType] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {number} [stopStrategyId] 
         * @param {number} [stopStrategyType] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateOrderOcoV3(price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, limitClientOrderId?: string, limitIcebergQty?: string, limitStrategyId?: number, limitStrategyType?: number, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, selfTradePreventionMode?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, stopStrategyId?: number, stopStrategyType?: number, trailingDelta?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderOcoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateOrderOcoV3(price, quantity, side, stopPrice, symbol, timestamp, limitClientOrderId, limitIcebergQty, limitStrategyId, limitStrategyType, listClientOrderId, newOrderRespType, recvWindow, selfTradePreventionMode, stopClientOrderId, stopIcebergQty, stopLimitPrice, stopLimitTimeInForce, stopStrategyId, stopStrategyType, trailingDelta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateOrderOcoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [computeCommissionRates] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateOrderTestV3(side: string, symbol: string, timestamp: number, type: string, computeCommissionRates?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderTestV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateOrderTestV3(side, symbol, timestamp, type, computeCommissionRates, icebergQty, newClientOrderId, newOrderRespType, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, stopPrice, strategyId, strategyType, timeInForce, trailingDelta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateOrderTestV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new order.
         * @summary New order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateOrderV3(side: string, symbol: string, timestamp: number, type: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateOrderV3(side, symbol, timestamp, type, icebergQty, newClientOrderId, newOrderRespType, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, stopPrice, strategyId, strategyType, timeInForce, trailingDelta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order using SOR (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [computeCommissionRates] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateSorOrderTestV3(quantity: string, side: string, symbol: string, timestamp: number, type: string, computeCommissionRates?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, recvWindow?: number, selfTradePreventionMode?: string, strategyId?: number, strategyType?: number, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateSorOrderTestV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateSorOrderTestV3(quantity, side, symbol, timestamp, type, computeCommissionRates, icebergQty, newClientOrderId, newOrderRespType, price, recvWindow, selfTradePreventionMode, strategyId, strategyType, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateSorOrderTestV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Places an order using smart order routing (SOR).
         * @summary New order using SOR (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotCreateSorOrderV3(quantity: string, side: string, symbol: string, timestamp: number, type: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, recvWindow?: number, selfTradePreventionMode?: string, strategyId?: number, strategyType?: number, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateSorOrderV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotCreateSorOrderV3(quantity, side, symbol, timestamp, type, icebergQty, newClientOrderId, newOrderRespType, price, recvWindow, selfTradePreventionMode, strategyId, strategyType, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotCreateSorOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancels all active orders on a symbol. This includes orders that are part of an order list.
         * @summary Cancel All Open Orders on a Symbol (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotDeleteOpenOrdersV3(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<SpotDeleteOpenOrdersV3RespInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotDeleteOpenOrdersV3(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotDeleteOpenOrdersV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an entire Order list
         * @summary Cancel Order list (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotDeleteOrderListV3(symbol: string, timestamp: number, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotDeleteOrderListV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotDeleteOrderListV3(symbol, timestamp, orderListId, listClientOrderId, newClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotDeleteOrderListV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {string} [cancelRestrictions] Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotDeleteOrderV3(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, cancelRestrictions?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotDeleteOrderV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotDeleteOrderV3(symbol, timestamp, orderId, origClientOrderId, newClientOrderId, cancelRestrictions, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotDeleteOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
         * @summary Query all Order lists (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotGetAllOrderListV3(timestamp: number, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpotGetAllOrderListV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotGetAllOrderListV3(timestamp, fromId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotGetAllOrderListV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotGetAllOrdersV3(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpotGetAllOrdersV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotGetAllOrdersV3(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotGetAllOrdersV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query Open Order lists (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotGetOpenOrderListV3(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpotGetOpenOrderListV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotGetOpenOrderListV3(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotGetOpenOrderListV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
         * @summary Current open orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotGetOpenOrdersV3(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpotGetOpenOrdersV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotGetOpenOrdersV3(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotGetOpenOrdersV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific order list based on provided optional parameters.
         * @summary Query Order list (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [origClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotGetOrderListV3(timestamp: number, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotGetOrderListV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotGetOrderListV3(timestamp, orderListId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotGetOrderListV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order\'s status.
         * @summary Query order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotGetOrderV3(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotGetOrderV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotGetOrderV3(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradingApi.spotGetOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradingApiFp(configuration)
    return {
        /**
         * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
         * @summary Cancel an Existing Order and Send a New Order (TRADE)
         * @param {TradingApiSpotCreateOrderCancelReplaceV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderCancelReplaceV3(requestParameters: TradingApiSpotCreateOrderCancelReplaceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderCancelReplaceV3Resp> {
            return localVarFp.spotCreateOrderCancelReplaceV3(requestParameters.cancelReplaceMode, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.cancelNewClientOrderId, requestParameters.cancelOrderId, requestParameters.cancelOrigClientOrderId, requestParameters.cancelRestrictions, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.orderRateLimitExceededMode, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
         * @summary New Order list - OCO (TRADE)
         * @param {TradingApiSpotCreateOrderListOcoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderListOcoV3(requestParameters: TradingApiSpotCreateOrderListOcoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderListOcoV3Resp> {
            return localVarFp.spotCreateOrderListOcoV3(requestParameters.aboveType, requestParameters.belowType, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.aboveClientOrderId, requestParameters.aboveIcebergQty, requestParameters.abovePrice, requestParameters.aboveStopPrice, requestParameters.aboveStrategyId, requestParameters.aboveStrategyType, requestParameters.aboveTimeInForce, requestParameters.aboveTrailingDelta, requestParameters.belowClientOrderId, requestParameters.belowIcebergQty, requestParameters.belowPrice, requestParameters.belowStopPrice, requestParameters.belowStrategyId, requestParameters.belowStrategyType, requestParameters.belowTimeInForce, requestParameters.belowTrailingDelta, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTO (TRADE)
         * @param {TradingApiSpotCreateOrderListOtoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderListOtoV3(requestParameters: TradingApiSpotCreateOrderListOtoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderListOtoV3Resp> {
            return localVarFp.spotCreateOrderListOtoV3(requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.pendingType, requestParameters.symbol, requestParameters.timestamp, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingClientOrderId, requestParameters.pendingIcebergQty, requestParameters.pendingPrice, requestParameters.pendingStopPrice, requestParameters.pendingStrategyId, requestParameters.pendingStrategyType, requestParameters.pendingTimeInForce, requestParameters.pendingTrailingDelta, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingStrategyId, requestParameters.workingStrategyType, requestParameters.workingTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTOCO (TRADE)
         * @param {TradingApiSpotCreateOrderListOtocoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderListOtocoV3(requestParameters: TradingApiSpotCreateOrderListOtocoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderListOtocoV3Resp> {
            return localVarFp.spotCreateOrderListOtocoV3(requestParameters.pendingAboveType, requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.symbol, requestParameters.timestamp, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingAboveClientOrderId, requestParameters.pendingAboveIcebergQty, requestParameters.pendingAbovePrice, requestParameters.pendingAboveStopPrice, requestParameters.pendingAboveStrategyId, requestParameters.pendingAboveStrategyType, requestParameters.pendingAboveTimeInForce, requestParameters.pendingAboveTrailingDelta, requestParameters.pendingBelowClientOrderId, requestParameters.pendingBelowIcebergQty, requestParameters.pendingBelowPrice, requestParameters.pendingBelowStopPrice, requestParameters.pendingBelowStrategyId, requestParameters.pendingBelowStrategyType, requestParameters.pendingBelowTimeInForce, requestParameters.pendingBelowTrailingDelta, requestParameters.pendingBelowType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingStrategyId, requestParameters.workingStrategyType, requestParameters.workingTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
         * @summary New OCO - Deprecated (TRADE)
         * @param {TradingApiSpotCreateOrderOcoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderOcoV3(requestParameters: TradingApiSpotCreateOrderOcoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderOcoV3Resp> {
            return localVarFp.spotCreateOrderOcoV3(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.limitStrategyId, requestParameters.limitStrategyType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, requestParameters.stopStrategyId, requestParameters.stopStrategyType, requestParameters.trailingDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order (TRADE)
         * @param {TradingApiSpotCreateOrderTestV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderTestV3(requestParameters: TradingApiSpotCreateOrderTestV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderTestV3Resp> {
            return localVarFp.spotCreateOrderTestV3(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.computeCommissionRates, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new order.
         * @summary New order (TRADE)
         * @param {TradingApiSpotCreateOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateOrderV3(requestParameters: TradingApiSpotCreateOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderV3Resp> {
            return localVarFp.spotCreateOrderV3(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order using SOR (TRADE)
         * @param {TradingApiSpotCreateSorOrderTestV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateSorOrderTestV3(requestParameters: TradingApiSpotCreateSorOrderTestV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateSorOrderTestV3Resp> {
            return localVarFp.spotCreateSorOrderTestV3(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.computeCommissionRates, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Places an order using smart order routing (SOR).
         * @summary New order using SOR (TRADE)
         * @param {TradingApiSpotCreateSorOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotCreateSorOrderV3(requestParameters: TradingApiSpotCreateSorOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateSorOrderV3Resp> {
            return localVarFp.spotCreateSorOrderV3(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels all active orders on a symbol. This includes orders that are part of an order list.
         * @summary Cancel All Open Orders on a Symbol (TRADE)
         * @param {TradingApiSpotDeleteOpenOrdersV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotDeleteOpenOrdersV3(requestParameters: TradingApiSpotDeleteOpenOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<SpotDeleteOpenOrdersV3RespInner>>> {
            return localVarFp.spotDeleteOpenOrdersV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an entire Order list
         * @summary Cancel Order list (TRADE)
         * @param {TradingApiSpotDeleteOrderListV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotDeleteOrderListV3(requestParameters: TradingApiSpotDeleteOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotDeleteOrderListV3Resp> {
            return localVarFp.spotDeleteOrderListV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel order (TRADE)
         * @param {TradingApiSpotDeleteOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotDeleteOrderV3(requestParameters: TradingApiSpotDeleteOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotDeleteOrderV3Resp> {
            return localVarFp.spotDeleteOrderV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.cancelRestrictions, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
         * @summary Query all Order lists (USER_DATA)
         * @param {TradingApiSpotGetAllOrderListV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetAllOrderListV3(requestParameters: TradingApiSpotGetAllOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetAllOrderListV3RespItem>> {
            return localVarFp.spotGetAllOrderListV3(requestParameters.timestamp, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All orders (USER_DATA)
         * @param {TradingApiSpotGetAllOrdersV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetAllOrdersV3(requestParameters: TradingApiSpotGetAllOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetAllOrdersV3RespItem>> {
            return localVarFp.spotGetAllOrdersV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Open Order lists (USER_DATA)
         * @param {TradingApiSpotGetOpenOrderListV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetOpenOrderListV3(requestParameters: TradingApiSpotGetOpenOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetOpenOrderListV3RespItem>> {
            return localVarFp.spotGetOpenOrderListV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
         * @summary Current open orders (USER_DATA)
         * @param {TradingApiSpotGetOpenOrdersV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetOpenOrdersV3(requestParameters: TradingApiSpotGetOpenOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetOpenOrdersV3RespItem>> {
            return localVarFp.spotGetOpenOrdersV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific order list based on provided optional parameters.
         * @summary Query Order list (USER_DATA)
         * @param {TradingApiSpotGetOrderListV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetOrderListV3(requestParameters: TradingApiSpotGetOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetOrderListV3Resp> {
            return localVarFp.spotGetOrderListV3(requestParameters.timestamp, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order\'s status.
         * @summary Query order (USER_DATA)
         * @param {TradingApiSpotGetOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotGetOrderV3(requestParameters: TradingApiSpotGetOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetOrderV3Resp> {
            return localVarFp.spotGetOrderV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradingApi - interface
 * @export
 * @interface TradingApi
 */
export interface TradingApiInterface {
    /**
     * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
     * @summary Cancel an Existing Order and Send a New Order (TRADE)
     * @param {TradingApiSpotCreateOrderCancelReplaceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateOrderCancelReplaceV3(requestParameters: TradingApiSpotCreateOrderCancelReplaceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderCancelReplaceV3Resp>;

    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
     * @summary New Order list - OCO (TRADE)
     * @param {TradingApiSpotCreateOrderListOcoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateOrderListOcoV3(requestParameters: TradingApiSpotCreateOrderListOcoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderListOcoV3Resp>;

    /**
     * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
     * @summary New Order list - OTO (TRADE)
     * @param {TradingApiSpotCreateOrderListOtoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateOrderListOtoV3(requestParameters: TradingApiSpotCreateOrderListOtoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderListOtoV3Resp>;

    /**
     * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
     * @summary New Order list - OTOCO (TRADE)
     * @param {TradingApiSpotCreateOrderListOtocoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateOrderListOtocoV3(requestParameters: TradingApiSpotCreateOrderListOtocoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderListOtocoV3Resp>;

    /**
     * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
     * @summary New OCO - Deprecated (TRADE)
     * @param {TradingApiSpotCreateOrderOcoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateOrderOcoV3(requestParameters: TradingApiSpotCreateOrderOcoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderOcoV3Resp>;

    /**
     * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order (TRADE)
     * @param {TradingApiSpotCreateOrderTestV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateOrderTestV3(requestParameters: TradingApiSpotCreateOrderTestV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderTestV3Resp>;

    /**
     * Send in a new order.
     * @summary New order (TRADE)
     * @param {TradingApiSpotCreateOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateOrderV3(requestParameters: TradingApiSpotCreateOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderV3Resp>;

    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order using SOR (TRADE)
     * @param {TradingApiSpotCreateSorOrderTestV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateSorOrderTestV3(requestParameters: TradingApiSpotCreateSorOrderTestV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateSorOrderTestV3Resp>;

    /**
     * Places an order using smart order routing (SOR).
     * @summary New order using SOR (TRADE)
     * @param {TradingApiSpotCreateSorOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotCreateSorOrderV3(requestParameters: TradingApiSpotCreateSorOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateSorOrderV3Resp>;

    /**
     * Cancels all active orders on a symbol. This includes orders that are part of an order list.
     * @summary Cancel All Open Orders on a Symbol (TRADE)
     * @param {TradingApiSpotDeleteOpenOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotDeleteOpenOrdersV3(requestParameters: TradingApiSpotDeleteOpenOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<SpotDeleteOpenOrdersV3RespInner>>>;

    /**
     * Cancel an entire Order list
     * @summary Cancel Order list (TRADE)
     * @param {TradingApiSpotDeleteOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotDeleteOrderListV3(requestParameters: TradingApiSpotDeleteOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotDeleteOrderListV3Resp>;

    /**
     * Cancel an active order.
     * @summary Cancel order (TRADE)
     * @param {TradingApiSpotDeleteOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotDeleteOrderV3(requestParameters: TradingApiSpotDeleteOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotDeleteOrderV3Resp>;

    /**
     * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
     * @summary Query all Order lists (USER_DATA)
     * @param {TradingApiSpotGetAllOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotGetAllOrderListV3(requestParameters: TradingApiSpotGetAllOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetAllOrderListV3RespItem>>;

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All orders (USER_DATA)
     * @param {TradingApiSpotGetAllOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotGetAllOrdersV3(requestParameters: TradingApiSpotGetAllOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetAllOrdersV3RespItem>>;

    /**
     * 
     * @summary Query Open Order lists (USER_DATA)
     * @param {TradingApiSpotGetOpenOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotGetOpenOrderListV3(requestParameters: TradingApiSpotGetOpenOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetOpenOrderListV3RespItem>>;

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
     * @summary Current open orders (USER_DATA)
     * @param {TradingApiSpotGetOpenOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotGetOpenOrdersV3(requestParameters: TradingApiSpotGetOpenOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetOpenOrdersV3RespItem>>;

    /**
     * Retrieves a specific order list based on provided optional parameters.
     * @summary Query Order list (USER_DATA)
     * @param {TradingApiSpotGetOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotGetOrderListV3(requestParameters: TradingApiSpotGetOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetOrderListV3Resp>;

    /**
     * Check an order\'s status.
     * @summary Query order (USER_DATA)
     * @param {TradingApiSpotGetOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiInterface
     */
    spotGetOrderV3(requestParameters: TradingApiSpotGetOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetOrderV3Resp>;

}

/**
 * Request parameters for spotCreateOrderCancelReplaceV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateOrderCancelReplaceV3Request
 */
export interface TradingApiSpotCreateOrderCancelReplaceV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly cancelReplaceMode: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly cancelNewClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly cancelOrderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly cancelOrigClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly cancelRestrictions?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly orderRateLimitExceededMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderCancelReplaceV3
     */
    readonly trailingDelta?: number
}

/**
 * Request parameters for spotCreateOrderListOcoV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateOrderListOcoV3Request
 */
export interface TradingApiSpotCreateOrderListOcoV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly aboveType: SpotCreateOrderListOcoV3AboveTypeEnum

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowType: SpotCreateOrderListOcoV3BelowTypeEnum

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly aboveClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly aboveIcebergQty?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly abovePrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly aboveStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly aboveStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly aboveStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly aboveTimeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly aboveTrailingDelta?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowIcebergQty?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowTimeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly belowTrailingDelta?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly newOrderRespType?: SpotCreateOrderListOcoV3NewOrderRespTypeEnum

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOcoV3
     */
    readonly selfTradePreventionMode?: string
}

/**
 * Request parameters for spotCreateOrderListOtoV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateOrderListOtoV3Request
 */
export interface TradingApiSpotCreateOrderListOtoV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingSide: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingType: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingPrice: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingSide: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingType: SpotCreateOrderListOtoV3WorkingTypeEnum

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly pendingTrailingDelta?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingIcebergQty?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtoV3
     */
    readonly workingTimeInForce?: string
}

/**
 * Request parameters for spotCreateOrderListOtocoV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateOrderListOtocoV3Request
 */
export interface TradingApiSpotCreateOrderListOtocoV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAboveType: SpotCreateOrderListOtocoV3PendingAboveTypeEnum

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingSide: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingPrice: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingSide: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingType: SpotCreateOrderListOtocoV3WorkingTypeEnum

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAboveClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAboveIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAbovePrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAboveStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAboveStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAboveStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAboveTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingAboveTrailingDelta?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowTrailingDelta?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly pendingBelowType?: SpotCreateOrderListOtocoV3PendingBelowTypeEnum

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingIcebergQty?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderListOtocoV3
     */
    readonly workingTimeInForce?: string
}

/**
 * Request parameters for spotCreateOrderOcoV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateOrderOcoV3Request
 */
export interface TradingApiSpotCreateOrderOcoV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly stopPrice: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly limitClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly limitIcebergQty?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly limitStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly limitStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly stopClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly stopIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly stopLimitPrice?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly stopLimitTimeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly stopStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly stopStrategyType?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderOcoV3
     */
    readonly trailingDelta?: number
}

/**
 * Request parameters for spotCreateOrderTestV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateOrderTestV3Request
 */
export interface TradingApiSpotCreateOrderTestV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly type: string

    /**
     * 
     * @type {boolean}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly computeCommissionRates?: boolean

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderTestV3
     */
    readonly trailingDelta?: number
}

/**
 * Request parameters for spotCreateOrderV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateOrderV3Request
 */
export interface TradingApiSpotCreateOrderV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateOrderV3
     */
    readonly trailingDelta?: number
}

/**
 * Request parameters for spotCreateSorOrderTestV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateSorOrderTestV3Request
 */
export interface TradingApiSpotCreateSorOrderTestV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly type: string

    /**
     * 
     * @type {boolean}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly computeCommissionRates?: boolean

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly price?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderTestV3
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for spotCreateSorOrderV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotCreateSorOrderV3Request
 */
export interface TradingApiSpotCreateSorOrderV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly price?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotCreateSorOrderV3
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for spotDeleteOpenOrdersV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotDeleteOpenOrdersV3Request
 */
export interface TradingApiSpotDeleteOpenOrdersV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotDeleteOpenOrdersV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotDeleteOpenOrdersV3
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradingApiSpotDeleteOpenOrdersV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for spotDeleteOrderListV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotDeleteOrderListV3Request
 */
export interface TradingApiSpotDeleteOrderListV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotDeleteOrderListV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotDeleteOrderListV3
     */
    readonly timestamp: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {number}
     * @memberof TradingApiSpotDeleteOrderListV3
     */
    readonly orderListId?: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {string}
     * @memberof TradingApiSpotDeleteOrderListV3
     */
    readonly listClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradingApiSpotDeleteOrderListV3
     */
    readonly newClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradingApiSpotDeleteOrderListV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for spotDeleteOrderV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotDeleteOrderV3Request
 */
export interface TradingApiSpotDeleteOrderV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotDeleteOrderV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotDeleteOrderV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotDeleteOrderV3
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotDeleteOrderV3
     */
    readonly origClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default.
     * @type {string}
     * @memberof TradingApiSpotDeleteOrderV3
     */
    readonly newClientOrderId?: string

    /**
     * Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
     * @type {string}
     * @memberof TradingApiSpotDeleteOrderV3
     */
    readonly cancelRestrictions?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;.
     * @type {number}
     * @memberof TradingApiSpotDeleteOrderV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for spotGetAllOrderListV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotGetAllOrderListV3Request
 */
export interface TradingApiSpotGetAllOrderListV3Request {
    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetAllOrderListV3
     */
    readonly timestamp: number

    /**
     * If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
     * @type {number}
     * @memberof TradingApiSpotGetAllOrderListV3
     */
    readonly fromId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetAllOrderListV3
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetAllOrderListV3
     */
    readonly endTime?: number

    /**
     * Default Value: 500; Max Value: 1000
     * @type {number}
     * @memberof TradingApiSpotGetAllOrderListV3
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradingApiSpotGetAllOrderListV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for spotGetAllOrdersV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotGetAllOrdersV3Request
 */
export interface TradingApiSpotGetAllOrdersV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotGetAllOrdersV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetAllOrdersV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetAllOrdersV3
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetAllOrdersV3
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetAllOrdersV3
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradingApiSpotGetAllOrdersV3
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradingApiSpotGetAllOrdersV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for spotGetOpenOrderListV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotGetOpenOrderListV3Request
 */
export interface TradingApiSpotGetOpenOrderListV3Request {
    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetOpenOrderListV3
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradingApiSpotGetOpenOrderListV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for spotGetOpenOrdersV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotGetOpenOrdersV3Request
 */
export interface TradingApiSpotGetOpenOrdersV3Request {
    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetOpenOrdersV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotGetOpenOrdersV3
     */
    readonly symbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradingApiSpotGetOpenOrdersV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for spotGetOrderListV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotGetOrderListV3Request
 */
export interface TradingApiSpotGetOrderListV3Request {
    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetOrderListV3
     */
    readonly timestamp: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {number}
     * @memberof TradingApiSpotGetOrderListV3
     */
    readonly orderListId?: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {string}
     * @memberof TradingApiSpotGetOrderListV3
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradingApiSpotGetOrderListV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for spotGetOrderV3 operation in TradingApi.
 * @export
 * @interface TradingApiSpotGetOrderV3Request
 */
export interface TradingApiSpotGetOrderV3Request {
    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotGetOrderV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetOrderV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof TradingApiSpotGetOrderV3
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof TradingApiSpotGetOrderV3
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof TradingApiSpotGetOrderV3
     */
    readonly recvWindow?: number
}

/**
 * TradingApi - object-oriented interface
 * @export
 * @class TradingApi
 * @extends {BaseAPI}
 */
export class TradingApi extends BaseAPI implements TradingApiInterface {
    /**
     * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
     * @summary Cancel an Existing Order and Send a New Order (TRADE)
     * @param {TradingApiSpotCreateOrderCancelReplaceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateOrderCancelReplaceV3(requestParameters: TradingApiSpotCreateOrderCancelReplaceV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateOrderCancelReplaceV3(requestParameters.cancelReplaceMode, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.cancelNewClientOrderId, requestParameters.cancelOrderId, requestParameters.cancelOrigClientOrderId, requestParameters.cancelRestrictions, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.orderRateLimitExceededMode, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
     * @summary New Order list - OCO (TRADE)
     * @param {TradingApiSpotCreateOrderListOcoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateOrderListOcoV3(requestParameters: TradingApiSpotCreateOrderListOcoV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateOrderListOcoV3(requestParameters.aboveType, requestParameters.belowType, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.aboveClientOrderId, requestParameters.aboveIcebergQty, requestParameters.abovePrice, requestParameters.aboveStopPrice, requestParameters.aboveStrategyId, requestParameters.aboveStrategyType, requestParameters.aboveTimeInForce, requestParameters.aboveTrailingDelta, requestParameters.belowClientOrderId, requestParameters.belowIcebergQty, requestParameters.belowPrice, requestParameters.belowStopPrice, requestParameters.belowStrategyId, requestParameters.belowStrategyType, requestParameters.belowTimeInForce, requestParameters.belowTrailingDelta, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
     * @summary New Order list - OTO (TRADE)
     * @param {TradingApiSpotCreateOrderListOtoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateOrderListOtoV3(requestParameters: TradingApiSpotCreateOrderListOtoV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateOrderListOtoV3(requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.pendingType, requestParameters.symbol, requestParameters.timestamp, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingClientOrderId, requestParameters.pendingIcebergQty, requestParameters.pendingPrice, requestParameters.pendingStopPrice, requestParameters.pendingStrategyId, requestParameters.pendingStrategyType, requestParameters.pendingTimeInForce, requestParameters.pendingTrailingDelta, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingStrategyId, requestParameters.workingStrategyType, requestParameters.workingTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
     * @summary New Order list - OTOCO (TRADE)
     * @param {TradingApiSpotCreateOrderListOtocoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateOrderListOtocoV3(requestParameters: TradingApiSpotCreateOrderListOtocoV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateOrderListOtocoV3(requestParameters.pendingAboveType, requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.symbol, requestParameters.timestamp, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingAboveClientOrderId, requestParameters.pendingAboveIcebergQty, requestParameters.pendingAbovePrice, requestParameters.pendingAboveStopPrice, requestParameters.pendingAboveStrategyId, requestParameters.pendingAboveStrategyType, requestParameters.pendingAboveTimeInForce, requestParameters.pendingAboveTrailingDelta, requestParameters.pendingBelowClientOrderId, requestParameters.pendingBelowIcebergQty, requestParameters.pendingBelowPrice, requestParameters.pendingBelowStopPrice, requestParameters.pendingBelowStrategyId, requestParameters.pendingBelowStrategyType, requestParameters.pendingBelowTimeInForce, requestParameters.pendingBelowTrailingDelta, requestParameters.pendingBelowType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingStrategyId, requestParameters.workingStrategyType, requestParameters.workingTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
     * @summary New OCO - Deprecated (TRADE)
     * @param {TradingApiSpotCreateOrderOcoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateOrderOcoV3(requestParameters: TradingApiSpotCreateOrderOcoV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateOrderOcoV3(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.limitStrategyId, requestParameters.limitStrategyType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, requestParameters.stopStrategyId, requestParameters.stopStrategyType, requestParameters.trailingDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order (TRADE)
     * @param {TradingApiSpotCreateOrderTestV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateOrderTestV3(requestParameters: TradingApiSpotCreateOrderTestV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateOrderTestV3(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.computeCommissionRates, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new order.
     * @summary New order (TRADE)
     * @param {TradingApiSpotCreateOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateOrderV3(requestParameters: TradingApiSpotCreateOrderV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateOrderV3(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order using SOR (TRADE)
     * @param {TradingApiSpotCreateSorOrderTestV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateSorOrderTestV3(requestParameters: TradingApiSpotCreateSorOrderTestV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateSorOrderTestV3(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.computeCommissionRates, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Places an order using smart order routing (SOR).
     * @summary New order using SOR (TRADE)
     * @param {TradingApiSpotCreateSorOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotCreateSorOrderV3(requestParameters: TradingApiSpotCreateSorOrderV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotCreateSorOrderV3(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels all active orders on a symbol. This includes orders that are part of an order list.
     * @summary Cancel All Open Orders on a Symbol (TRADE)
     * @param {TradingApiSpotDeleteOpenOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotDeleteOpenOrdersV3(requestParameters: TradingApiSpotDeleteOpenOrdersV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotDeleteOpenOrdersV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an entire Order list
     * @summary Cancel Order list (TRADE)
     * @param {TradingApiSpotDeleteOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotDeleteOrderListV3(requestParameters: TradingApiSpotDeleteOrderListV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotDeleteOrderListV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel order (TRADE)
     * @param {TradingApiSpotDeleteOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotDeleteOrderV3(requestParameters: TradingApiSpotDeleteOrderV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotDeleteOrderV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.cancelRestrictions, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
     * @summary Query all Order lists (USER_DATA)
     * @param {TradingApiSpotGetAllOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotGetAllOrderListV3(requestParameters: TradingApiSpotGetAllOrderListV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotGetAllOrderListV3(requestParameters.timestamp, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All orders (USER_DATA)
     * @param {TradingApiSpotGetAllOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotGetAllOrdersV3(requestParameters: TradingApiSpotGetAllOrdersV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotGetAllOrdersV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Open Order lists (USER_DATA)
     * @param {TradingApiSpotGetOpenOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotGetOpenOrderListV3(requestParameters: TradingApiSpotGetOpenOrderListV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotGetOpenOrderListV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
     * @summary Current open orders (USER_DATA)
     * @param {TradingApiSpotGetOpenOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotGetOpenOrdersV3(requestParameters: TradingApiSpotGetOpenOrdersV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotGetOpenOrdersV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific order list based on provided optional parameters.
     * @summary Query Order list (USER_DATA)
     * @param {TradingApiSpotGetOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotGetOrderListV3(requestParameters: TradingApiSpotGetOrderListV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotGetOrderListV3(requestParameters.timestamp, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order\'s status.
     * @summary Query order (USER_DATA)
     * @param {TradingApiSpotGetOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public spotGetOrderV3(requestParameters: TradingApiSpotGetOrderV3Request, options?: RawAxiosRequestConfig) {
        return TradingApiFp(this.configuration).spotGetOrderV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SpotCreateOrderListOcoV3AboveTypeEnum = {
    StopLossLimit: 'STOP_LOSS_LIMIT',
    StopLoss: 'STOP_LOSS',
    LimitMaker: 'LIMIT_MAKER',
    TakeProfit: 'TAKE_PROFIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT'
} as const;
export type SpotCreateOrderListOcoV3AboveTypeEnum = typeof SpotCreateOrderListOcoV3AboveTypeEnum[keyof typeof SpotCreateOrderListOcoV3AboveTypeEnum];
/**
 * @export
 */
export const SpotCreateOrderListOcoV3BelowTypeEnum = {
    StopLoss: 'STOP_LOSS',
    StopLossLimit: 'STOP_LOSS_LIMIT',
    TakeProfit: 'TAKE_PROFIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT'
} as const;
export type SpotCreateOrderListOcoV3BelowTypeEnum = typeof SpotCreateOrderListOcoV3BelowTypeEnum[keyof typeof SpotCreateOrderListOcoV3BelowTypeEnum];
/**
 * @export
 */
export const SpotCreateOrderListOcoV3NewOrderRespTypeEnum = {
    Ack: 'ACK',
    Result: 'RESULT',
    Full: 'FULL'
} as const;
export type SpotCreateOrderListOcoV3NewOrderRespTypeEnum = typeof SpotCreateOrderListOcoV3NewOrderRespTypeEnum[keyof typeof SpotCreateOrderListOcoV3NewOrderRespTypeEnum];
/**
 * @export
 */
export const SpotCreateOrderListOtoV3WorkingTypeEnum = {
    Limit: 'LIMIT',
    LimitMaker: 'LIMIT_MAKER'
} as const;
export type SpotCreateOrderListOtoV3WorkingTypeEnum = typeof SpotCreateOrderListOtoV3WorkingTypeEnum[keyof typeof SpotCreateOrderListOtoV3WorkingTypeEnum];
/**
 * @export
 */
export const SpotCreateOrderListOtocoV3PendingAboveTypeEnum = {
    StopLossLimit: 'STOP_LOSS_LIMIT',
    StopLoss: 'STOP_LOSS',
    LimitMaker: 'LIMIT_MAKER',
    TakeProfit: 'TAKE_PROFIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT'
} as const;
export type SpotCreateOrderListOtocoV3PendingAboveTypeEnum = typeof SpotCreateOrderListOtocoV3PendingAboveTypeEnum[keyof typeof SpotCreateOrderListOtocoV3PendingAboveTypeEnum];
/**
 * @export
 */
export const SpotCreateOrderListOtocoV3WorkingTypeEnum = {
    Limit: 'LIMIT',
    LimitMaker: 'LIMIT_MAKER'
} as const;
export type SpotCreateOrderListOtocoV3WorkingTypeEnum = typeof SpotCreateOrderListOtocoV3WorkingTypeEnum[keyof typeof SpotCreateOrderListOtocoV3WorkingTypeEnum];
/**
 * @export
 */
export const SpotCreateOrderListOtocoV3PendingBelowTypeEnum = {
    StopLoss: 'STOP_LOSS',
    StopLossLimit: 'STOP_LOSS_LIMIT',
    TakeProfit: 'TAKE_PROFIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT'
} as const;
export type SpotCreateOrderListOtocoV3PendingBelowTypeEnum = typeof SpotCreateOrderListOtocoV3PendingBelowTypeEnum[keyof typeof SpotCreateOrderListOtocoV3PendingBelowTypeEnum];
