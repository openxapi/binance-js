/* tslint:disable */
/* eslint-disable */
/**
 * Binance Spot API
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CreateOrderListOcoV3Resp } from '../model';
// @ts-ignore
import type { CreateOrderListOtoV3Resp } from '../model';
// @ts-ignore
import type { CreateOrderListOtocoV3Resp } from '../model';
// @ts-ignore
import type { CreateOrderOcoV3Resp } from '../model';
// @ts-ignore
import type { CreateSorOrderV3Resp } from '../model';
// @ts-ignore
import type { CreateUserDataStreamV3Resp } from '../model';
// @ts-ignore
import type { DeleteOrderListV3Resp } from '../model';
// @ts-ignore
import type { DeleteOrderV3Resp } from '../model';
// @ts-ignore
import type { GetAccountCommissionV3Resp } from '../model';
// @ts-ignore
import type { GetAccountV3Resp } from '../model';
// @ts-ignore
import type { GetAllOrderListV3RespItem } from '../model';
// @ts-ignore
import type { GetAllOrdersV3RespItem } from '../model';
// @ts-ignore
import type { GetAvgPriceV3Resp } from '../model';
// @ts-ignore
import type { GetDepthV3Resp } from '../model';
// @ts-ignore
import type { GetHistoricalTradesV3RespItem } from '../model';
// @ts-ignore
import type { GetKlinesV3200ResponseInnerInner } from '../model';
// @ts-ignore
import type { GetMyAllocationsV3RespItem } from '../model';
// @ts-ignore
import type { GetMyPreventedMatchesV3RespItem } from '../model';
// @ts-ignore
import type { GetMyTradesV3RespItem } from '../model';
// @ts-ignore
import type { GetOpenOrderListV3RespItem } from '../model';
// @ts-ignore
import type { GetOpenOrdersV3RespItem } from '../model';
// @ts-ignore
import type { GetOrderListV3Resp } from '../model';
// @ts-ignore
import type { GetOrderV3Resp } from '../model';
// @ts-ignore
import type { GetRateLimitOrderV3RespItem } from '../model';
// @ts-ignore
import type { GetTimeV3Resp } from '../model';
// @ts-ignore
import type { GetTradesV3RespItem } from '../model';
// @ts-ignore
import type { SpotCreateOrderCancelReplaceV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateOrderTestV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateOrderV3Resp } from '../model';
// @ts-ignore
import type { SpotCreateSorOrderTestV3Resp } from '../model';
// @ts-ignore
import type { SpotDeleteOpenOrdersV3RespInner } from '../model';
// @ts-ignore
import type { SpotGetAggTradesV3RespItem } from '../model';
// @ts-ignore
import type { SpotGetExchangeInfoV3Resp } from '../model';
// @ts-ignore
import type { SpotGetTicker24hrV3Resp } from '../model';
// @ts-ignore
import type { SpotGetTickerBookTickerV3Resp } from '../model';
// @ts-ignore
import type { SpotGetTickerPriceV3Resp } from '../model';
// @ts-ignore
import type { SpotGetTickerTradingDayV3Resp } from '../model';
// @ts-ignore
import type { SpotGetTickerV3Resp } from '../model';
/**
 * SpotTradingApi - axios parameter creator
 * @export
 */
export const SpotTradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
         * @summary Cancel an Existing Order and Send a New Order (TRADE)
         * @param {string} cancelReplaceMode 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [cancelNewClientOrderId] 
         * @param {number} [cancelOrderId] 
         * @param {string} [cancelOrigClientOrderId] 
         * @param {string} [cancelRestrictions] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [orderRateLimitExceededMode] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderCancelReplaceV3: async (cancelReplaceMode: string, side: string, symbol: string, timestamp: number, type: string, cancelNewClientOrderId?: string, cancelOrderId?: number, cancelOrigClientOrderId?: string, cancelRestrictions?: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, orderRateLimitExceededMode?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelReplaceMode' is not null or undefined
            assertParamExists('createOrderCancelReplaceV3', 'cancelReplaceMode', cancelReplaceMode)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderCancelReplaceV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderCancelReplaceV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderCancelReplaceV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderCancelReplaceV3', 'type', type)
            const localVarPath = `/api/v3/order/cancelReplace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (cancelNewClientOrderId !== undefined) { 
                localVarFormParams.set('cancelNewClientOrderId', cancelNewClientOrderId as any);
            }
    
            if (cancelOrderId !== undefined) { 
                localVarFormParams.set('cancelOrderId', cancelOrderId as any);
            }
    
            if (cancelOrigClientOrderId !== undefined) { 
                localVarFormParams.set('cancelOrigClientOrderId', cancelOrigClientOrderId as any);
            }
    
            if (cancelReplaceMode !== undefined) { 
                localVarFormParams.set('cancelReplaceMode', cancelReplaceMode as any);
            }
    
            if (cancelRestrictions !== undefined) { 
                localVarFormParams.set('cancelRestrictions', cancelRestrictions as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (orderRateLimitExceededMode !== undefined) { 
                localVarFormParams.set('orderRateLimitExceededMode', orderRateLimitExceededMode as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (trailingDelta !== undefined) { 
                localVarFormParams.set('trailingDelta', trailingDelta as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
         * @summary New Order list - OCO (TRADE)
         * @param {CreateOrderListOcoV3AboveTypeEnum} aboveType 
         * @param {CreateOrderListOcoV3BelowTypeEnum} belowType 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [aboveClientOrderId] 
         * @param {number} [aboveIcebergQty] 
         * @param {string} [abovePrice] 
         * @param {string} [aboveStopPrice] 
         * @param {number} [aboveStrategyId] 
         * @param {number} [aboveStrategyType] 
         * @param {string} [aboveTimeInForce] 
         * @param {number} [aboveTrailingDelta] 
         * @param {string} [belowClientOrderId] 
         * @param {number} [belowIcebergQty] 
         * @param {string} [belowPrice] 
         * @param {string} [belowStopPrice] 
         * @param {number} [belowStrategyId] 
         * @param {number} [belowStrategyType] 
         * @param {string} [belowTimeInForce] 
         * @param {number} [belowTrailingDelta] 
         * @param {string} [listClientOrderId] 
         * @param {CreateOrderListOcoV3NewOrderRespTypeEnum} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderListOcoV3: async (aboveType: CreateOrderListOcoV3AboveTypeEnum, belowType: CreateOrderListOcoV3BelowTypeEnum, quantity: string, side: string, symbol: string, timestamp: number, aboveClientOrderId?: string, aboveIcebergQty?: number, abovePrice?: string, aboveStopPrice?: string, aboveStrategyId?: number, aboveStrategyType?: number, aboveTimeInForce?: string, aboveTrailingDelta?: number, belowClientOrderId?: string, belowIcebergQty?: number, belowPrice?: string, belowStopPrice?: string, belowStrategyId?: number, belowStrategyType?: number, belowTimeInForce?: string, belowTrailingDelta?: number, listClientOrderId?: string, newOrderRespType?: CreateOrderListOcoV3NewOrderRespTypeEnum, recvWindow?: number, selfTradePreventionMode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aboveType' is not null or undefined
            assertParamExists('createOrderListOcoV3', 'aboveType', aboveType)
            // verify required parameter 'belowType' is not null or undefined
            assertParamExists('createOrderListOcoV3', 'belowType', belowType)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('createOrderListOcoV3', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderListOcoV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderListOcoV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderListOcoV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/orderList/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (aboveClientOrderId !== undefined) { 
                localVarFormParams.set('aboveClientOrderId', aboveClientOrderId as any);
            }
    
            if (aboveIcebergQty !== undefined) { 
                localVarFormParams.set('aboveIcebergQty', aboveIcebergQty as any);
            }
    
            if (abovePrice !== undefined) { 
                localVarFormParams.set('abovePrice', abovePrice as any);
            }
    
            if (aboveStopPrice !== undefined) { 
                localVarFormParams.set('aboveStopPrice', aboveStopPrice as any);
            }
    
            if (aboveStrategyId !== undefined) { 
                localVarFormParams.set('aboveStrategyId', aboveStrategyId as any);
            }
    
            if (aboveStrategyType !== undefined) { 
                localVarFormParams.set('aboveStrategyType', aboveStrategyType as any);
            }
    
            if (aboveTimeInForce !== undefined) { 
                localVarFormParams.set('aboveTimeInForce', aboveTimeInForce as any);
            }
    
            if (aboveTrailingDelta !== undefined) { 
                localVarFormParams.set('aboveTrailingDelta', aboveTrailingDelta as any);
            }
    
            if (aboveType !== undefined) { 
                localVarFormParams.set('aboveType', aboveType as any);
            }
    
            if (belowClientOrderId !== undefined) { 
                localVarFormParams.set('belowClientOrderId', belowClientOrderId as any);
            }
    
            if (belowIcebergQty !== undefined) { 
                localVarFormParams.set('belowIcebergQty', belowIcebergQty as any);
            }
    
            if (belowPrice !== undefined) { 
                localVarFormParams.set('belowPrice', belowPrice as any);
            }
    
            if (belowStopPrice !== undefined) { 
                localVarFormParams.set('belowStopPrice', belowStopPrice as any);
            }
    
            if (belowStrategyId !== undefined) { 
                localVarFormParams.set('belowStrategyId', belowStrategyId as any);
            }
    
            if (belowStrategyType !== undefined) { 
                localVarFormParams.set('belowStrategyType', belowStrategyType as any);
            }
    
            if (belowTimeInForce !== undefined) { 
                localVarFormParams.set('belowTimeInForce', belowTimeInForce as any);
            }
    
            if (belowTrailingDelta !== undefined) { 
                localVarFormParams.set('belowTrailingDelta', belowTrailingDelta as any);
            }
    
            if (belowType !== undefined) { 
                localVarFormParams.set('belowType', belowType as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTO (TRADE)
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} pendingType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {CreateOrderListOtoV3WorkingTypeEnum} workingType 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingClientOrderId] 
         * @param {string} [pendingIcebergQty] 
         * @param {string} [pendingPrice] 
         * @param {string} [pendingStopPrice] 
         * @param {number} [pendingStrategyId] 
         * @param {number} [pendingStrategyType] 
         * @param {string} [pendingTimeInForce] 
         * @param {string} [pendingTrailingDelta] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {number} [workingStrategyId] 
         * @param {number} [workingStrategyType] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderListOtoV3: async (pendingQuantity: string, pendingSide: string, pendingType: string, symbol: string, timestamp: number, workingPrice: string, workingQuantity: string, workingSide: string, workingType: CreateOrderListOtoV3WorkingTypeEnum, listClientOrderId?: string, newOrderRespType?: string, pendingClientOrderId?: string, pendingIcebergQty?: string, pendingPrice?: string, pendingStopPrice?: string, pendingStrategyId?: number, pendingStrategyType?: number, pendingTimeInForce?: string, pendingTrailingDelta?: string, recvWindow?: number, selfTradePreventionMode?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingStrategyId?: number, workingStrategyType?: number, workingTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'pendingQuantity', pendingQuantity)
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'pendingSide', pendingSide)
            // verify required parameter 'pendingType' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'pendingType', pendingType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'timestamp', timestamp)
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'workingPrice', workingPrice)
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'workingQuantity', workingQuantity)
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'workingSide', workingSide)
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('createOrderListOtoV3', 'workingType', workingType)
            const localVarPath = `/api/v3/orderList/oto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (pendingClientOrderId !== undefined) { 
                localVarFormParams.set('pendingClientOrderId', pendingClientOrderId as any);
            }
    
            if (pendingIcebergQty !== undefined) { 
                localVarFormParams.set('pendingIcebergQty', pendingIcebergQty as any);
            }
    
            if (pendingPrice !== undefined) { 
                localVarFormParams.set('pendingPrice', pendingPrice as any);
            }
    
            if (pendingQuantity !== undefined) { 
                localVarFormParams.set('pendingQuantity', pendingQuantity as any);
            }
    
            if (pendingSide !== undefined) { 
                localVarFormParams.set('pendingSide', pendingSide as any);
            }
    
            if (pendingStopPrice !== undefined) { 
                localVarFormParams.set('pendingStopPrice', pendingStopPrice as any);
            }
    
            if (pendingStrategyId !== undefined) { 
                localVarFormParams.set('pendingStrategyId', pendingStrategyId as any);
            }
    
            if (pendingStrategyType !== undefined) { 
                localVarFormParams.set('pendingStrategyType', pendingStrategyType as any);
            }
    
            if (pendingTimeInForce !== undefined) { 
                localVarFormParams.set('pendingTimeInForce', pendingTimeInForce as any);
            }
    
            if (pendingTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingTrailingDelta', pendingTrailingDelta as any);
            }
    
            if (pendingType !== undefined) { 
                localVarFormParams.set('pendingType', pendingType as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (workingClientOrderId !== undefined) { 
                localVarFormParams.set('workingClientOrderId', workingClientOrderId as any);
            }
    
            if (workingIcebergQty !== undefined) { 
                localVarFormParams.set('workingIcebergQty', workingIcebergQty as any);
            }
    
            if (workingPrice !== undefined) { 
                localVarFormParams.set('workingPrice', workingPrice as any);
            }
    
            if (workingQuantity !== undefined) { 
                localVarFormParams.set('workingQuantity', workingQuantity as any);
            }
    
            if (workingSide !== undefined) { 
                localVarFormParams.set('workingSide', workingSide as any);
            }
    
            if (workingStrategyId !== undefined) { 
                localVarFormParams.set('workingStrategyId', workingStrategyId as any);
            }
    
            if (workingStrategyType !== undefined) { 
                localVarFormParams.set('workingStrategyType', workingStrategyType as any);
            }
    
            if (workingTimeInForce !== undefined) { 
                localVarFormParams.set('workingTimeInForce', workingTimeInForce as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTOCO (TRADE)
         * @param {CreateOrderListOtocoV3PendingAboveTypeEnum} pendingAboveType 
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {CreateOrderListOtocoV3WorkingTypeEnum} workingType 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingAboveClientOrderId] 
         * @param {string} [pendingAboveIcebergQty] 
         * @param {string} [pendingAbovePrice] 
         * @param {string} [pendingAboveStopPrice] 
         * @param {number} [pendingAboveStrategyId] 
         * @param {number} [pendingAboveStrategyType] 
         * @param {string} [pendingAboveTimeInForce] 
         * @param {string} [pendingAboveTrailingDelta] 
         * @param {string} [pendingBelowClientOrderId] 
         * @param {string} [pendingBelowIcebergQty] 
         * @param {string} [pendingBelowPrice] 
         * @param {string} [pendingBelowStopPrice] 
         * @param {number} [pendingBelowStrategyId] 
         * @param {number} [pendingBelowStrategyType] 
         * @param {string} [pendingBelowTimeInForce] 
         * @param {string} [pendingBelowTrailingDelta] 
         * @param {CreateOrderListOtocoV3PendingBelowTypeEnum} [pendingBelowType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {number} [workingStrategyId] 
         * @param {number} [workingStrategyType] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderListOtocoV3: async (pendingAboveType: CreateOrderListOtocoV3PendingAboveTypeEnum, pendingQuantity: string, pendingSide: string, symbol: string, timestamp: number, workingPrice: string, workingQuantity: string, workingSide: string, workingType: CreateOrderListOtocoV3WorkingTypeEnum, listClientOrderId?: string, newOrderRespType?: string, pendingAboveClientOrderId?: string, pendingAboveIcebergQty?: string, pendingAbovePrice?: string, pendingAboveStopPrice?: string, pendingAboveStrategyId?: number, pendingAboveStrategyType?: number, pendingAboveTimeInForce?: string, pendingAboveTrailingDelta?: string, pendingBelowClientOrderId?: string, pendingBelowIcebergQty?: string, pendingBelowPrice?: string, pendingBelowStopPrice?: string, pendingBelowStrategyId?: number, pendingBelowStrategyType?: number, pendingBelowTimeInForce?: string, pendingBelowTrailingDelta?: string, pendingBelowType?: CreateOrderListOtocoV3PendingBelowTypeEnum, recvWindow?: number, selfTradePreventionMode?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingStrategyId?: number, workingStrategyType?: number, workingTimeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingAboveType' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'pendingAboveType', pendingAboveType)
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'pendingQuantity', pendingQuantity)
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'pendingSide', pendingSide)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'timestamp', timestamp)
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'workingPrice', workingPrice)
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'workingQuantity', workingQuantity)
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'workingSide', workingSide)
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('createOrderListOtocoV3', 'workingType', workingType)
            const localVarPath = `/api/v3/orderList/otoco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (pendingAboveClientOrderId !== undefined) { 
                localVarFormParams.set('pendingAboveClientOrderId', pendingAboveClientOrderId as any);
            }
    
            if (pendingAboveIcebergQty !== undefined) { 
                localVarFormParams.set('pendingAboveIcebergQty', pendingAboveIcebergQty as any);
            }
    
            if (pendingAbovePrice !== undefined) { 
                localVarFormParams.set('pendingAbovePrice', pendingAbovePrice as any);
            }
    
            if (pendingAboveStopPrice !== undefined) { 
                localVarFormParams.set('pendingAboveStopPrice', pendingAboveStopPrice as any);
            }
    
            if (pendingAboveStrategyId !== undefined) { 
                localVarFormParams.set('pendingAboveStrategyId', pendingAboveStrategyId as any);
            }
    
            if (pendingAboveStrategyType !== undefined) { 
                localVarFormParams.set('pendingAboveStrategyType', pendingAboveStrategyType as any);
            }
    
            if (pendingAboveTimeInForce !== undefined) { 
                localVarFormParams.set('pendingAboveTimeInForce', pendingAboveTimeInForce as any);
            }
    
            if (pendingAboveTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingAboveTrailingDelta', pendingAboveTrailingDelta as any);
            }
    
            if (pendingAboveType !== undefined) { 
                localVarFormParams.set('pendingAboveType', pendingAboveType as any);
            }
    
            if (pendingBelowClientOrderId !== undefined) { 
                localVarFormParams.set('pendingBelowClientOrderId', pendingBelowClientOrderId as any);
            }
    
            if (pendingBelowIcebergQty !== undefined) { 
                localVarFormParams.set('pendingBelowIcebergQty', pendingBelowIcebergQty as any);
            }
    
            if (pendingBelowPrice !== undefined) { 
                localVarFormParams.set('pendingBelowPrice', pendingBelowPrice as any);
            }
    
            if (pendingBelowStopPrice !== undefined) { 
                localVarFormParams.set('pendingBelowStopPrice', pendingBelowStopPrice as any);
            }
    
            if (pendingBelowStrategyId !== undefined) { 
                localVarFormParams.set('pendingBelowStrategyId', pendingBelowStrategyId as any);
            }
    
            if (pendingBelowStrategyType !== undefined) { 
                localVarFormParams.set('pendingBelowStrategyType', pendingBelowStrategyType as any);
            }
    
            if (pendingBelowTimeInForce !== undefined) { 
                localVarFormParams.set('pendingBelowTimeInForce', pendingBelowTimeInForce as any);
            }
    
            if (pendingBelowTrailingDelta !== undefined) { 
                localVarFormParams.set('pendingBelowTrailingDelta', pendingBelowTrailingDelta as any);
            }
    
            if (pendingBelowType !== undefined) { 
                localVarFormParams.set('pendingBelowType', pendingBelowType as any);
            }
    
            if (pendingQuantity !== undefined) { 
                localVarFormParams.set('pendingQuantity', pendingQuantity as any);
            }
    
            if (pendingSide !== undefined) { 
                localVarFormParams.set('pendingSide', pendingSide as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (workingClientOrderId !== undefined) { 
                localVarFormParams.set('workingClientOrderId', workingClientOrderId as any);
            }
    
            if (workingIcebergQty !== undefined) { 
                localVarFormParams.set('workingIcebergQty', workingIcebergQty as any);
            }
    
            if (workingPrice !== undefined) { 
                localVarFormParams.set('workingPrice', workingPrice as any);
            }
    
            if (workingQuantity !== undefined) { 
                localVarFormParams.set('workingQuantity', workingQuantity as any);
            }
    
            if (workingSide !== undefined) { 
                localVarFormParams.set('workingSide', workingSide as any);
            }
    
            if (workingStrategyId !== undefined) { 
                localVarFormParams.set('workingStrategyId', workingStrategyId as any);
            }
    
            if (workingStrategyType !== undefined) { 
                localVarFormParams.set('workingStrategyType', workingStrategyType as any);
            }
    
            if (workingTimeInForce !== undefined) { 
                localVarFormParams.set('workingTimeInForce', workingTimeInForce as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
         * @summary New OCO - Deprecated (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {number} [limitStrategyId] 
         * @param {number} [limitStrategyType] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {number} [stopStrategyId] 
         * @param {number} [stopStrategyType] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderOcoV3: async (price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, limitClientOrderId?: string, limitIcebergQty?: string, limitStrategyId?: number, limitStrategyType?: number, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, selfTradePreventionMode?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, stopStrategyId?: number, stopStrategyType?: number, trailingDelta?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('createOrderOcoV3', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('createOrderOcoV3', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderOcoV3', 'side', side)
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('createOrderOcoV3', 'stopPrice', stopPrice)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderOcoV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderOcoV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/order/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (limitClientOrderId !== undefined) { 
                localVarFormParams.set('limitClientOrderId', limitClientOrderId as any);
            }
    
            if (limitIcebergQty !== undefined) { 
                localVarFormParams.set('limitIcebergQty', limitIcebergQty as any);
            }
    
            if (limitStrategyId !== undefined) { 
                localVarFormParams.set('limitStrategyId', limitStrategyId as any);
            }
    
            if (limitStrategyType !== undefined) { 
                localVarFormParams.set('limitStrategyType', limitStrategyType as any);
            }
    
            if (listClientOrderId !== undefined) { 
                localVarFormParams.set('listClientOrderId', listClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopClientOrderId !== undefined) { 
                localVarFormParams.set('stopClientOrderId', stopClientOrderId as any);
            }
    
            if (stopIcebergQty !== undefined) { 
                localVarFormParams.set('stopIcebergQty', stopIcebergQty as any);
            }
    
            if (stopLimitPrice !== undefined) { 
                localVarFormParams.set('stopLimitPrice', stopLimitPrice as any);
            }
    
            if (stopLimitTimeInForce !== undefined) { 
                localVarFormParams.set('stopLimitTimeInForce', stopLimitTimeInForce as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (stopStrategyId !== undefined) { 
                localVarFormParams.set('stopStrategyId', stopStrategyId as any);
            }
    
            if (stopStrategyType !== undefined) { 
                localVarFormParams.set('stopStrategyType', stopStrategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (trailingDelta !== undefined) { 
                localVarFormParams.set('trailingDelta', trailingDelta as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [computeCommissionRates] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderTestV3: async (side: string, symbol: string, timestamp: number, type: string, computeCommissionRates?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderTestV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderTestV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderTestV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderTestV3', 'type', type)
            const localVarPath = `/api/v3/order/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (computeCommissionRates !== undefined) { 
                localVarFormParams.set('computeCommissionRates', computeCommissionRates as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (trailingDelta !== undefined) { 
                localVarFormParams.set('trailingDelta', trailingDelta as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new order.
         * @summary New order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV3: async (side: string, symbol: string, timestamp: number, type: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderV3', 'type', type)
            const localVarPath = `/api/v3/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (quoteOrderQty !== undefined) { 
                localVarFormParams.set('quoteOrderQty', quoteOrderQty as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (trailingDelta !== undefined) { 
                localVarFormParams.set('trailingDelta', trailingDelta as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order using SOR (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [computeCommissionRates] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSorOrderTestV3: async (quantity: string, side: string, symbol: string, timestamp: number, type: string, computeCommissionRates?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, recvWindow?: number, selfTradePreventionMode?: string, strategyId?: number, strategyType?: number, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('createSorOrderTestV3', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createSorOrderTestV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createSorOrderTestV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createSorOrderTestV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createSorOrderTestV3', 'type', type)
            const localVarPath = `/api/v3/sor/order/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (computeCommissionRates !== undefined) { 
                localVarFormParams.set('computeCommissionRates', computeCommissionRates as any);
            }
    
            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Places an order using smart order routing (SOR).
         * @summary New order using SOR (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSorOrderV3: async (quantity: string, side: string, symbol: string, timestamp: number, type: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, recvWindow?: number, selfTradePreventionMode?: string, strategyId?: number, strategyType?: number, timeInForce?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('createSorOrderV3', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createSorOrderV3', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createSorOrderV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createSorOrderV3', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createSorOrderV3', 'type', type)
            const localVarPath = `/api/v3/sor/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (icebergQty !== undefined) { 
                localVarFormParams.set('icebergQty', icebergQty as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (strategyId !== undefined) { 
                localVarFormParams.set('strategyId', strategyId as any);
            }
    
            if (strategyType !== undefined) { 
                localVarFormParams.set('strategyType', strategyType as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
         * @summary Start user data stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDataStreamV3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/userDataStream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels all active orders on a symbol. This includes orders that are part of an order list.
         * @summary Cancel All Open Orders on a Symbol (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOpenOrdersV3: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOpenOrdersV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteOpenOrdersV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an entire Order list
         * @summary Cancel Order list (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderListV3: async (symbol: string, timestamp: number, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderListV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteOrderListV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (listClientOrderId !== undefined) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {string} [cancelRestrictions] Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV3: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, cancelRestrictions?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteOrderV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (cancelRestrictions !== undefined) {
                localVarQueryParameter['cancelRestrictions'] = cancelRestrictions;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a user data stream.
         * @summary Close user data stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDataStreamV3: async (listenKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listenKey' is not null or undefined
            assertParamExists('deleteUserDataStreamV3', 'listenKey', listenKey)
            const localVarPath = `/api/v3/userDataStream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (listenKey !== undefined) {
                localVarQueryParameter['listenKey'] = listenKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account commission rates.
         * @summary Query Commission Rates (USER_DATA)
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCommissionV3: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAccountCommissionV3', 'symbol', symbol)
            const localVarPath = `/api/v3/account/commission`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information.
         * @summary Account information (USER_DATA)
         * @param {number} timestamp 
         * @param {boolean} [omitZeroBalances] When set to &#x60;true&#x60;, emits only the non-zero balances of an account. &lt;br/&gt;Default value: &#x60;false&#x60;
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV3: async (timestamp: number, omitZeroBalances?: boolean, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (omitZeroBalances !== undefined) {
                localVarQueryParameter['omitZeroBalances'] = omitZeroBalances;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
         * @summary Compressed/Aggregate trades list
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV3: async (symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAggTradesV3', 'symbol', symbol)
            const localVarPath = `/api/v3/aggTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
         * @summary Query all Order lists (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrderListV3: async (timestamp: number, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAllOrderListV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/allOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV3: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAllOrdersV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAllOrdersV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current average price for a symbol.
         * @summary Current average price
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvgPriceV3: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAvgPriceV3', 'symbol', symbol)
            const localVarPath = `/api/v3/avgPrice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Order book
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 5000. &lt;br/&gt; If limit &amp;gt; 5000. then the response will truncate to 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV3: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getDepthV3', 'symbol', symbol)
            const localVarPath = `/api/v3/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange information
         * @param {string} [symbol] Example: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC&lt;/a&gt;&amp;#34;
         * @param {Array<string>} [symbols] Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X  GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BTCUSDT%22,%22BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;[&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBBTC&lt;/a&gt;&amp;#34;]&amp;#39;
         * @param {string} [permissions] Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22,%22LEVERAGED\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;[&amp;#34;MARGIN&amp;#34;,&amp;#34;LEVERAGED&lt;/a&gt;&amp;#34;]&amp;#39;
         * @param {boolean} [showPermissionSets] Controls whether the content of the &#x60;permissionSets&#x60; field is populated or not. Defaults to &#x60;true&#x60;
         * @param {GetExchangeInfoV3SymbolStatusEnum} [symbolStatus] Filters symbols that have this &#x60;tradingStatus&#x60;. Valid values: &#x60;TRADING&#x60;, &#x60;HALT&#x60;, &#x60;BREAK&#x60; &lt;br/&gt; Cannot be used in combination with &#x60;symbols&#x60; or &#x60;symbol&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV3: async (symbol?: string, symbols?: Array<string>, permissions?: string, showPermissionSets?: boolean, symbolStatus?: GetExchangeInfoV3SymbolStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (showPermissionSets !== undefined) {
                localVarQueryParameter['showPermissionSets'] = showPermissionSets;
            }

            if (symbolStatus !== undefined) {
                localVarQueryParameter['symbolStatus'] = symbolStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older trades.
         * @summary Old trade lookup
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV3: async (symbol: string, limit?: number, fromId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getHistoricalTradesV3', 'symbol', symbol)
            const localVarPath = `/api/v3/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV3: async (symbol: string, interval: string, startTime?: number, endTime?: number, timeZone?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getKlinesV3', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getKlinesV3', 'interval', interval)
            const localVarPath = `/api/v3/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (timeZone !== undefined) {
                localVarQueryParameter['timeZone'] = timeZone;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves allocations resulting from SOR order placement.
         * @summary Query Allocations (USER_DATA)
         * @param {string} symbol 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromAllocationId] 
         * @param {number} [limit] Default 500;Max 1000
         * @param {number} [orderId] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;.
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAllocationsV3: async (symbol: string, startTime?: number, endTime?: number, fromAllocationId?: number, limit?: number, orderId?: number, recvWindow?: number, timestamp?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMyAllocationsV3', 'symbol', symbol)
            const localVarPath = `/api/v3/myAllocations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromAllocationId !== undefined) {
                localVarQueryParameter['fromAllocationId'] = fromAllocationId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit
         * @summary Query Prevented Matches (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [preventedMatchId] 
         * @param {number} [orderId] 
         * @param {number} [fromPreventedMatchId] 
         * @param {number} [limit] Default: &#x60;500&#x60;; Max: &#x60;1000&#x60;
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPreventedMatchesV3: async (symbol: string, timestamp: number, preventedMatchId?: number, orderId?: number, fromPreventedMatchId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMyPreventedMatchesV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMyPreventedMatchesV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/myPreventedMatches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (preventedMatchId !== undefined) {
                localVarQueryParameter['preventedMatchId'] = preventedMatchId;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (fromPreventedMatchId !== undefined) {
                localVarQueryParameter['fromPreventedMatchId'] = fromPreventedMatchId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account trade list (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] This can only be used in combination with &#x60;symbol&#x60;.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyTradesV3: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMyTradesV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMyTradesV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/myTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Open Order lists (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderListV3: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrderListV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/openOrderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
         * @summary Current open orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV3: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrdersV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific order list based on provided optional parameters.
         * @summary Query Order list (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [origClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderListV3: async (timestamp: number, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderListV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/orderList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (orderListId !== undefined) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order\'s status.
         * @summary Query order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV3: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderV3', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Displays the user\'s unfilled order count for all intervals.
         * @summary Query Unfilled Order Count (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimitOrderV3: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getRateLimitOrderV3', 'timestamp', timestamp)
            const localVarPath = `/api/v3/rateLimit/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr ticker price change statistics
         * @param {string} [symbol] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {string} [symbols] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {GetTicker24hrV3TypeEnum} [type] Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV3: async (symbol?: string, symbols?: string, type?: GetTicker24hrV3TypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ticker/24hr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol order book ticker
         * @param {string} [symbol] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {string} [symbols] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV3: async (symbol?: string, symbols?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ticker/bookTicker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol price ticker
         * @param {string} [symbol] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {string} [symbols] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV3: async (symbol?: string, symbols?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Trading Day Ticker
         * @param {string} symbol Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
         * @param {string} symbols Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {GetTickerTradingDayV3TypeEnum} [type] Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerTradingDayV3: async (symbol: string, symbols: string, timeZone?: string, type?: GetTickerTradingDayV3TypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTickerTradingDayV3', 'symbol', symbol)
            // verify required parameter 'symbols' is not null or undefined
            assertParamExists('getTickerTradingDayV3', 'symbols', symbols)
            const localVarPath = `/api/v3/ticker/tradingDay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (timeZone !== undefined) {
                localVarQueryParameter['timeZone'] = timeZone;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Rolling window price change statistics
         * @param {string} symbol Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
         * @param {string} symbols Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
         * @param {string} [windowSize] Defaults to &#x60;1d&#x60; if no parameter provided &lt;br/&gt; Supported &#x60;windowSize&#x60; values: &lt;br/&gt; &#x60;1m&#x60;,&#x60;2m&#x60;....&#x60;59m&#x60; for minutes &lt;br/&gt; &#x60;1h&#x60;, &#x60;2h&#x60;....&#x60;23h&#x60; - for hours &lt;br/&gt; &#x60;1d&#x60;...&#x60;7d&#x60; - for days &lt;br/&gt;&lt;br/&gt; Units cannot be combined (e.g. &#x60;1d2h&#x60; is not allowed)
         * @param {GetTickerV3TypeEnum} [type] Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerV3: async (symbol: string, symbols: string, windowSize?: string, type?: GetTickerV3TypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTickerV3', 'symbol', symbol)
            // verify required parameter 'symbols' is not null or undefined
            assertParamExists('getTickerV3', 'symbols', symbols)
            const localVarPath = `/api/v3/ticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (windowSize !== undefined) {
                localVarQueryParameter['windowSize'] = windowSize;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent trades.
         * @summary Recent trades list
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV3: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTradesV3', 'symbol', symbol)
            const localVarPath = `/api/v3/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.
         * @summary UIKlines
         * @param {string} symbol 
         * @param {string} interval See &lt;a href&#x3D;\&quot;/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\&quot;&gt;&#x60;klines&#x60;&lt;/a&gt;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUiKlinesV3: async (symbol: string, interval: string, startTime?: number, endTime?: number, timeZone?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUiKlinesV3', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getUiKlinesV3', 'interval', interval)
            const localVarPath = `/api/v3/uiKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (timeZone !== undefined) {
                localVarQueryParameter['timeZone'] = timeZone;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 30 minutes.
         * @summary Keepalive user data stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDataStreamV3: async (listenKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listenKey' is not null or undefined
            assertParamExists('updateUserDataStreamV3', 'listenKey', listenKey)
            const localVarPath = `/api/v3/userDataStream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (listenKey !== undefined) { 
                localVarFormParams.set('listenKey', listenKey as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpotTradingApi - functional programming interface
 * @export
 */
export const SpotTradingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpotTradingApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
         * @summary Cancel an Existing Order and Send a New Order (TRADE)
         * @param {string} cancelReplaceMode 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [cancelNewClientOrderId] 
         * @param {number} [cancelOrderId] 
         * @param {string} [cancelOrigClientOrderId] 
         * @param {string} [cancelRestrictions] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [orderRateLimitExceededMode] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderCancelReplaceV3(cancelReplaceMode: string, side: string, symbol: string, timestamp: number, type: string, cancelNewClientOrderId?: string, cancelOrderId?: number, cancelOrigClientOrderId?: string, cancelRestrictions?: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, orderRateLimitExceededMode?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderCancelReplaceV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderCancelReplaceV3(cancelReplaceMode, side, symbol, timestamp, type, cancelNewClientOrderId, cancelOrderId, cancelOrigClientOrderId, cancelRestrictions, icebergQty, newClientOrderId, newOrderRespType, orderRateLimitExceededMode, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, stopPrice, strategyId, strategyType, timeInForce, trailingDelta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createOrderCancelReplaceV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
         * @summary New Order list - OCO (TRADE)
         * @param {CreateOrderListOcoV3AboveTypeEnum} aboveType 
         * @param {CreateOrderListOcoV3BelowTypeEnum} belowType 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [aboveClientOrderId] 
         * @param {number} [aboveIcebergQty] 
         * @param {string} [abovePrice] 
         * @param {string} [aboveStopPrice] 
         * @param {number} [aboveStrategyId] 
         * @param {number} [aboveStrategyType] 
         * @param {string} [aboveTimeInForce] 
         * @param {number} [aboveTrailingDelta] 
         * @param {string} [belowClientOrderId] 
         * @param {number} [belowIcebergQty] 
         * @param {string} [belowPrice] 
         * @param {string} [belowStopPrice] 
         * @param {number} [belowStrategyId] 
         * @param {number} [belowStrategyType] 
         * @param {string} [belowTimeInForce] 
         * @param {number} [belowTrailingDelta] 
         * @param {string} [listClientOrderId] 
         * @param {CreateOrderListOcoV3NewOrderRespTypeEnum} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderListOcoV3(aboveType: CreateOrderListOcoV3AboveTypeEnum, belowType: CreateOrderListOcoV3BelowTypeEnum, quantity: string, side: string, symbol: string, timestamp: number, aboveClientOrderId?: string, aboveIcebergQty?: number, abovePrice?: string, aboveStopPrice?: string, aboveStrategyId?: number, aboveStrategyType?: number, aboveTimeInForce?: string, aboveTrailingDelta?: number, belowClientOrderId?: string, belowIcebergQty?: number, belowPrice?: string, belowStopPrice?: string, belowStrategyId?: number, belowStrategyType?: number, belowTimeInForce?: string, belowTrailingDelta?: number, listClientOrderId?: string, newOrderRespType?: CreateOrderListOcoV3NewOrderRespTypeEnum, recvWindow?: number, selfTradePreventionMode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderListOcoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderListOcoV3(aboveType, belowType, quantity, side, symbol, timestamp, aboveClientOrderId, aboveIcebergQty, abovePrice, aboveStopPrice, aboveStrategyId, aboveStrategyType, aboveTimeInForce, aboveTrailingDelta, belowClientOrderId, belowIcebergQty, belowPrice, belowStopPrice, belowStrategyId, belowStrategyType, belowTimeInForce, belowTrailingDelta, listClientOrderId, newOrderRespType, recvWindow, selfTradePreventionMode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createOrderListOcoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTO (TRADE)
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} pendingType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {CreateOrderListOtoV3WorkingTypeEnum} workingType 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingClientOrderId] 
         * @param {string} [pendingIcebergQty] 
         * @param {string} [pendingPrice] 
         * @param {string} [pendingStopPrice] 
         * @param {number} [pendingStrategyId] 
         * @param {number} [pendingStrategyType] 
         * @param {string} [pendingTimeInForce] 
         * @param {string} [pendingTrailingDelta] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {number} [workingStrategyId] 
         * @param {number} [workingStrategyType] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderListOtoV3(pendingQuantity: string, pendingSide: string, pendingType: string, symbol: string, timestamp: number, workingPrice: string, workingQuantity: string, workingSide: string, workingType: CreateOrderListOtoV3WorkingTypeEnum, listClientOrderId?: string, newOrderRespType?: string, pendingClientOrderId?: string, pendingIcebergQty?: string, pendingPrice?: string, pendingStopPrice?: string, pendingStrategyId?: number, pendingStrategyType?: number, pendingTimeInForce?: string, pendingTrailingDelta?: string, recvWindow?: number, selfTradePreventionMode?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingStrategyId?: number, workingStrategyType?: number, workingTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderListOtoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderListOtoV3(pendingQuantity, pendingSide, pendingType, symbol, timestamp, workingPrice, workingQuantity, workingSide, workingType, listClientOrderId, newOrderRespType, pendingClientOrderId, pendingIcebergQty, pendingPrice, pendingStopPrice, pendingStrategyId, pendingStrategyType, pendingTimeInForce, pendingTrailingDelta, recvWindow, selfTradePreventionMode, workingClientOrderId, workingIcebergQty, workingStrategyId, workingStrategyType, workingTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createOrderListOtoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTOCO (TRADE)
         * @param {CreateOrderListOtocoV3PendingAboveTypeEnum} pendingAboveType 
         * @param {string} pendingQuantity 
         * @param {string} pendingSide 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} workingPrice 
         * @param {string} workingQuantity 
         * @param {string} workingSide 
         * @param {CreateOrderListOtocoV3WorkingTypeEnum} workingType 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [pendingAboveClientOrderId] 
         * @param {string} [pendingAboveIcebergQty] 
         * @param {string} [pendingAbovePrice] 
         * @param {string} [pendingAboveStopPrice] 
         * @param {number} [pendingAboveStrategyId] 
         * @param {number} [pendingAboveStrategyType] 
         * @param {string} [pendingAboveTimeInForce] 
         * @param {string} [pendingAboveTrailingDelta] 
         * @param {string} [pendingBelowClientOrderId] 
         * @param {string} [pendingBelowIcebergQty] 
         * @param {string} [pendingBelowPrice] 
         * @param {string} [pendingBelowStopPrice] 
         * @param {number} [pendingBelowStrategyId] 
         * @param {number} [pendingBelowStrategyType] 
         * @param {string} [pendingBelowTimeInForce] 
         * @param {string} [pendingBelowTrailingDelta] 
         * @param {CreateOrderListOtocoV3PendingBelowTypeEnum} [pendingBelowType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [workingClientOrderId] 
         * @param {string} [workingIcebergQty] 
         * @param {number} [workingStrategyId] 
         * @param {number} [workingStrategyType] 
         * @param {string} [workingTimeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderListOtocoV3(pendingAboveType: CreateOrderListOtocoV3PendingAboveTypeEnum, pendingQuantity: string, pendingSide: string, symbol: string, timestamp: number, workingPrice: string, workingQuantity: string, workingSide: string, workingType: CreateOrderListOtocoV3WorkingTypeEnum, listClientOrderId?: string, newOrderRespType?: string, pendingAboveClientOrderId?: string, pendingAboveIcebergQty?: string, pendingAbovePrice?: string, pendingAboveStopPrice?: string, pendingAboveStrategyId?: number, pendingAboveStrategyType?: number, pendingAboveTimeInForce?: string, pendingAboveTrailingDelta?: string, pendingBelowClientOrderId?: string, pendingBelowIcebergQty?: string, pendingBelowPrice?: string, pendingBelowStopPrice?: string, pendingBelowStrategyId?: number, pendingBelowStrategyType?: number, pendingBelowTimeInForce?: string, pendingBelowTrailingDelta?: string, pendingBelowType?: CreateOrderListOtocoV3PendingBelowTypeEnum, recvWindow?: number, selfTradePreventionMode?: string, workingClientOrderId?: string, workingIcebergQty?: string, workingStrategyId?: number, workingStrategyType?: number, workingTimeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderListOtocoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderListOtocoV3(pendingAboveType, pendingQuantity, pendingSide, symbol, timestamp, workingPrice, workingQuantity, workingSide, workingType, listClientOrderId, newOrderRespType, pendingAboveClientOrderId, pendingAboveIcebergQty, pendingAbovePrice, pendingAboveStopPrice, pendingAboveStrategyId, pendingAboveStrategyType, pendingAboveTimeInForce, pendingAboveTrailingDelta, pendingBelowClientOrderId, pendingBelowIcebergQty, pendingBelowPrice, pendingBelowStopPrice, pendingBelowStrategyId, pendingBelowStrategyType, pendingBelowTimeInForce, pendingBelowTrailingDelta, pendingBelowType, recvWindow, selfTradePreventionMode, workingClientOrderId, workingIcebergQty, workingStrategyId, workingStrategyType, workingTimeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createOrderListOtocoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
         * @summary New OCO - Deprecated (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} stopPrice 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} [limitClientOrderId] 
         * @param {string} [limitIcebergQty] 
         * @param {number} [limitStrategyId] 
         * @param {number} [limitStrategyType] 
         * @param {string} [listClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopClientOrderId] 
         * @param {string} [stopIcebergQty] 
         * @param {string} [stopLimitPrice] 
         * @param {string} [stopLimitTimeInForce] 
         * @param {number} [stopStrategyId] 
         * @param {number} [stopStrategyType] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderOcoV3(price: string, quantity: string, side: string, stopPrice: string, symbol: string, timestamp: number, limitClientOrderId?: string, limitIcebergQty?: string, limitStrategyId?: number, limitStrategyType?: number, listClientOrderId?: string, newOrderRespType?: string, recvWindow?: number, selfTradePreventionMode?: string, stopClientOrderId?: string, stopIcebergQty?: string, stopLimitPrice?: string, stopLimitTimeInForce?: string, stopStrategyId?: number, stopStrategyType?: number, trailingDelta?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderOcoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderOcoV3(price, quantity, side, stopPrice, symbol, timestamp, limitClientOrderId, limitIcebergQty, limitStrategyId, limitStrategyType, listClientOrderId, newOrderRespType, recvWindow, selfTradePreventionMode, stopClientOrderId, stopIcebergQty, stopLimitPrice, stopLimitTimeInForce, stopStrategyId, stopStrategyType, trailingDelta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createOrderOcoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [computeCommissionRates] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderTestV3(side: string, symbol: string, timestamp: number, type: string, computeCommissionRates?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderTestV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderTestV3(side, symbol, timestamp, type, computeCommissionRates, icebergQty, newClientOrderId, newOrderRespType, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, stopPrice, strategyId, strategyType, timeInForce, trailingDelta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createOrderTestV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new order.
         * @summary New order (TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {string} [quantity] 
         * @param {string} [quoteOrderQty] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {number} [trailingDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderV3(side: string, symbol: string, timestamp: number, type: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, quantity?: string, quoteOrderQty?: string, recvWindow?: number, selfTradePreventionMode?: string, stopPrice?: string, strategyId?: number, strategyType?: number, timeInForce?: string, trailingDelta?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateOrderV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderV3(side, symbol, timestamp, type, icebergQty, newClientOrderId, newOrderRespType, price, quantity, quoteOrderQty, recvWindow, selfTradePreventionMode, stopPrice, strategyId, strategyType, timeInForce, trailingDelta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order using SOR (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {boolean} [computeCommissionRates] 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSorOrderTestV3(quantity: string, side: string, symbol: string, timestamp: number, type: string, computeCommissionRates?: boolean, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, recvWindow?: number, selfTradePreventionMode?: string, strategyId?: number, strategyType?: number, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotCreateSorOrderTestV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSorOrderTestV3(quantity, side, symbol, timestamp, type, computeCommissionRates, icebergQty, newClientOrderId, newOrderRespType, price, recvWindow, selfTradePreventionMode, strategyId, strategyType, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createSorOrderTestV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Places an order using smart order routing (SOR).
         * @summary New order using SOR (TRADE)
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [icebergQty] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [price] 
         * @param {number} [recvWindow] 
         * @param {string} [selfTradePreventionMode] 
         * @param {number} [strategyId] 
         * @param {number} [strategyType] 
         * @param {string} [timeInForce] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSorOrderV3(quantity: string, side: string, symbol: string, timestamp: number, type: string, icebergQty?: string, newClientOrderId?: string, newOrderRespType?: string, price?: string, recvWindow?: number, selfTradePreventionMode?: string, strategyId?: number, strategyType?: number, timeInForce?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSorOrderV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSorOrderV3(quantity, side, symbol, timestamp, type, icebergQty, newClientOrderId, newOrderRespType, price, recvWindow, selfTradePreventionMode, strategyId, strategyType, timeInForce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createSorOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
         * @summary Start user data stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserDataStreamV3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDataStreamV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserDataStreamV3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.createUserDataStreamV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancels all active orders on a symbol. This includes orders that are part of an order list.
         * @summary Cancel All Open Orders on a Symbol (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOpenOrdersV3(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<SpotDeleteOpenOrdersV3RespInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOpenOrdersV3(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.deleteOpenOrdersV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an entire Order list
         * @summary Cancel Order list (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [listClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrderListV3(symbol: string, timestamp: number, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrderListV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrderListV3(symbol, timestamp, orderListId, listClientOrderId, newClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.deleteOrderListV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {string} [cancelRestrictions] Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrderV3(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, cancelRestrictions?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrderV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrderV3(symbol, timestamp, orderId, origClientOrderId, newClientOrderId, cancelRestrictions, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.deleteOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a user data stream.
         * @summary Close user data stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserDataStreamV3(listenKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserDataStreamV3(listenKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.deleteUserDataStreamV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account commission rates.
         * @summary Query Commission Rates (USER_DATA)
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountCommissionV3(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountCommissionV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountCommissionV3(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getAccountCommissionV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information.
         * @summary Account information (USER_DATA)
         * @param {number} timestamp 
         * @param {boolean} [omitZeroBalances] When set to &#x60;true&#x60;, emits only the non-zero balances of an account. &lt;br/&gt;Default value: &#x60;false&#x60;
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV3(timestamp: number, omitZeroBalances?: boolean, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV3(timestamp, omitZeroBalances, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getAccountV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
         * @summary Compressed/Aggregate trades list
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggTradesV3(symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpotGetAggTradesV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggTradesV3(symbol, fromId, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getAggTradesV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
         * @summary Query all Order lists (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrderListV3(timestamp: number, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllOrderListV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrderListV3(timestamp, fromId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getAllOrderListV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrdersV3(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllOrdersV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrdersV3(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getAllOrdersV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current average price for a symbol.
         * @summary Current average price
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvgPriceV3(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAvgPriceV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvgPriceV3(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getAvgPriceV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Order book
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 5000. &lt;br/&gt; If limit &amp;gt; 5000. then the response will truncate to 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepthV3(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDepthV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepthV3(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getDepthV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange information
         * @param {string} [symbol] Example: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC&lt;/a&gt;&amp;#34;
         * @param {Array<string>} [symbols] Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X  GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BTCUSDT%22,%22BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;[&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBBTC&lt;/a&gt;&amp;#34;]&amp;#39;
         * @param {string} [permissions] Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22,%22LEVERAGED\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;[&amp;#34;MARGIN&amp;#34;,&amp;#34;LEVERAGED&lt;/a&gt;&amp;#34;]&amp;#39;
         * @param {boolean} [showPermissionSets] Controls whether the content of the &#x60;permissionSets&#x60; field is populated or not. Defaults to &#x60;true&#x60;
         * @param {GetExchangeInfoV3SymbolStatusEnum} [symbolStatus] Filters symbols that have this &#x60;tradingStatus&#x60;. Valid values: &#x60;TRADING&#x60;, &#x60;HALT&#x60;, &#x60;BREAK&#x60; &lt;br/&gt; Cannot be used in combination with &#x60;symbols&#x60; or &#x60;symbol&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfoV3(symbol?: string, symbols?: Array<string>, permissions?: string, showPermissionSets?: boolean, symbolStatus?: GetExchangeInfoV3SymbolStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotGetExchangeInfoV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfoV3(symbol, symbols, permissions, showPermissionSets, symbolStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getExchangeInfoV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get older trades.
         * @summary Old trade lookup
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTradesV3(symbol: string, limit?: number, fromId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetHistoricalTradesV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTradesV3(symbol, limit, fromId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getHistoricalTradesV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKlinesV3(symbol: string, interval: string, startTime?: number, endTime?: number, timeZone?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<GetKlinesV3200ResponseInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKlinesV3(symbol, interval, startTime, endTime, timeZone, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getKlinesV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves allocations resulting from SOR order placement.
         * @summary Query Allocations (USER_DATA)
         * @param {string} symbol 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromAllocationId] 
         * @param {number} [limit] Default 500;Max 1000
         * @param {number} [orderId] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;.
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyAllocationsV3(symbol: string, startTime?: number, endTime?: number, fromAllocationId?: number, limit?: number, orderId?: number, recvWindow?: number, timestamp?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMyAllocationsV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyAllocationsV3(symbol, startTime, endTime, fromAllocationId, limit, orderId, recvWindow, timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getMyAllocationsV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit
         * @summary Query Prevented Matches (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [preventedMatchId] 
         * @param {number} [orderId] 
         * @param {number} [fromPreventedMatchId] 
         * @param {number} [limit] Default: &#x60;500&#x60;; Max: &#x60;1000&#x60;
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyPreventedMatchesV3(symbol: string, timestamp: number, preventedMatchId?: number, orderId?: number, fromPreventedMatchId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMyPreventedMatchesV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyPreventedMatchesV3(symbol, timestamp, preventedMatchId, orderId, fromPreventedMatchId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getMyPreventedMatchesV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account trade list (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] This can only be used in combination with &#x60;symbol&#x60;.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyTradesV3(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMyTradesV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyTradesV3(symbol, timestamp, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getMyTradesV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query Open Order lists (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrderListV3(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOpenOrderListV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrderListV3(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getOpenOrderListV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
         * @summary Current open orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrdersV3(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOpenOrdersV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrdersV3(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getOpenOrdersV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific order list based on provided optional parameters.
         * @summary Query Order list (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [orderListId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {string} [origClientOrderId] Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderListV3(timestamp: number, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderListV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderListV3(timestamp, orderListId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getOrderListV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order\'s status.
         * @summary Query order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderV3(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderV3(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingV3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPingV3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getPingV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Displays the user\'s unfilled order count for all intervals.
         * @summary Query Unfilled Order Count (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] The value cannot be greater than &#x60;60000&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimitOrderV3(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRateLimitOrderV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimitOrderV3(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getRateLimitOrderV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr ticker price change statistics
         * @param {string} [symbol] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {string} [symbols] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {GetTicker24hrV3TypeEnum} [type] Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicker24hrV3(symbol?: string, symbols?: string, type?: GetTicker24hrV3TypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotGetTicker24hrV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker24hrV3(symbol, symbols, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getTicker24hrV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol order book ticker
         * @param {string} [symbol] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {string} [symbols] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerBookTickerV3(symbol?: string, symbols?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotGetTickerBookTickerV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerBookTickerV3(symbol, symbols, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getTickerBookTickerV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol price ticker
         * @param {string} [symbol] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {string} [symbols] Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerPriceV3(symbol?: string, symbols?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotGetTickerPriceV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerPriceV3(symbol, symbols, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getTickerPriceV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Trading Day Ticker
         * @param {string} symbol Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
         * @param {string} symbols Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {GetTickerTradingDayV3TypeEnum} [type] Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerTradingDayV3(symbol: string, symbols: string, timeZone?: string, type?: GetTickerTradingDayV3TypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotGetTickerTradingDayV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerTradingDayV3(symbol, symbols, timeZone, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getTickerTradingDayV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Rolling window price change statistics
         * @param {string} symbol Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
         * @param {string} symbols Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
         * @param {string} [windowSize] Defaults to &#x60;1d&#x60; if no parameter provided &lt;br/&gt; Supported &#x60;windowSize&#x60; values: &lt;br/&gt; &#x60;1m&#x60;,&#x60;2m&#x60;....&#x60;59m&#x60; for minutes &lt;br/&gt; &#x60;1h&#x60;, &#x60;2h&#x60;....&#x60;23h&#x60; - for hours &lt;br/&gt; &#x60;1d&#x60;...&#x60;7d&#x60; - for days &lt;br/&gt;&lt;br/&gt; Units cannot be combined (e.g. &#x60;1d2h&#x60; is not allowed)
         * @param {GetTickerV3TypeEnum} [type] Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerV3(symbol: string, symbols: string, windowSize?: string, type?: GetTickerV3TypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotGetTickerV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerV3(symbol, symbols, windowSize, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getTickerV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeV3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTimeV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeV3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getTimeV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent trades.
         * @summary Recent trades list
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradesV3(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTradesV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradesV3(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getTradesV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.
         * @summary UIKlines
         * @param {string} symbol 
         * @param {string} interval See &lt;a href&#x3D;\&quot;/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\&quot;&gt;&#x60;klines&#x60;&lt;/a&gt;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUiKlinesV3(symbol: string, interval: string, startTime?: number, endTime?: number, timeZone?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<GetKlinesV3200ResponseInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUiKlinesV3(symbol, interval, startTime, endTime, timeZone, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.getUiKlinesV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 30 minutes.
         * @summary Keepalive user data stream (USER_STREAM)
         * @param {string} listenKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserDataStreamV3(listenKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserDataStreamV3(listenKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTradingApi.updateUserDataStreamV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SpotTradingApi - factory interface
 * @export
 */
export const SpotTradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpotTradingApiFp(configuration)
    return {
        /**
         * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
         * @summary Cancel an Existing Order and Send a New Order (TRADE)
         * @param {SpotTradingApiCreateOrderCancelReplaceV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderCancelReplaceV3(requestParameters: SpotTradingApiCreateOrderCancelReplaceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderCancelReplaceV3Resp> {
            return localVarFp.createOrderCancelReplaceV3(requestParameters.cancelReplaceMode, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.cancelNewClientOrderId, requestParameters.cancelOrderId, requestParameters.cancelOrigClientOrderId, requestParameters.cancelRestrictions, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.orderRateLimitExceededMode, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
         * @summary New Order list - OCO (TRADE)
         * @param {SpotTradingApiCreateOrderListOcoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderListOcoV3(requestParameters: SpotTradingApiCreateOrderListOcoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderListOcoV3Resp> {
            return localVarFp.createOrderListOcoV3(requestParameters.aboveType, requestParameters.belowType, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.aboveClientOrderId, requestParameters.aboveIcebergQty, requestParameters.abovePrice, requestParameters.aboveStopPrice, requestParameters.aboveStrategyId, requestParameters.aboveStrategyType, requestParameters.aboveTimeInForce, requestParameters.aboveTrailingDelta, requestParameters.belowClientOrderId, requestParameters.belowIcebergQty, requestParameters.belowPrice, requestParameters.belowStopPrice, requestParameters.belowStrategyId, requestParameters.belowStrategyType, requestParameters.belowTimeInForce, requestParameters.belowTrailingDelta, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTO (TRADE)
         * @param {SpotTradingApiCreateOrderListOtoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderListOtoV3(requestParameters: SpotTradingApiCreateOrderListOtoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderListOtoV3Resp> {
            return localVarFp.createOrderListOtoV3(requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.pendingType, requestParameters.symbol, requestParameters.timestamp, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingClientOrderId, requestParameters.pendingIcebergQty, requestParameters.pendingPrice, requestParameters.pendingStopPrice, requestParameters.pendingStrategyId, requestParameters.pendingStrategyType, requestParameters.pendingTimeInForce, requestParameters.pendingTrailingDelta, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingStrategyId, requestParameters.workingStrategyType, requestParameters.workingTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
         * @summary New Order list - OTOCO (TRADE)
         * @param {SpotTradingApiCreateOrderListOtocoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderListOtocoV3(requestParameters: SpotTradingApiCreateOrderListOtocoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderListOtocoV3Resp> {
            return localVarFp.createOrderListOtocoV3(requestParameters.pendingAboveType, requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.symbol, requestParameters.timestamp, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingAboveClientOrderId, requestParameters.pendingAboveIcebergQty, requestParameters.pendingAbovePrice, requestParameters.pendingAboveStopPrice, requestParameters.pendingAboveStrategyId, requestParameters.pendingAboveStrategyType, requestParameters.pendingAboveTimeInForce, requestParameters.pendingAboveTrailingDelta, requestParameters.pendingBelowClientOrderId, requestParameters.pendingBelowIcebergQty, requestParameters.pendingBelowPrice, requestParameters.pendingBelowStopPrice, requestParameters.pendingBelowStrategyId, requestParameters.pendingBelowStrategyType, requestParameters.pendingBelowTimeInForce, requestParameters.pendingBelowTrailingDelta, requestParameters.pendingBelowType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingStrategyId, requestParameters.workingStrategyType, requestParameters.workingTimeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
         * @summary New OCO - Deprecated (TRADE)
         * @param {SpotTradingApiCreateOrderOcoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderOcoV3(requestParameters: SpotTradingApiCreateOrderOcoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderOcoV3Resp> {
            return localVarFp.createOrderOcoV3(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.limitStrategyId, requestParameters.limitStrategyType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, requestParameters.stopStrategyId, requestParameters.stopStrategyType, requestParameters.trailingDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order (TRADE)
         * @param {SpotTradingApiCreateOrderTestV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderTestV3(requestParameters: SpotTradingApiCreateOrderTestV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderTestV3Resp> {
            return localVarFp.createOrderTestV3(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.computeCommissionRates, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new order.
         * @summary New order (TRADE)
         * @param {SpotTradingApiCreateOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV3(requestParameters: SpotTradingApiCreateOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderV3Resp> {
            return localVarFp.createOrderV3(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
         * @summary Test new order using SOR (TRADE)
         * @param {SpotTradingApiCreateSorOrderTestV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSorOrderTestV3(requestParameters: SpotTradingApiCreateSorOrderTestV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateSorOrderTestV3Resp> {
            return localVarFp.createSorOrderTestV3(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.computeCommissionRates, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Places an order using smart order routing (SOR).
         * @summary New order using SOR (TRADE)
         * @param {SpotTradingApiCreateSorOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSorOrderV3(requestParameters: SpotTradingApiCreateSorOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateSorOrderV3Resp> {
            return localVarFp.createSorOrderV3(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
         * @summary Start user data stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDataStreamV3(options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDataStreamV3Resp> {
            return localVarFp.createUserDataStreamV3(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels all active orders on a symbol. This includes orders that are part of an order list.
         * @summary Cancel All Open Orders on a Symbol (TRADE)
         * @param {SpotTradingApiDeleteOpenOrdersV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOpenOrdersV3(requestParameters: SpotTradingApiDeleteOpenOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<SpotDeleteOpenOrdersV3RespInner>>> {
            return localVarFp.deleteOpenOrdersV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an entire Order list
         * @summary Cancel Order list (TRADE)
         * @param {SpotTradingApiDeleteOrderListV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderListV3(requestParameters: SpotTradingApiDeleteOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderListV3Resp> {
            return localVarFp.deleteOrderListV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel order (TRADE)
         * @param {SpotTradingApiDeleteOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV3(requestParameters: SpotTradingApiDeleteOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV3Resp> {
            return localVarFp.deleteOrderV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.cancelRestrictions, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a user data stream.
         * @summary Close user data stream (USER_STREAM)
         * @param {SpotTradingApiDeleteUserDataStreamV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDataStreamV3(requestParameters: SpotTradingApiDeleteUserDataStreamV3Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteUserDataStreamV3(requestParameters.listenKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account commission rates.
         * @summary Query Commission Rates (USER_DATA)
         * @param {SpotTradingApiGetAccountCommissionV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCommissionV3(requestParameters: SpotTradingApiGetAccountCommissionV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountCommissionV3Resp> {
            return localVarFp.getAccountCommissionV3(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information.
         * @summary Account information (USER_DATA)
         * @param {SpotTradingApiGetAccountV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV3(requestParameters: SpotTradingApiGetAccountV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV3Resp> {
            return localVarFp.getAccountV3(requestParameters.timestamp, requestParameters.omitZeroBalances, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
         * @summary Compressed/Aggregate trades list
         * @param {SpotTradingApiGetAggTradesV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV3(requestParameters: SpotTradingApiGetAggTradesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetAggTradesV3RespItem>> {
            return localVarFp.getAggTradesV3(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
         * @summary Query all Order lists (USER_DATA)
         * @param {SpotTradingApiGetAllOrderListV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrderListV3(requestParameters: SpotTradingApiGetAllOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrderListV3RespItem>> {
            return localVarFp.getAllOrderListV3(requestParameters.timestamp, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All orders (USER_DATA)
         * @param {SpotTradingApiGetAllOrdersV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV3(requestParameters: SpotTradingApiGetAllOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV3RespItem>> {
            return localVarFp.getAllOrdersV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Current average price for a symbol.
         * @summary Current average price
         * @param {SpotTradingApiGetAvgPriceV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvgPriceV3(requestParameters: SpotTradingApiGetAvgPriceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAvgPriceV3Resp> {
            return localVarFp.getAvgPriceV3(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Order book
         * @param {SpotTradingApiGetDepthV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV3(requestParameters: SpotTradingApiGetDepthV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV3Resp> {
            return localVarFp.getDepthV3(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange information
         * @param {SpotTradingApiGetExchangeInfoV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV3(requestParameters: SpotTradingApiGetExchangeInfoV3Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetExchangeInfoV3Resp> {
            return localVarFp.getExchangeInfoV3(requestParameters.symbol, requestParameters.symbols, requestParameters.permissions, requestParameters.showPermissionSets, requestParameters.symbolStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Get older trades.
         * @summary Old trade lookup
         * @param {SpotTradingApiGetHistoricalTradesV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV3(requestParameters: SpotTradingApiGetHistoricalTradesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV3RespItem>> {
            return localVarFp.getHistoricalTradesV3(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick data
         * @param {SpotTradingApiGetKlinesV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV3(requestParameters: SpotTradingApiGetKlinesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<GetKlinesV3200ResponseInnerInner>>> {
            return localVarFp.getKlinesV3(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.timeZone, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves allocations resulting from SOR order placement.
         * @summary Query Allocations (USER_DATA)
         * @param {SpotTradingApiGetMyAllocationsV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAllocationsV3(requestParameters: SpotTradingApiGetMyAllocationsV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMyAllocationsV3RespItem>> {
            return localVarFp.getMyAllocationsV3(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.fromAllocationId, requestParameters.limit, requestParameters.orderId, requestParameters.recvWindow, requestParameters.timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit
         * @summary Query Prevented Matches (USER_DATA)
         * @param {SpotTradingApiGetMyPreventedMatchesV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPreventedMatchesV3(requestParameters: SpotTradingApiGetMyPreventedMatchesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMyPreventedMatchesV3RespItem>> {
            return localVarFp.getMyPreventedMatchesV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.preventedMatchId, requestParameters.orderId, requestParameters.fromPreventedMatchId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account trade list (USER_DATA)
         * @param {SpotTradingApiGetMyTradesV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyTradesV3(requestParameters: SpotTradingApiGetMyTradesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMyTradesV3RespItem>> {
            return localVarFp.getMyTradesV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Open Order lists (USER_DATA)
         * @param {SpotTradingApiGetOpenOrderListV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderListV3(requestParameters: SpotTradingApiGetOpenOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrderListV3RespItem>> {
            return localVarFp.getOpenOrderListV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
         * @summary Current open orders (USER_DATA)
         * @param {SpotTradingApiGetOpenOrdersV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV3(requestParameters: SpotTradingApiGetOpenOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV3RespItem>> {
            return localVarFp.getOpenOrdersV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific order list based on provided optional parameters.
         * @summary Query Order list (USER_DATA)
         * @param {SpotTradingApiGetOrderListV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderListV3(requestParameters: SpotTradingApiGetOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderListV3Resp> {
            return localVarFp.getOrderListV3(requestParameters.timestamp, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order\'s status.
         * @summary Query order (USER_DATA)
         * @param {SpotTradingApiGetOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV3(requestParameters: SpotTradingApiGetOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV3Resp> {
            return localVarFp.getOrderV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV3(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPingV3(options).then((request) => request(axios, basePath));
        },
        /**
         * Displays the user\'s unfilled order count for all intervals.
         * @summary Query Unfilled Order Count (USER_DATA)
         * @param {SpotTradingApiGetRateLimitOrderV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimitOrderV3(requestParameters: SpotTradingApiGetRateLimitOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRateLimitOrderV3RespItem>> {
            return localVarFp.getRateLimitOrderV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr ticker price change statistics
         * @param {SpotTradingApiGetTicker24hrV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV3(requestParameters: SpotTradingApiGetTicker24hrV3Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTicker24hrV3Resp> {
            return localVarFp.getTicker24hrV3(requestParameters.symbol, requestParameters.symbols, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol order book ticker
         * @param {SpotTradingApiGetTickerBookTickerV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV3(requestParameters: SpotTradingApiGetTickerBookTickerV3Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTickerBookTickerV3Resp> {
            return localVarFp.getTickerBookTickerV3(requestParameters.symbol, requestParameters.symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol price ticker
         * @param {SpotTradingApiGetTickerPriceV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV3(requestParameters: SpotTradingApiGetTickerPriceV3Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTickerPriceV3Resp> {
            return localVarFp.getTickerPriceV3(requestParameters.symbol, requestParameters.symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Trading Day Ticker
         * @param {SpotTradingApiGetTickerTradingDayV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerTradingDayV3(requestParameters: SpotTradingApiGetTickerTradingDayV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTickerTradingDayV3Resp> {
            return localVarFp.getTickerTradingDayV3(requestParameters.symbol, requestParameters.symbols, requestParameters.timeZone, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Rolling window price change statistics
         * @param {SpotTradingApiGetTickerV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerV3(requestParameters: SpotTradingApiGetTickerV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTickerV3Resp> {
            return localVarFp.getTickerV3(requestParameters.symbol, requestParameters.symbols, requestParameters.windowSize, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check server time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV3(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV3Resp> {
            return localVarFp.getTimeV3(options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent trades.
         * @summary Recent trades list
         * @param {SpotTradingApiGetTradesV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV3(requestParameters: SpotTradingApiGetTradesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV3RespItem>> {
            return localVarFp.getTradesV3(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.
         * @summary UIKlines
         * @param {SpotTradingApiGetUiKlinesV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUiKlinesV3(requestParameters: SpotTradingApiGetUiKlinesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<GetKlinesV3200ResponseInnerInner>>> {
            return localVarFp.getUiKlinesV3(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.timeZone, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 30 minutes.
         * @summary Keepalive user data stream (USER_STREAM)
         * @param {SpotTradingApiUpdateUserDataStreamV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDataStreamV3(requestParameters: SpotTradingApiUpdateUserDataStreamV3Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateUserDataStreamV3(requestParameters.listenKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpotTradingApi - interface
 * @export
 * @interface SpotTradingApi
 */
export interface SpotTradingApiInterface {
    /**
     * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
     * @summary Cancel an Existing Order and Send a New Order (TRADE)
     * @param {SpotTradingApiCreateOrderCancelReplaceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createOrderCancelReplaceV3(requestParameters: SpotTradingApiCreateOrderCancelReplaceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderCancelReplaceV3Resp>;

    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
     * @summary New Order list - OCO (TRADE)
     * @param {SpotTradingApiCreateOrderListOcoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createOrderListOcoV3(requestParameters: SpotTradingApiCreateOrderListOcoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderListOcoV3Resp>;

    /**
     * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
     * @summary New Order list - OTO (TRADE)
     * @param {SpotTradingApiCreateOrderListOtoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createOrderListOtoV3(requestParameters: SpotTradingApiCreateOrderListOtoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderListOtoV3Resp>;

    /**
     * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
     * @summary New Order list - OTOCO (TRADE)
     * @param {SpotTradingApiCreateOrderListOtocoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createOrderListOtocoV3(requestParameters: SpotTradingApiCreateOrderListOtocoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderListOtocoV3Resp>;

    /**
     * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
     * @summary New OCO - Deprecated (TRADE)
     * @param {SpotTradingApiCreateOrderOcoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createOrderOcoV3(requestParameters: SpotTradingApiCreateOrderOcoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderOcoV3Resp>;

    /**
     * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order (TRADE)
     * @param {SpotTradingApiCreateOrderTestV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createOrderTestV3(requestParameters: SpotTradingApiCreateOrderTestV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderTestV3Resp>;

    /**
     * Send in a new order.
     * @summary New order (TRADE)
     * @param {SpotTradingApiCreateOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createOrderV3(requestParameters: SpotTradingApiCreateOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateOrderV3Resp>;

    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order using SOR (TRADE)
     * @param {SpotTradingApiCreateSorOrderTestV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createSorOrderTestV3(requestParameters: SpotTradingApiCreateSorOrderTestV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotCreateSorOrderTestV3Resp>;

    /**
     * Places an order using smart order routing (SOR).
     * @summary New order using SOR (TRADE)
     * @param {SpotTradingApiCreateSorOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createSorOrderV3(requestParameters: SpotTradingApiCreateSorOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateSorOrderV3Resp>;

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
     * @summary Start user data stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    createUserDataStreamV3(options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDataStreamV3Resp>;

    /**
     * Cancels all active orders on a symbol. This includes orders that are part of an order list.
     * @summary Cancel All Open Orders on a Symbol (TRADE)
     * @param {SpotTradingApiDeleteOpenOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    deleteOpenOrdersV3(requestParameters: SpotTradingApiDeleteOpenOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<SpotDeleteOpenOrdersV3RespInner>>>;

    /**
     * Cancel an entire Order list
     * @summary Cancel Order list (TRADE)
     * @param {SpotTradingApiDeleteOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    deleteOrderListV3(requestParameters: SpotTradingApiDeleteOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderListV3Resp>;

    /**
     * Cancel an active order.
     * @summary Cancel order (TRADE)
     * @param {SpotTradingApiDeleteOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    deleteOrderV3(requestParameters: SpotTradingApiDeleteOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV3Resp>;

    /**
     * Close out a user data stream.
     * @summary Close user data stream (USER_STREAM)
     * @param {SpotTradingApiDeleteUserDataStreamV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    deleteUserDataStreamV3(requestParameters: SpotTradingApiDeleteUserDataStreamV3Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Get current account commission rates.
     * @summary Query Commission Rates (USER_DATA)
     * @param {SpotTradingApiGetAccountCommissionV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getAccountCommissionV3(requestParameters: SpotTradingApiGetAccountCommissionV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountCommissionV3Resp>;

    /**
     * Get current account information.
     * @summary Account information (USER_DATA)
     * @param {SpotTradingApiGetAccountV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getAccountV3(requestParameters: SpotTradingApiGetAccountV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV3Resp>;

    /**
     * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
     * @summary Compressed/Aggregate trades list
     * @param {SpotTradingApiGetAggTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getAggTradesV3(requestParameters: SpotTradingApiGetAggTradesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SpotGetAggTradesV3RespItem>>;

    /**
     * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
     * @summary Query all Order lists (USER_DATA)
     * @param {SpotTradingApiGetAllOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getAllOrderListV3(requestParameters: SpotTradingApiGetAllOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrderListV3RespItem>>;

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All orders (USER_DATA)
     * @param {SpotTradingApiGetAllOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getAllOrdersV3(requestParameters: SpotTradingApiGetAllOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV3RespItem>>;

    /**
     * Current average price for a symbol.
     * @summary Current average price
     * @param {SpotTradingApiGetAvgPriceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getAvgPriceV3(requestParameters: SpotTradingApiGetAvgPriceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAvgPriceV3Resp>;

    /**
     * 
     * @summary Order book
     * @param {SpotTradingApiGetDepthV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getDepthV3(requestParameters: SpotTradingApiGetDepthV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV3Resp>;

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange information
     * @param {SpotTradingApiGetExchangeInfoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getExchangeInfoV3(requestParameters?: SpotTradingApiGetExchangeInfoV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetExchangeInfoV3Resp>;

    /**
     * Get older trades.
     * @summary Old trade lookup
     * @param {SpotTradingApiGetHistoricalTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getHistoricalTradesV3(requestParameters: SpotTradingApiGetHistoricalTradesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV3RespItem>>;

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick data
     * @param {SpotTradingApiGetKlinesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getKlinesV3(requestParameters: SpotTradingApiGetKlinesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<GetKlinesV3200ResponseInnerInner>>>;

    /**
     * Retrieves allocations resulting from SOR order placement.
     * @summary Query Allocations (USER_DATA)
     * @param {SpotTradingApiGetMyAllocationsV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getMyAllocationsV3(requestParameters: SpotTradingApiGetMyAllocationsV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMyAllocationsV3RespItem>>;

    /**
     * Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit
     * @summary Query Prevented Matches (USER_DATA)
     * @param {SpotTradingApiGetMyPreventedMatchesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getMyPreventedMatchesV3(requestParameters: SpotTradingApiGetMyPreventedMatchesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMyPreventedMatchesV3RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account trade list (USER_DATA)
     * @param {SpotTradingApiGetMyTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getMyTradesV3(requestParameters: SpotTradingApiGetMyTradesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMyTradesV3RespItem>>;

    /**
     * 
     * @summary Query Open Order lists (USER_DATA)
     * @param {SpotTradingApiGetOpenOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getOpenOrderListV3(requestParameters: SpotTradingApiGetOpenOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrderListV3RespItem>>;

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
     * @summary Current open orders (USER_DATA)
     * @param {SpotTradingApiGetOpenOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getOpenOrdersV3(requestParameters: SpotTradingApiGetOpenOrdersV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV3RespItem>>;

    /**
     * Retrieves a specific order list based on provided optional parameters.
     * @summary Query Order list (USER_DATA)
     * @param {SpotTradingApiGetOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getOrderListV3(requestParameters: SpotTradingApiGetOrderListV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderListV3Resp>;

    /**
     * Check an order\'s status.
     * @summary Query order (USER_DATA)
     * @param {SpotTradingApiGetOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getOrderV3(requestParameters: SpotTradingApiGetOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV3Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getPingV3(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Displays the user\'s unfilled order count for all intervals.
     * @summary Query Unfilled Order Count (USER_DATA)
     * @param {SpotTradingApiGetRateLimitOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getRateLimitOrderV3(requestParameters: SpotTradingApiGetRateLimitOrderV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRateLimitOrderV3RespItem>>;

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
     * @summary 24hr ticker price change statistics
     * @param {SpotTradingApiGetTicker24hrV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getTicker24hrV3(requestParameters?: SpotTradingApiGetTicker24hrV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTicker24hrV3Resp>;

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol order book ticker
     * @param {SpotTradingApiGetTickerBookTickerV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getTickerBookTickerV3(requestParameters?: SpotTradingApiGetTickerBookTickerV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTickerBookTickerV3Resp>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol price ticker
     * @param {SpotTradingApiGetTickerPriceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getTickerPriceV3(requestParameters?: SpotTradingApiGetTickerPriceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTickerPriceV3Resp>;

    /**
     * Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
     * @summary Trading Day Ticker
     * @param {SpotTradingApiGetTickerTradingDayV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getTickerTradingDayV3(requestParameters: SpotTradingApiGetTickerTradingDayV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTickerTradingDayV3Resp>;

    /**
     * Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
     * @summary Rolling window price change statistics
     * @param {SpotTradingApiGetTickerV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getTickerV3(requestParameters: SpotTradingApiGetTickerV3Request, options?: RawAxiosRequestConfig): AxiosPromise<SpotGetTickerV3Resp>;

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check server time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getTimeV3(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV3Resp>;

    /**
     * Get recent trades.
     * @summary Recent trades list
     * @param {SpotTradingApiGetTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getTradesV3(requestParameters: SpotTradingApiGetTradesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV3RespItem>>;

    /**
     * The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.
     * @summary UIKlines
     * @param {SpotTradingApiGetUiKlinesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    getUiKlinesV3(requestParameters: SpotTradingApiGetUiKlinesV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<GetKlinesV3200ResponseInnerInner>>>;

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 30 minutes.
     * @summary Keepalive user data stream (USER_STREAM)
     * @param {SpotTradingApiUpdateUserDataStreamV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApiInterface
     */
    updateUserDataStreamV3(requestParameters: SpotTradingApiUpdateUserDataStreamV3Request, options?: RawAxiosRequestConfig): AxiosPromise<object>;

}

/**
 * Request parameters for createOrderCancelReplaceV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateOrderCancelReplaceV3Request
 */
export interface SpotTradingApiCreateOrderCancelReplaceV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly cancelReplaceMode: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly cancelNewClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly cancelOrderId?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly cancelOrigClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly cancelRestrictions?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly orderRateLimitExceededMode?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderCancelReplaceV3
     */
    readonly trailingDelta?: number
}

/**
 * Request parameters for createOrderListOcoV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateOrderListOcoV3Request
 */
export interface SpotTradingApiCreateOrderListOcoV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly aboveType: CreateOrderListOcoV3AboveTypeEnum

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowType: CreateOrderListOcoV3BelowTypeEnum

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly aboveClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly aboveIcebergQty?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly abovePrice?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly aboveStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly aboveStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly aboveStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly aboveTimeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly aboveTrailingDelta?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowIcebergQty?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowPrice?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowTimeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly belowTrailingDelta?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly newOrderRespType?: CreateOrderListOcoV3NewOrderRespTypeEnum

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOcoV3
     */
    readonly selfTradePreventionMode?: string
}

/**
 * Request parameters for createOrderListOtoV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateOrderListOtoV3Request
 */
export interface SpotTradingApiCreateOrderListOtoV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingSide: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingType: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingPrice: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingSide: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingType: CreateOrderListOtoV3WorkingTypeEnum

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingPrice?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly pendingTrailingDelta?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingIcebergQty?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtoV3
     */
    readonly workingTimeInForce?: string
}

/**
 * Request parameters for createOrderListOtocoV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateOrderListOtocoV3Request
 */
export interface SpotTradingApiCreateOrderListOtocoV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAboveType: CreateOrderListOtocoV3PendingAboveTypeEnum

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingSide: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingPrice: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingQuantity: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingSide: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingType: CreateOrderListOtocoV3WorkingTypeEnum

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAboveClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAboveIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAbovePrice?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAboveStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAboveStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAboveStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAboveTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingAboveTrailingDelta?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowPrice?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowStopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowTimeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowTrailingDelta?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly pendingBelowType?: CreateOrderListOtocoV3PendingBelowTypeEnum

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingIcebergQty?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderListOtocoV3
     */
    readonly workingTimeInForce?: string
}

/**
 * Request parameters for createOrderOcoV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateOrderOcoV3Request
 */
export interface SpotTradingApiCreateOrderOcoV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly stopPrice: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly limitClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly limitIcebergQty?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly limitStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly limitStrategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly listClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly stopClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly stopIcebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly stopLimitPrice?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly stopLimitTimeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly stopStrategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly stopStrategyType?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderOcoV3
     */
    readonly trailingDelta?: number
}

/**
 * Request parameters for createOrderTestV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateOrderTestV3Request
 */
export interface SpotTradingApiCreateOrderTestV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly type: string

    /**
     * 
     * @type {boolean}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly computeCommissionRates?: boolean

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderTestV3
     */
    readonly trailingDelta?: number
}

/**
 * Request parameters for createOrderV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateOrderV3Request
 */
export interface SpotTradingApiCreateOrderV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly quantity?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly quoteOrderQty?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateOrderV3
     */
    readonly trailingDelta?: number
}

/**
 * Request parameters for createSorOrderTestV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateSorOrderTestV3Request
 */
export interface SpotTradingApiCreateSorOrderTestV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly type: string

    /**
     * 
     * @type {boolean}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly computeCommissionRates?: boolean

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly price?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderTestV3
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for createSorOrderV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiCreateSorOrderV3Request
 */
export interface SpotTradingApiCreateSorOrderV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly icebergQty?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly price?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly strategyId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly strategyType?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiCreateSorOrderV3
     */
    readonly timeInForce?: string
}

/**
 * Request parameters for deleteOpenOrdersV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiDeleteOpenOrdersV3Request
 */
export interface SpotTradingApiDeleteOpenOrdersV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiDeleteOpenOrdersV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiDeleteOpenOrdersV3
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiDeleteOpenOrdersV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteOrderListV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiDeleteOrderListV3Request
 */
export interface SpotTradingApiDeleteOrderListV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiDeleteOrderListV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiDeleteOrderListV3
     */
    readonly timestamp: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {number}
     * @memberof SpotTradingApiDeleteOrderListV3
     */
    readonly orderListId?: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {string}
     * @memberof SpotTradingApiDeleteOrderListV3
     */
    readonly listClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof SpotTradingApiDeleteOrderListV3
     */
    readonly newClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiDeleteOrderListV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteOrderV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiDeleteOrderV3Request
 */
export interface SpotTradingApiDeleteOrderV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiDeleteOrderV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiDeleteOrderV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiDeleteOrderV3
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiDeleteOrderV3
     */
    readonly origClientOrderId?: string

    /**
     * Used to uniquely identify this cancel. Automatically generated by default.
     * @type {string}
     * @memberof SpotTradingApiDeleteOrderV3
     */
    readonly newClientOrderId?: string

    /**
     * Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
     * @type {string}
     * @memberof SpotTradingApiDeleteOrderV3
     */
    readonly cancelRestrictions?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;.
     * @type {number}
     * @memberof SpotTradingApiDeleteOrderV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteUserDataStreamV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiDeleteUserDataStreamV3Request
 */
export interface SpotTradingApiDeleteUserDataStreamV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiDeleteUserDataStreamV3
     */
    readonly listenKey: string
}

/**
 * Request parameters for getAccountCommissionV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetAccountCommissionV3Request
 */
export interface SpotTradingApiGetAccountCommissionV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetAccountCommissionV3
     */
    readonly symbol: string
}

/**
 * Request parameters for getAccountV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetAccountV3Request
 */
export interface SpotTradingApiGetAccountV3Request {
    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetAccountV3
     */
    readonly timestamp: number

    /**
     * When set to &#x60;true&#x60;, emits only the non-zero balances of an account. &lt;br/&gt;Default value: &#x60;false&#x60;
     * @type {boolean}
     * @memberof SpotTradingApiGetAccountV3
     */
    readonly omitZeroBalances?: boolean

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetAccountV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAggTradesV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetAggTradesV3Request
 */
export interface SpotTradingApiGetAggTradesV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetAggTradesV3
     */
    readonly symbol: string

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof SpotTradingApiGetAggTradesV3
     */
    readonly fromId?: number

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof SpotTradingApiGetAggTradesV3
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof SpotTradingApiGetAggTradesV3
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof SpotTradingApiGetAggTradesV3
     */
    readonly limit?: number
}

/**
 * Request parameters for getAllOrderListV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetAllOrderListV3Request
 */
export interface SpotTradingApiGetAllOrderListV3Request {
    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetAllOrderListV3
     */
    readonly timestamp: number

    /**
     * If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
     * @type {number}
     * @memberof SpotTradingApiGetAllOrderListV3
     */
    readonly fromId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetAllOrderListV3
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetAllOrderListV3
     */
    readonly endTime?: number

    /**
     * Default Value: 500; Max Value: 1000
     * @type {number}
     * @memberof SpotTradingApiGetAllOrderListV3
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetAllOrderListV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAllOrdersV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetAllOrdersV3Request
 */
export interface SpotTradingApiGetAllOrdersV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetAllOrdersV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetAllOrdersV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetAllOrdersV3
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetAllOrdersV3
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetAllOrdersV3
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof SpotTradingApiGetAllOrdersV3
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetAllOrdersV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAvgPriceV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetAvgPriceV3Request
 */
export interface SpotTradingApiGetAvgPriceV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetAvgPriceV3
     */
    readonly symbol: string
}

/**
 * Request parameters for getDepthV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetDepthV3Request
 */
export interface SpotTradingApiGetDepthV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetDepthV3
     */
    readonly symbol: string

    /**
     * Default 100; max 5000. &lt;br/&gt; If limit &amp;gt; 5000. then the response will truncate to 5000.
     * @type {number}
     * @memberof SpotTradingApiGetDepthV3
     */
    readonly limit?: number
}

/**
 * Request parameters for getExchangeInfoV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetExchangeInfoV3Request
 */
export interface SpotTradingApiGetExchangeInfoV3Request {
    /**
     * Example: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC&lt;/a&gt;&amp;#34;
     * @type {string}
     * @memberof SpotTradingApiGetExchangeInfoV3
     */
    readonly symbol?: string

    /**
     * Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X  GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BTCUSDT%22,%22BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;[&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBBTC&lt;/a&gt;&amp;#34;]&amp;#39;
     * @type {Array<string>}
     * @memberof SpotTradingApiGetExchangeInfoV3
     */
    readonly symbols?: Array<string>

    /**
     * Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22,%22LEVERAGED\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;[&amp;#34;MARGIN&amp;#34;,&amp;#34;LEVERAGED&lt;/a&gt;&amp;#34;]&amp;#39;
     * @type {string}
     * @memberof SpotTradingApiGetExchangeInfoV3
     */
    readonly permissions?: string

    /**
     * Controls whether the content of the &#x60;permissionSets&#x60; field is populated or not. Defaults to &#x60;true&#x60;
     * @type {boolean}
     * @memberof SpotTradingApiGetExchangeInfoV3
     */
    readonly showPermissionSets?: boolean

    /**
     * Filters symbols that have this &#x60;tradingStatus&#x60;. Valid values: &#x60;TRADING&#x60;, &#x60;HALT&#x60;, &#x60;BREAK&#x60; &lt;br/&gt; Cannot be used in combination with &#x60;symbols&#x60; or &#x60;symbol&#x60;.
     * @type {'TRADING' | 'HALT' | 'BREAK'}
     * @memberof SpotTradingApiGetExchangeInfoV3
     */
    readonly symbolStatus?: GetExchangeInfoV3SymbolStatusEnum
}

/**
 * Request parameters for getHistoricalTradesV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetHistoricalTradesV3Request
 */
export interface SpotTradingApiGetHistoricalTradesV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetHistoricalTradesV3
     */
    readonly symbol: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof SpotTradingApiGetHistoricalTradesV3
     */
    readonly limit?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof SpotTradingApiGetHistoricalTradesV3
     */
    readonly fromId?: number
}

/**
 * Request parameters for getKlinesV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetKlinesV3Request
 */
export interface SpotTradingApiGetKlinesV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetKlinesV3
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetKlinesV3
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetKlinesV3
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetKlinesV3
     */
    readonly endTime?: number

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof SpotTradingApiGetKlinesV3
     */
    readonly timeZone?: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof SpotTradingApiGetKlinesV3
     */
    readonly limit?: number
}

/**
 * Request parameters for getMyAllocationsV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetMyAllocationsV3Request
 */
export interface SpotTradingApiGetMyAllocationsV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetMyAllocationsV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyAllocationsV3
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyAllocationsV3
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyAllocationsV3
     */
    readonly fromAllocationId?: number

    /**
     * Default 500;Max 1000
     * @type {number}
     * @memberof SpotTradingApiGetMyAllocationsV3
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyAllocationsV3
     */
    readonly orderId?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;.
     * @type {number}
     * @memberof SpotTradingApiGetMyAllocationsV3
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyAllocationsV3
     */
    readonly timestamp?: number
}

/**
 * Request parameters for getMyPreventedMatchesV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetMyPreventedMatchesV3Request
 */
export interface SpotTradingApiGetMyPreventedMatchesV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetMyPreventedMatchesV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyPreventedMatchesV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyPreventedMatchesV3
     */
    readonly preventedMatchId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyPreventedMatchesV3
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyPreventedMatchesV3
     */
    readonly fromPreventedMatchId?: number

    /**
     * Default: &#x60;500&#x60;; Max: &#x60;1000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetMyPreventedMatchesV3
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetMyPreventedMatchesV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMyTradesV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetMyTradesV3Request
 */
export interface SpotTradingApiGetMyTradesV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetMyTradesV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyTradesV3
     */
    readonly timestamp: number

    /**
     * This can only be used in combination with &#x60;symbol&#x60;.
     * @type {number}
     * @memberof SpotTradingApiGetMyTradesV3
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyTradesV3
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetMyTradesV3
     */
    readonly endTime?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof SpotTradingApiGetMyTradesV3
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof SpotTradingApiGetMyTradesV3
     */
    readonly limit?: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetMyTradesV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenOrderListV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetOpenOrderListV3Request
 */
export interface SpotTradingApiGetOpenOrderListV3Request {
    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetOpenOrderListV3
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetOpenOrderListV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenOrdersV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetOpenOrdersV3Request
 */
export interface SpotTradingApiGetOpenOrdersV3Request {
    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetOpenOrdersV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetOpenOrdersV3
     */
    readonly symbol?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetOpenOrdersV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderListV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetOrderListV3Request
 */
export interface SpotTradingApiGetOrderListV3Request {
    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetOrderListV3
     */
    readonly timestamp: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {number}
     * @memberof SpotTradingApiGetOrderListV3
     */
    readonly orderListId?: number

    /**
     * Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
     * @type {string}
     * @memberof SpotTradingApiGetOrderListV3
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetOrderListV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetOrderV3Request
 */
export interface SpotTradingApiGetOrderV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetOrderV3
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetOrderV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetOrderV3
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetOrderV3
     */
    readonly origClientOrderId?: string

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetOrderV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getRateLimitOrderV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetRateLimitOrderV3Request
 */
export interface SpotTradingApiGetRateLimitOrderV3Request {
    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetRateLimitOrderV3
     */
    readonly timestamp: number

    /**
     * The value cannot be greater than &#x60;60000&#x60;
     * @type {number}
     * @memberof SpotTradingApiGetRateLimitOrderV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTicker24hrV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetTicker24hrV3Request
 */
export interface SpotTradingApiGetTicker24hrV3Request {
    /**
     * Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
     * @type {string}
     * @memberof SpotTradingApiGetTicker24hrV3
     */
    readonly symbol?: string

    /**
     * Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
     * @type {string}
     * @memberof SpotTradingApiGetTicker24hrV3
     */
    readonly symbols?: string

    /**
     * Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
     * @type {'FULL' | 'MINI'}
     * @memberof SpotTradingApiGetTicker24hrV3
     */
    readonly type?: GetTicker24hrV3TypeEnum
}

/**
 * Request parameters for getTickerBookTickerV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetTickerBookTickerV3Request
 */
export interface SpotTradingApiGetTickerBookTickerV3Request {
    /**
     * Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
     * @type {string}
     * @memberof SpotTradingApiGetTickerBookTickerV3
     */
    readonly symbol?: string

    /**
     * Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
     * @type {string}
     * @memberof SpotTradingApiGetTickerBookTickerV3
     */
    readonly symbols?: string
}

/**
 * Request parameters for getTickerPriceV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetTickerPriceV3Request
 */
export interface SpotTradingApiGetTickerPriceV3Request {
    /**
     * Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
     * @type {string}
     * @memberof SpotTradingApiGetTickerPriceV3
     */
    readonly symbol?: string

    /**
     * Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
     * @type {string}
     * @memberof SpotTradingApiGetTickerPriceV3
     */
    readonly symbols?: string
}

/**
 * Request parameters for getTickerTradingDayV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetTickerTradingDayV3Request
 */
export interface SpotTradingApiGetTickerTradingDayV3Request {
    /**
     * Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
     * @type {string}
     * @memberof SpotTradingApiGetTickerTradingDayV3
     */
    readonly symbol: string

    /**
     * Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
     * @type {string}
     * @memberof SpotTradingApiGetTickerTradingDayV3
     */
    readonly symbols: string

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof SpotTradingApiGetTickerTradingDayV3
     */
    readonly timeZone?: string

    /**
     * Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
     * @type {'FULL' | 'MINI'}
     * @memberof SpotTradingApiGetTickerTradingDayV3
     */
    readonly type?: GetTickerTradingDayV3TypeEnum
}

/**
 * Request parameters for getTickerV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetTickerV3Request
 */
export interface SpotTradingApiGetTickerV3Request {
    /**
     * Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
     * @type {string}
     * @memberof SpotTradingApiGetTickerV3
     */
    readonly symbol: string

    /**
     * Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
     * @type {string}
     * @memberof SpotTradingApiGetTickerV3
     */
    readonly symbols: string

    /**
     * Defaults to &#x60;1d&#x60; if no parameter provided &lt;br/&gt; Supported &#x60;windowSize&#x60; values: &lt;br/&gt; &#x60;1m&#x60;,&#x60;2m&#x60;....&#x60;59m&#x60; for minutes &lt;br/&gt; &#x60;1h&#x60;, &#x60;2h&#x60;....&#x60;23h&#x60; - for hours &lt;br/&gt; &#x60;1d&#x60;...&#x60;7d&#x60; - for days &lt;br/&gt;&lt;br/&gt; Units cannot be combined (e.g. &#x60;1d2h&#x60; is not allowed)
     * @type {string}
     * @memberof SpotTradingApiGetTickerV3
     */
    readonly windowSize?: string

    /**
     * Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
     * @type {'FULL' | 'MINI'}
     * @memberof SpotTradingApiGetTickerV3
     */
    readonly type?: GetTickerV3TypeEnum
}

/**
 * Request parameters for getTradesV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetTradesV3Request
 */
export interface SpotTradingApiGetTradesV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetTradesV3
     */
    readonly symbol: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof SpotTradingApiGetTradesV3
     */
    readonly limit?: number
}

/**
 * Request parameters for getUiKlinesV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiGetUiKlinesV3Request
 */
export interface SpotTradingApiGetUiKlinesV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiGetUiKlinesV3
     */
    readonly symbol: string

    /**
     * See &lt;a href&#x3D;\&quot;/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\&quot;&gt;&#x60;klines&#x60;&lt;/a&gt;
     * @type {string}
     * @memberof SpotTradingApiGetUiKlinesV3
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetUiKlinesV3
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof SpotTradingApiGetUiKlinesV3
     */
    readonly endTime?: number

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof SpotTradingApiGetUiKlinesV3
     */
    readonly timeZone?: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof SpotTradingApiGetUiKlinesV3
     */
    readonly limit?: number
}

/**
 * Request parameters for updateUserDataStreamV3 operation in SpotTradingApi.
 * @export
 * @interface SpotTradingApiUpdateUserDataStreamV3Request
 */
export interface SpotTradingApiUpdateUserDataStreamV3Request {
    /**
     * 
     * @type {string}
     * @memberof SpotTradingApiUpdateUserDataStreamV3
     */
    readonly listenKey: string
}

/**
 * SpotTradingApi - object-oriented interface
 * @export
 * @class SpotTradingApi
 * @extends {BaseAPI}
 */
export class SpotTradingApi extends BaseAPI implements SpotTradingApiInterface {
    /**
     * Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
     * @summary Cancel an Existing Order and Send a New Order (TRADE)
     * @param {SpotTradingApiCreateOrderCancelReplaceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createOrderCancelReplaceV3(requestParameters: SpotTradingApiCreateOrderCancelReplaceV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createOrderCancelReplaceV3(requestParameters.cancelReplaceMode, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.cancelNewClientOrderId, requestParameters.cancelOrderId, requestParameters.cancelOrigClientOrderId, requestParameters.cancelRestrictions, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.orderRateLimitExceededMode, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
     * @summary New Order list - OCO (TRADE)
     * @param {SpotTradingApiCreateOrderListOcoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createOrderListOcoV3(requestParameters: SpotTradingApiCreateOrderListOcoV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createOrderListOcoV3(requestParameters.aboveType, requestParameters.belowType, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.aboveClientOrderId, requestParameters.aboveIcebergQty, requestParameters.abovePrice, requestParameters.aboveStopPrice, requestParameters.aboveStrategyId, requestParameters.aboveStrategyType, requestParameters.aboveTimeInForce, requestParameters.aboveTrailingDelta, requestParameters.belowClientOrderId, requestParameters.belowIcebergQty, requestParameters.belowPrice, requestParameters.belowStopPrice, requestParameters.belowStrategyId, requestParameters.belowStrategyType, requestParameters.belowTimeInForce, requestParameters.belowTrailingDelta, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
     * @summary New Order list - OTO (TRADE)
     * @param {SpotTradingApiCreateOrderListOtoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createOrderListOtoV3(requestParameters: SpotTradingApiCreateOrderListOtoV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createOrderListOtoV3(requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.pendingType, requestParameters.symbol, requestParameters.timestamp, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingClientOrderId, requestParameters.pendingIcebergQty, requestParameters.pendingPrice, requestParameters.pendingStopPrice, requestParameters.pendingStrategyId, requestParameters.pendingStrategyType, requestParameters.pendingTimeInForce, requestParameters.pendingTrailingDelta, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingStrategyId, requestParameters.workingStrategyType, requestParameters.workingTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
     * @summary New Order list - OTOCO (TRADE)
     * @param {SpotTradingApiCreateOrderListOtocoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createOrderListOtocoV3(requestParameters: SpotTradingApiCreateOrderListOtocoV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createOrderListOtocoV3(requestParameters.pendingAboveType, requestParameters.pendingQuantity, requestParameters.pendingSide, requestParameters.symbol, requestParameters.timestamp, requestParameters.workingPrice, requestParameters.workingQuantity, requestParameters.workingSide, requestParameters.workingType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.pendingAboveClientOrderId, requestParameters.pendingAboveIcebergQty, requestParameters.pendingAbovePrice, requestParameters.pendingAboveStopPrice, requestParameters.pendingAboveStrategyId, requestParameters.pendingAboveStrategyType, requestParameters.pendingAboveTimeInForce, requestParameters.pendingAboveTrailingDelta, requestParameters.pendingBelowClientOrderId, requestParameters.pendingBelowIcebergQty, requestParameters.pendingBelowPrice, requestParameters.pendingBelowStopPrice, requestParameters.pendingBelowStrategyId, requestParameters.pendingBelowStrategyType, requestParameters.pendingBelowTimeInForce, requestParameters.pendingBelowTrailingDelta, requestParameters.pendingBelowType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.workingClientOrderId, requestParameters.workingIcebergQty, requestParameters.workingStrategyId, requestParameters.workingStrategyType, requestParameters.workingTimeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
     * @summary New OCO - Deprecated (TRADE)
     * @param {SpotTradingApiCreateOrderOcoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createOrderOcoV3(requestParameters: SpotTradingApiCreateOrderOcoV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createOrderOcoV3(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.stopPrice, requestParameters.symbol, requestParameters.timestamp, requestParameters.limitClientOrderId, requestParameters.limitIcebergQty, requestParameters.limitStrategyId, requestParameters.limitStrategyType, requestParameters.listClientOrderId, requestParameters.newOrderRespType, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopClientOrderId, requestParameters.stopIcebergQty, requestParameters.stopLimitPrice, requestParameters.stopLimitTimeInForce, requestParameters.stopStrategyId, requestParameters.stopStrategyType, requestParameters.trailingDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order (TRADE)
     * @param {SpotTradingApiCreateOrderTestV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createOrderTestV3(requestParameters: SpotTradingApiCreateOrderTestV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createOrderTestV3(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.computeCommissionRates, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new order.
     * @summary New order (TRADE)
     * @param {SpotTradingApiCreateOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createOrderV3(requestParameters: SpotTradingApiCreateOrderV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createOrderV3(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.quantity, requestParameters.quoteOrderQty, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, requestParameters.trailingDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order using SOR (TRADE)
     * @param {SpotTradingApiCreateSorOrderTestV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createSorOrderTestV3(requestParameters: SpotTradingApiCreateSorOrderTestV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createSorOrderTestV3(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.computeCommissionRates, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Places an order using smart order routing (SOR).
     * @summary New order using SOR (TRADE)
     * @param {SpotTradingApiCreateSorOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createSorOrderV3(requestParameters: SpotTradingApiCreateSorOrderV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createSorOrderV3(requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.icebergQty, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.price, requestParameters.recvWindow, requestParameters.selfTradePreventionMode, requestParameters.strategyId, requestParameters.strategyType, requestParameters.timeInForce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
     * @summary Start user data stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public createUserDataStreamV3(options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).createUserDataStreamV3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels all active orders on a symbol. This includes orders that are part of an order list.
     * @summary Cancel All Open Orders on a Symbol (TRADE)
     * @param {SpotTradingApiDeleteOpenOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public deleteOpenOrdersV3(requestParameters: SpotTradingApiDeleteOpenOrdersV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).deleteOpenOrdersV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an entire Order list
     * @summary Cancel Order list (TRADE)
     * @param {SpotTradingApiDeleteOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public deleteOrderListV3(requestParameters: SpotTradingApiDeleteOrderListV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).deleteOrderListV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderListId, requestParameters.listClientOrderId, requestParameters.newClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel order (TRADE)
     * @param {SpotTradingApiDeleteOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public deleteOrderV3(requestParameters: SpotTradingApiDeleteOrderV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).deleteOrderV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.newClientOrderId, requestParameters.cancelRestrictions, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a user data stream.
     * @summary Close user data stream (USER_STREAM)
     * @param {SpotTradingApiDeleteUserDataStreamV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public deleteUserDataStreamV3(requestParameters: SpotTradingApiDeleteUserDataStreamV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).deleteUserDataStreamV3(requestParameters.listenKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account commission rates.
     * @summary Query Commission Rates (USER_DATA)
     * @param {SpotTradingApiGetAccountCommissionV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getAccountCommissionV3(requestParameters: SpotTradingApiGetAccountCommissionV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getAccountCommissionV3(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information.
     * @summary Account information (USER_DATA)
     * @param {SpotTradingApiGetAccountV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getAccountV3(requestParameters: SpotTradingApiGetAccountV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getAccountV3(requestParameters.timestamp, requestParameters.omitZeroBalances, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
     * @summary Compressed/Aggregate trades list
     * @param {SpotTradingApiGetAggTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getAggTradesV3(requestParameters: SpotTradingApiGetAggTradesV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getAggTradesV3(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can\'t be longer than 24 hours.
     * @summary Query all Order lists (USER_DATA)
     * @param {SpotTradingApiGetAllOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getAllOrderListV3(requestParameters: SpotTradingApiGetAllOrderListV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getAllOrderListV3(requestParameters.timestamp, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All orders (USER_DATA)
     * @param {SpotTradingApiGetAllOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getAllOrdersV3(requestParameters: SpotTradingApiGetAllOrdersV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getAllOrdersV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current average price for a symbol.
     * @summary Current average price
     * @param {SpotTradingApiGetAvgPriceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getAvgPriceV3(requestParameters: SpotTradingApiGetAvgPriceV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getAvgPriceV3(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Order book
     * @param {SpotTradingApiGetDepthV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getDepthV3(requestParameters: SpotTradingApiGetDepthV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getDepthV3(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange information
     * @param {SpotTradingApiGetExchangeInfoV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getExchangeInfoV3(requestParameters: SpotTradingApiGetExchangeInfoV3Request = {}, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getExchangeInfoV3(requestParameters.symbol, requestParameters.symbols, requestParameters.permissions, requestParameters.showPermissionSets, requestParameters.symbolStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older trades.
     * @summary Old trade lookup
     * @param {SpotTradingApiGetHistoricalTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getHistoricalTradesV3(requestParameters: SpotTradingApiGetHistoricalTradesV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getHistoricalTradesV3(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick data
     * @param {SpotTradingApiGetKlinesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getKlinesV3(requestParameters: SpotTradingApiGetKlinesV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getKlinesV3(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.timeZone, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves allocations resulting from SOR order placement.
     * @summary Query Allocations (USER_DATA)
     * @param {SpotTradingApiGetMyAllocationsV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getMyAllocationsV3(requestParameters: SpotTradingApiGetMyAllocationsV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getMyAllocationsV3(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.fromAllocationId, requestParameters.limit, requestParameters.orderId, requestParameters.recvWindow, requestParameters.timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit
     * @summary Query Prevented Matches (USER_DATA)
     * @param {SpotTradingApiGetMyPreventedMatchesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getMyPreventedMatchesV3(requestParameters: SpotTradingApiGetMyPreventedMatchesV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getMyPreventedMatchesV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.preventedMatchId, requestParameters.orderId, requestParameters.fromPreventedMatchId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account trade list (USER_DATA)
     * @param {SpotTradingApiGetMyTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getMyTradesV3(requestParameters: SpotTradingApiGetMyTradesV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getMyTradesV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Open Order lists (USER_DATA)
     * @param {SpotTradingApiGetOpenOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getOpenOrderListV3(requestParameters: SpotTradingApiGetOpenOrderListV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getOpenOrderListV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
     * @summary Current open orders (USER_DATA)
     * @param {SpotTradingApiGetOpenOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getOpenOrdersV3(requestParameters: SpotTradingApiGetOpenOrdersV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getOpenOrdersV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific order list based on provided optional parameters.
     * @summary Query Order list (USER_DATA)
     * @param {SpotTradingApiGetOrderListV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getOrderListV3(requestParameters: SpotTradingApiGetOrderListV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getOrderListV3(requestParameters.timestamp, requestParameters.orderListId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order\'s status.
     * @summary Query order (USER_DATA)
     * @param {SpotTradingApiGetOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getOrderV3(requestParameters: SpotTradingApiGetOrderV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getOrderV3(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getPingV3(options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getPingV3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Displays the user\'s unfilled order count for all intervals.
     * @summary Query Unfilled Order Count (USER_DATA)
     * @param {SpotTradingApiGetRateLimitOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getRateLimitOrderV3(requestParameters: SpotTradingApiGetRateLimitOrderV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getRateLimitOrderV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
     * @summary 24hr ticker price change statistics
     * @param {SpotTradingApiGetTicker24hrV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getTicker24hrV3(requestParameters: SpotTradingApiGetTicker24hrV3Request = {}, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getTicker24hrV3(requestParameters.symbol, requestParameters.symbols, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol order book ticker
     * @param {SpotTradingApiGetTickerBookTickerV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getTickerBookTickerV3(requestParameters: SpotTradingApiGetTickerBookTickerV3Request = {}, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getTickerBookTickerV3(requestParameters.symbol, requestParameters.symbols, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol price ticker
     * @param {SpotTradingApiGetTickerPriceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getTickerPriceV3(requestParameters: SpotTradingApiGetTickerPriceV3Request = {}, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getTickerPriceV3(requestParameters.symbol, requestParameters.symbols, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
     * @summary Trading Day Ticker
     * @param {SpotTradingApiGetTickerTradingDayV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getTickerTradingDayV3(requestParameters: SpotTradingApiGetTickerTradingDayV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getTickerTradingDayV3(requestParameters.symbol, requestParameters.symbols, requestParameters.timeZone, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
     * @summary Rolling window price change statistics
     * @param {SpotTradingApiGetTickerV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getTickerV3(requestParameters: SpotTradingApiGetTickerV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getTickerV3(requestParameters.symbol, requestParameters.symbols, requestParameters.windowSize, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check server time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getTimeV3(options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getTimeV3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent trades.
     * @summary Recent trades list
     * @param {SpotTradingApiGetTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getTradesV3(requestParameters: SpotTradingApiGetTradesV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getTradesV3(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.
     * @summary UIKlines
     * @param {SpotTradingApiGetUiKlinesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public getUiKlinesV3(requestParameters: SpotTradingApiGetUiKlinesV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).getUiKlinesV3(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.timeZone, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 30 minutes.
     * @summary Keepalive user data stream (USER_STREAM)
     * @param {SpotTradingApiUpdateUserDataStreamV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTradingApi
     */
    public updateUserDataStreamV3(requestParameters: SpotTradingApiUpdateUserDataStreamV3Request, options?: RawAxiosRequestConfig) {
        return SpotTradingApiFp(this.configuration).updateUserDataStreamV3(requestParameters.listenKey, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateOrderListOcoV3AboveTypeEnum = {
    StopLossLimit: 'STOP_LOSS_LIMIT',
    StopLoss: 'STOP_LOSS',
    LimitMaker: 'LIMIT_MAKER',
    TakeProfit: 'TAKE_PROFIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT'
} as const;
export type CreateOrderListOcoV3AboveTypeEnum = typeof CreateOrderListOcoV3AboveTypeEnum[keyof typeof CreateOrderListOcoV3AboveTypeEnum];
/**
 * @export
 */
export const CreateOrderListOcoV3BelowTypeEnum = {
    StopLoss: 'STOP_LOSS',
    StopLossLimit: 'STOP_LOSS_LIMIT',
    TakeProfit: 'TAKE_PROFIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT'
} as const;
export type CreateOrderListOcoV3BelowTypeEnum = typeof CreateOrderListOcoV3BelowTypeEnum[keyof typeof CreateOrderListOcoV3BelowTypeEnum];
/**
 * @export
 */
export const CreateOrderListOcoV3NewOrderRespTypeEnum = {
    Ack: 'ACK',
    Result: 'RESULT',
    Full: 'FULL'
} as const;
export type CreateOrderListOcoV3NewOrderRespTypeEnum = typeof CreateOrderListOcoV3NewOrderRespTypeEnum[keyof typeof CreateOrderListOcoV3NewOrderRespTypeEnum];
/**
 * @export
 */
export const CreateOrderListOtoV3WorkingTypeEnum = {
    Limit: 'LIMIT',
    LimitMaker: 'LIMIT_MAKER'
} as const;
export type CreateOrderListOtoV3WorkingTypeEnum = typeof CreateOrderListOtoV3WorkingTypeEnum[keyof typeof CreateOrderListOtoV3WorkingTypeEnum];
/**
 * @export
 */
export const CreateOrderListOtocoV3PendingAboveTypeEnum = {
    StopLossLimit: 'STOP_LOSS_LIMIT',
    StopLoss: 'STOP_LOSS',
    LimitMaker: 'LIMIT_MAKER',
    TakeProfit: 'TAKE_PROFIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT'
} as const;
export type CreateOrderListOtocoV3PendingAboveTypeEnum = typeof CreateOrderListOtocoV3PendingAboveTypeEnum[keyof typeof CreateOrderListOtocoV3PendingAboveTypeEnum];
/**
 * @export
 */
export const CreateOrderListOtocoV3WorkingTypeEnum = {
    Limit: 'LIMIT',
    LimitMaker: 'LIMIT_MAKER'
} as const;
export type CreateOrderListOtocoV3WorkingTypeEnum = typeof CreateOrderListOtocoV3WorkingTypeEnum[keyof typeof CreateOrderListOtocoV3WorkingTypeEnum];
/**
 * @export
 */
export const CreateOrderListOtocoV3PendingBelowTypeEnum = {
    StopLoss: 'STOP_LOSS',
    StopLossLimit: 'STOP_LOSS_LIMIT',
    TakeProfit: 'TAKE_PROFIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT'
} as const;
export type CreateOrderListOtocoV3PendingBelowTypeEnum = typeof CreateOrderListOtocoV3PendingBelowTypeEnum[keyof typeof CreateOrderListOtocoV3PendingBelowTypeEnum];
/**
 * @export
 */
export const GetExchangeInfoV3SymbolStatusEnum = {
    Trading: 'TRADING',
    Halt: 'HALT',
    Break: 'BREAK'
} as const;
export type GetExchangeInfoV3SymbolStatusEnum = typeof GetExchangeInfoV3SymbolStatusEnum[keyof typeof GetExchangeInfoV3SymbolStatusEnum];
/**
 * @export
 */
export const GetTicker24hrV3TypeEnum = {
    Full: 'FULL',
    Mini: 'MINI'
} as const;
export type GetTicker24hrV3TypeEnum = typeof GetTicker24hrV3TypeEnum[keyof typeof GetTicker24hrV3TypeEnum];
/**
 * @export
 */
export const GetTickerTradingDayV3TypeEnum = {
    Full: 'FULL',
    Mini: 'MINI'
} as const;
export type GetTickerTradingDayV3TypeEnum = typeof GetTickerTradingDayV3TypeEnum[keyof typeof GetTickerTradingDayV3TypeEnum];
/**
 * @export
 */
export const GetTickerV3TypeEnum = {
    Full: 'FULL',
    Mini: 'MINI'
} as const;
export type GetTickerV3TypeEnum = typeof GetTickerV3TypeEnum[keyof typeof GetTickerV3TypeEnum];
