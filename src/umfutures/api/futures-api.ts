/* tslint:disable */
/* eslint-disable */
/**
 * Binance USD-M Futures API
 * OpenAPI specification for Binance exchange - Umfutures API
 *
 * The version of the OpenAPI document: 0.2.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CreateConvertAcceptQuoteV1Resp } from '../model';
// @ts-ignore
import type { CreateConvertGetQuoteV1Resp } from '../model';
// @ts-ignore
import type { CreateFeeBurnV1Resp } from '../model';
// @ts-ignore
import type { CreateLeverageV1Resp } from '../model';
// @ts-ignore
import type { CreateListenKeyV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginTypeV1Resp } from '../model';
// @ts-ignore
import type { CreateMultiAssetsMarginV1Resp } from '../model';
// @ts-ignore
import type { CreateOrderTestV1Resp } from '../model';
// @ts-ignore
import type { CreateOrderV1Resp } from '../model';
// @ts-ignore
import type { CreatePositionMarginV1Resp } from '../model';
// @ts-ignore
import type { CreatePositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { DeleteAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteOrderV1Resp } from '../model';
// @ts-ignore
import type { GetAccountConfigV1Resp } from '../model';
// @ts-ignore
import type { GetAccountV2Resp } from '../model';
// @ts-ignore
import type { GetAccountV3Resp } from '../model';
// @ts-ignore
import type { GetAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { GetAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetBalanceV2RespItem } from '../model';
// @ts-ignore
import type { GetBalanceV3RespItem } from '../model';
// @ts-ignore
import type { GetCommissionRateV1Resp } from '../model';
// @ts-ignore
import type { GetConstituentsV1Resp } from '../model';
// @ts-ignore
import type { GetConvertExchangeInfoV1RespItem } from '../model';
// @ts-ignore
import type { GetConvertOrderStatusV1Resp } from '../model';
// @ts-ignore
import type { GetDepthV1Resp } from '../model';
// @ts-ignore
import type { GetFeeBurnV1Resp } from '../model';
// @ts-ignore
import type { GetForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetFundingInfoV1RespItem } from '../model';
// @ts-ignore
import type { GetFundingRateV1RespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataBasisRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataGlobalLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataOpenInterestHistRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTakerlongshortRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTopLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTopLongShortPositionRatioRespItem } from '../model';
// @ts-ignore
import type { GetHistoricalTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetIncomeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetIncomeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetIndexInfoV1RespItem } from '../model';
// @ts-ignore
import type { GetMultiAssetsMarginV1Resp } from '../model';
// @ts-ignore
import type { GetOpenInterestV1Resp } from '../model';
// @ts-ignore
import type { GetOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { GetOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetOrderV1Resp } from '../model';
// @ts-ignore
import type { GetPmAccountInfoV1Resp } from '../model';
// @ts-ignore
import type { GetPositionMarginHistoryV1RespItem } from '../model';
// @ts-ignore
import type { GetPositionRiskV2RespItem } from '../model';
// @ts-ignore
import type { GetPositionRiskV3RespItem } from '../model';
// @ts-ignore
import type { GetPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { GetRateLimitOrderV1RespItem } from '../model';
// @ts-ignore
import type { GetSymbolConfigV1RespItem } from '../model';
// @ts-ignore
import type { GetTimeV1Resp } from '../model';
// @ts-ignore
import type { GetTradeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetTradeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { UmfuturesCreateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { UmfuturesCreateCountdownCancelAllV1Req } from '../model';
// @ts-ignore
import type { UmfuturesCreateCountdownCancelAllV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesDeleteBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { UmfuturesGetAggTradesV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetApiTradingStatusV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetAssetIndexV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetContinuousKlinesV1RespInnerInner } from '../model';
// @ts-ignore
import type { UmfuturesGetExchangeInfoV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataDeliveryPriceRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetLeverageBracketV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetOrderAsynV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetPremiumIndexV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTicker24hrV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerBookTickerV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerPriceV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerPriceV2Resp } from '../model';
// @ts-ignore
import type { UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { UmfuturesUpdateBatchOrdersV1RespItem } from '../model';
// @ts-ignore
import type { UpdateListenKeyV1Resp } from '../model';
// @ts-ignore
import type { UpdateOrderV1Resp } from '../model';
/**
 * FuturesApi - axios parameter creator
 * @export
 */
export const FuturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1: async (batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept the offered quote by quote ID.
         * @summary Accept the offered quote (USER_DATA)
         * @param {string} quoteId 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConvertAcceptQuoteV1: async (quoteId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteId' is not null or undefined
            assertParamExists('createConvertAcceptQuoteV1', 'quoteId', quoteId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createConvertAcceptQuoteV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/convert/acceptQuote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (quoteId !== undefined) { 
                localVarFormParams.set('quoteId', quoteId as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a quote for the requested token pairs
         * @summary Send Quote Request(USER_DATA)
         * @param {string} fromAsset 
         * @param {number} timestamp 
         * @param {string} toAsset 
         * @param {string} [fromAmount] 
         * @param {number} [recvWindow] 
         * @param {string} [toAmount] 
         * @param {string} [validTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConvertGetQuoteV1: async (fromAsset: string, timestamp: number, toAsset: string, fromAmount?: string, recvWindow?: number, toAmount?: string, validTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromAsset' is not null or undefined
            assertParamExists('createConvertGetQuoteV1', 'fromAsset', fromAsset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createConvertGetQuoteV1', 'timestamp', timestamp)
            // verify required parameter 'toAsset' is not null or undefined
            assertParamExists('createConvertGetQuoteV1', 'toAsset', toAsset)
            const localVarPath = `/fapi/v1/convert/getQuote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (fromAmount !== undefined) { 
                localVarFormParams.set('fromAmount', fromAmount as any);
            }
    
            if (fromAsset !== undefined) { 
                localVarFormParams.set('fromAsset', fromAsset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (toAmount !== undefined) { 
                localVarFormParams.set('toAmount', toAmount as any);
            }
    
            if (toAsset !== undefined) { 
                localVarFormParams.set('toAsset', toAsset as any);
            }
    
            if (validTime !== undefined) { 
                localVarFormParams.set('validTime', validTime as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {UmfuturesCreateCountdownCancelAllV1Req} [umfuturesCreateCountdownCancelAllV1Req] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1: async (umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/countdownCancelAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(umfuturesCreateCountdownCancelAllV1Req, localVarRequestOptions, configuration)
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On Futures Trade (TRADE)
         * @param {string} feeBurn 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeeBurnV1: async (feeBurn: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feeBurn' is not null or undefined
            assertParamExists('createFeeBurnV1', 'feeBurn', feeBurn)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createFeeBurnV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/feeBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (feeBurn !== undefined) { 
                localVarFormParams.set('feeBurn', feeBurn as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('createLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginTypeV1: async (marginType: string, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marginType' is not null or undefined
            assertParamExists('createMarginTypeV1', 'marginType', marginType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginTypeV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginTypeV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/marginType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (marginType !== undefined) { 
                localVarFormParams.set('marginType', marginType as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {string} multiAssetsMargin 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultiAssetsMarginV1: async (multiAssetsMargin: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'multiAssetsMargin' is not null or undefined
            assertParamExists('createMultiAssetsMarginV1', 'multiAssetsMargin', multiAssetsMargin)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMultiAssetsMarginV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/multiAssetsMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (multiAssetsMargin !== undefined) { 
                localVarFormParams.set('multiAssetsMargin', multiAssetsMargin as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderTestV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderTestV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderTestV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderTestV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderTestV1', 'type', type)
            const localVarPath = `/fapi/v1/order/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderV1', 'type', type)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionMarginV1: async (amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createPositionMarginV1', 'amount', amount)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createPositionMarginV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPositionMarginV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createPositionMarginV1', 'type', type)
            const localVarPath = `/fapi/v1/positionMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('createPositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1: async (symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIdList) {
                localVarQueryParameter['orderIdList'] = orderIdList;
            }

            if (origClientOrderIdList) {
                localVarQueryParameter['origClientOrderIdList'] = origClientOrderIdList;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account configuration
         * @summary Futures Account Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountConfigV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountConfigV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/accountConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V2(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV2', 'timestamp', timestamp)
            const localVarPath = `/fapi/v2/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V3(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV3: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV3', 'timestamp', timestamp)
            const localVarPath = `/fapi/v3/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdlQuantileV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAdlQuantileV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV1: async (symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAggTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/aggTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
         * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTradingStatusV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getApiTradingStatusV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/apiTradingStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {string} [symbol] Asset pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetIndexV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/assetIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV2: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBalanceV2', 'timestamp', timestamp)
            const localVarPath = `/fapi/v2/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV3: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBalanceV3', 'timestamp', timestamp)
            const localVarPath = `/fapi/v3/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Commission Rate
         * @summary User Commission Rate (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommissionRateV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCommissionRateV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCommissionRateV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/commissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstituentsV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getConstituentsV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/constituents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinuousKlinesV1: async (pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'contractType', contractType)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/continuousKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for all convertible token pairs and the tokens’ respective upper/lower limits
         * @summary List All Convert Pairs
         * @param {string} [fromAsset] User spends coin
         * @param {string} [toAsset] User receives coin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertExchangeInfoV1: async (fromAsset?: string, toAsset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/convert/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromAsset !== undefined) {
                localVarQueryParameter['fromAsset'] = fromAsset;
            }

            if (toAsset !== undefined) {
                localVarQueryParameter['toAsset'] = toAsset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query order status by order ID.
         * @summary Order status(USER_DATA)
         * @param {string} [orderId] Either orderId or quoteId is required
         * @param {string} [quoteId] Either orderId or quoteId is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertOrderStatusV1: async (orderId?: string, quoteId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/convert/orderStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (quoteId !== undefined) {
                localVarQueryParameter['quoteId'] = quoteId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getDepthV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeBurnV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getFeeBurnV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/feeBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/fundingInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {string} [symbol] 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateV1: async (symbol?: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/fundingRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {string} pair BTCUSDT
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} limit Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataBasis: async (pair: string, contractType: string, period: string, limit: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'period', period)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'limit', limit)
            const localVarPath = `/futures/data/basis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {string} pair e.g BTCUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataDeliveryPrice: async (pair: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataDeliveryPrice', 'pair', pair)
            const localVarPath = `/futures/data/delivery-price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataGlobalLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataGlobalLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataGlobalLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/globalLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataOpenInterestHist: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'period', period)
            const localVarPath = `/futures/data/openInterestHist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTakerlongshortRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataTakerlongshortRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTakerlongshortRatio', 'period', period)
            const localVarPath = `/futures/data/takerlongshortRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortPositionRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortPositionRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortPositionRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortPositionRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1: async (symbol: string, limit?: number, fromId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getHistoricalTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/income/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/income/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexInfoV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/indexInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexPriceKlinesV1: async (pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getIndexPriceKlinesV1', 'pair', pair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getIndexPriceKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/indexPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user notional and leverage bracket on speicfic symbol
         * @summary Notional and Leverage Brackets (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getLeverageBracketV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkPriceKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarkPriceKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getMarkPriceKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/markPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Get Current Multi-Assets Mode (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiAssetsMarginV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMultiAssetsMarginV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/multiAssetsMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenInterestV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/openInterest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getOrderAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getOrderAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getOrderAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAsynV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmAccountInfoV1: async (asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPmAccountInfoV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPmAccountInfoV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/pmAccountInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin，2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] Default current time if not pass
         * @param {number} [limit] Default: 500
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionMarginHistoryV1: async (symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPositionMarginHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionMarginHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/positionMargin/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV2: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionRiskV2', 'timestamp', timestamp)
            const localVarPath = `/fapi/v2/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV3: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionRiskV3', 'timestamp', timestamp)
            const localVarPath = `/fapi/v3/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionSideDualV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPremiumIndexKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getPremiumIndexKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/premiumIndexKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/premiumIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimitOrderV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getRateLimitOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/rateLimit/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account symbol configuration.
         * @summary Symbol Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolConfigV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getSymbolConfigV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/symbolConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/24hr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/bookTicker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV2: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v2/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getTradeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTradeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/trade/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getTradeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getTradeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTradeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/trade/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] This can only be used in combination with &#x60;symbol&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUserTradesV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchOrdersV1: async (batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('updateBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderV1: async (price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('updateOrderV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('updateOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('updateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('updateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FuturesApi - functional programming interface
 * @export
 */
export const FuturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FuturesApiAxiosParamCreator(configuration)
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchOrdersV1(batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accept the offered quote by quote ID.
         * @summary Accept the offered quote (USER_DATA)
         * @param {string} quoteId 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConvertAcceptQuoteV1(quoteId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConvertAcceptQuoteV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConvertAcceptQuoteV1(quoteId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createConvertAcceptQuoteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request a quote for the requested token pairs
         * @summary Send Quote Request(USER_DATA)
         * @param {string} fromAsset 
         * @param {number} timestamp 
         * @param {string} toAsset 
         * @param {string} [fromAmount] 
         * @param {number} [recvWindow] 
         * @param {string} [toAmount] 
         * @param {string} [validTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConvertGetQuoteV1(fromAsset: string, timestamp: number, toAsset: string, fromAmount?: string, recvWindow?: number, toAmount?: string, validTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConvertGetQuoteV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConvertGetQuoteV1(fromAsset, timestamp, toAsset, fromAmount, recvWindow, toAmount, validTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createConvertGetQuoteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {UmfuturesCreateCountdownCancelAllV1Req} [umfuturesCreateCountdownCancelAllV1Req] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCountdownCancelAllV1(umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCountdownCancelAllV1(umfuturesCreateCountdownCancelAllV1Req, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createCountdownCancelAllV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On Futures Trade (TRADE)
         * @param {string} feeBurn 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeeBurnV1(feeBurn: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFeeBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeeBurnV1(feeBurn, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createFeeBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginTypeV1(marginType: string, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginTypeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginTypeV1(marginType, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createMarginTypeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {string} multiAssetsMargin 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMultiAssetsMarginV1(multiAssetsMargin: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMultiAssetsMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMultiAssetsMarginV1(multiAssetsMargin, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createMultiAssetsMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderTestV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderTestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderTestV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, goodTillDate, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createOrderTestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, goodTillDate, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionMarginV1(amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePositionMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionMarginV1(amount, symbol, timestamp, type, positionSide, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createPositionMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.createPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.deleteAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatchOrdersV1(symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatchOrdersV1(symbol, timestamp, orderIdList, origClientOrderIdList, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.deleteBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.deleteListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.deleteOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account configuration
         * @summary Futures Account Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountConfigV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountConfigV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountConfigV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAccountConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V2(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV2(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV2Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV2(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAccountV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V3(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV3(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV3(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAccountV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdlQuantileV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdlQuantileV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggTradesV1(symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggTradesV1(symbol, fromId, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAggTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
         * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiTradingStatusV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetApiTradingStatusV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiTradingStatusV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getApiTradingStatusV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {string} [symbol] Asset pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetIndexV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetAssetIndexV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetIndexV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getAssetIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceV2(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBalanceV2RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceV2(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getBalanceV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceV3(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBalanceV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceV3(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getBalanceV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User Commission Rate
         * @summary User Commission Rate (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommissionRateV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommissionRateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionRateV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getCommissionRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConstituentsV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConstituentsV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConstituentsV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getConstituentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContinuousKlinesV1(pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContinuousKlinesV1(pair, contractType, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getContinuousKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query for all convertible token pairs and the tokens’ respective upper/lower limits
         * @summary List All Convert Pairs
         * @param {string} [fromAsset] User spends coin
         * @param {string} [toAsset] User receives coin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvertExchangeInfoV1(fromAsset?: string, toAsset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetConvertExchangeInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvertExchangeInfoV1(fromAsset, toAsset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getConvertExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query order status by order ID.
         * @summary Order status(USER_DATA)
         * @param {string} [orderId] Either orderId or quoteId is required
         * @param {string} [quoteId] Either orderId or quoteId is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvertOrderStatusV1(orderId?: string, quoteId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConvertOrderStatusV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvertOrderStatusV1(orderId, quoteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getConvertOrderStatusV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepthV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDepthV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepthV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getDepthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetExchangeInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeBurnV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeeBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeeBurnV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFeeBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForceOrdersV1(timestamp, symbol, autoCloseType, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFundingInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFundingInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {string} [symbol] 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingRateV1(symbol?: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFundingRateV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingRateV1(symbol, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFundingRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {string} pair BTCUSDT
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} limit Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataBasis(pair: string, contractType: string, period: string, limit: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataBasisRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataBasis(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataBasis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {string} pair e.g BTCUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataDeliveryPrice(pair: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataDeliveryPrice(pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataDeliveryPrice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataGlobalLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataGlobalLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataGlobalLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataOpenInterestHist(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataOpenInterestHist(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataOpenInterestHist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTakerlongshortRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTakerlongshortRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTakerlongshortRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataTakerlongshortRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTopLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTopLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataTopLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTopLongShortPositionRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTopLongShortPositionRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getFuturesDataTopLongShortPositionRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTradesV1(symbol: string, limit?: number, fromId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetHistoricalTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTradesV1(symbol, limit, fromId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getHistoricalTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getIncomeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getIncomeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndexInfoV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetIndexInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndexInfoV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getIndexInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndexPriceKlinesV1(pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndexPriceKlinesV1(pair, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getIndexPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user notional and leverage bracket on speicfic symbol
         * @summary Notional and Leverage Brackets (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeverageBracketV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetLeverageBracketV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeverageBracketV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarkPriceKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarkPriceKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getMarkPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Get Current Multi-Assets Mode (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultiAssetsMarginV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMultiAssetsMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultiAssetsMarginV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getMultiAssetsMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenInterestV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOpenInterestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenInterestV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOpenInterestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrdersV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrdersV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOrderAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetOrderAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOrderAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmAccountInfoV1(asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPmAccountInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmAccountInfoV1(asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPmAccountInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin，2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] Default current time if not pass
         * @param {number} [limit] Default: 500
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionMarginHistoryV1(symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionMarginHistoryV1(symbol, timestamp, type, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPositionMarginHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionRiskV2(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionRiskV2RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionRiskV2(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPositionRiskV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionRiskV3(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionRiskV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionRiskV3(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPositionRiskV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionSideDualV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionSideDualV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPremiumIndexKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPremiumIndexKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPremiumIndexKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPremiumIndexV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetPremiumIndexV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPremiumIndexV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getPremiumIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimitOrderV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRateLimitOrderV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimitOrderV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getRateLimitOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account symbol configuration.
         * @summary Symbol Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSymbolConfigV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetSymbolConfigV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSymbolConfigV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getSymbolConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicker24hrV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTicker24hrV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker24hrV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTicker24hrV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerBookTickerV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerBookTickerV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerBookTickerV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTickerBookTickerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerPriceV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerPriceV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerPriceV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTickerPriceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerPriceV2(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerPriceV2Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerPriceV2(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTickerPriceV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTimeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTimeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTradeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTradeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTradeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTradeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradesV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradesV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] This can only be used in combination with &#x60;symbol&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTradesV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTradesV1(symbol, timestamp, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.getUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatchOrdersV1(batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.updateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.updateListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrderV1(price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrderV1(price, quantity, side, symbol, timestamp, orderId, origClientOrderId, priceMatch, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuturesApi.updateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FuturesApi - factory interface
 * @export
 */
export const FuturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FuturesApiFp(configuration)
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {FuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1(requestParameters: FuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>> {
            return localVarFp.createBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept the offered quote by quote ID.
         * @summary Accept the offered quote (USER_DATA)
         * @param {FuturesApiCreateConvertAcceptQuoteV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConvertAcceptQuoteV1(requestParameters: FuturesApiCreateConvertAcceptQuoteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateConvertAcceptQuoteV1Resp> {
            return localVarFp.createConvertAcceptQuoteV1(requestParameters.quoteId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a quote for the requested token pairs
         * @summary Send Quote Request(USER_DATA)
         * @param {FuturesApiCreateConvertGetQuoteV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConvertGetQuoteV1(requestParameters: FuturesApiCreateConvertGetQuoteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateConvertGetQuoteV1Resp> {
            return localVarFp.createConvertGetQuoteV1(requestParameters.fromAsset, requestParameters.timestamp, requestParameters.toAsset, requestParameters.fromAmount, requestParameters.recvWindow, requestParameters.toAmount, requestParameters.validTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {FuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1(requestParameters: FuturesApiCreateCountdownCancelAllV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp> {
            return localVarFp.createCountdownCancelAllV1(requestParameters.umfuturesCreateCountdownCancelAllV1Req, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On Futures Trade (TRADE)
         * @param {FuturesApiCreateFeeBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeeBurnV1(requestParameters: FuturesApiCreateFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateFeeBurnV1Resp> {
            return localVarFp.createFeeBurnV1(requestParameters.feeBurn, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {FuturesApiCreateLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeverageV1(requestParameters: FuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeverageV1Resp> {
            return localVarFp.createLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp> {
            return localVarFp.createListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {FuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginTypeV1(requestParameters: FuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginTypeV1Resp> {
            return localVarFp.createMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {FuturesApiCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultiAssetsMarginV1(requestParameters: FuturesApiCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMultiAssetsMarginV1Resp> {
            return localVarFp.createMultiAssetsMarginV1(requestParameters.multiAssetsMargin, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {FuturesApiCreateOrderTestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderTestV1(requestParameters: FuturesApiCreateOrderTestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderTestV1Resp> {
            return localVarFp.createOrderTestV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {FuturesApiCreateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1(requestParameters: FuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderV1Resp> {
            return localVarFp.createOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {FuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionMarginV1(requestParameters: FuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionMarginV1Resp> {
            return localVarFp.createPositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {FuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionSideDualV1(requestParameters: FuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionSideDualV1Resp> {
            return localVarFp.createPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {FuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1(requestParameters: FuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp> {
            return localVarFp.deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {FuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1(requestParameters: FuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>> {
            return localVarFp.deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {FuturesApiDeleteOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1(requestParameters: FuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp> {
            return localVarFp.deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account configuration
         * @summary Futures Account Configuration(USER_DATA)
         * @param {FuturesApiGetAccountConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountConfigV1(requestParameters: FuturesApiGetAccountConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountConfigV1Resp> {
            return localVarFp.getAccountConfigV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V2(USER_DATA)
         * @param {FuturesApiGetAccountV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2(requestParameters: FuturesApiGetAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV2Resp> {
            return localVarFp.getAccountV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V3(USER_DATA)
         * @param {FuturesApiGetAccountV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV3(requestParameters: FuturesApiGetAccountV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV3Resp> {
            return localVarFp.getAccountV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {FuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdlQuantileV1(requestParameters: FuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAdlQuantileV1RespItem>> {
            return localVarFp.getAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {FuturesApiGetAggTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV1(requestParameters: FuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>> {
            return localVarFp.getAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {FuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV1(requestParameters: FuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV1RespItem>> {
            return localVarFp.getAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
         * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
         * @param {FuturesApiGetApiTradingStatusV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTradingStatusV1(requestParameters: FuturesApiGetApiTradingStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetApiTradingStatusV1Resp> {
            return localVarFp.getApiTradingStatusV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {FuturesApiGetAssetIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetIndexV1(requestParameters: FuturesApiGetAssetIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetAssetIndexV1Resp> {
            return localVarFp.getAssetIndexV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V2 (USER_DATA)
         * @param {FuturesApiGetBalanceV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV2(requestParameters: FuturesApiGetBalanceV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV2RespItem>> {
            return localVarFp.getBalanceV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V3 (USER_DATA)
         * @param {FuturesApiGetBalanceV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV3(requestParameters: FuturesApiGetBalanceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV3RespItem>> {
            return localVarFp.getBalanceV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User Commission Rate
         * @summary User Commission Rate (USER_DATA)
         * @param {FuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommissionRateV1(requestParameters: FuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCommissionRateV1Resp> {
            return localVarFp.getCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {FuturesApiGetConstituentsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstituentsV1(requestParameters: FuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConstituentsV1Resp> {
            return localVarFp.getConstituentsV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {FuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinuousKlinesV1(requestParameters: FuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for all convertible token pairs and the tokens’ respective upper/lower limits
         * @summary List All Convert Pairs
         * @param {FuturesApiGetConvertExchangeInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertExchangeInfoV1(requestParameters: FuturesApiGetConvertExchangeInfoV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetConvertExchangeInfoV1RespItem>> {
            return localVarFp.getConvertExchangeInfoV1(requestParameters.fromAsset, requestParameters.toAsset, options).then((request) => request(axios, basePath));
        },
        /**
         * Query order status by order ID.
         * @summary Order status(USER_DATA)
         * @param {FuturesApiGetConvertOrderStatusV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertOrderStatusV1(requestParameters: FuturesApiGetConvertOrderStatusV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetConvertOrderStatusV1Resp> {
            return localVarFp.getConvertOrderStatusV1(requestParameters.orderId, requestParameters.quoteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {FuturesApiGetDepthV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1(requestParameters: FuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp> {
            return localVarFp.getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetExchangeInfoV1Resp> {
            return localVarFp.getExchangeInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {FuturesApiGetFeeBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeBurnV1(requestParameters: FuturesApiGetFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetFeeBurnV1Resp> {
            return localVarFp.getFeeBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {FuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForceOrdersV1(requestParameters: FuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetForceOrdersV1RespItem>> {
            return localVarFp.getForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingInfoV1RespItem>> {
            return localVarFp.getFundingInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {FuturesApiGetFundingRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateV1(requestParameters: FuturesApiGetFundingRateV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingRateV1RespItem>> {
            return localVarFp.getFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {FuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataBasis(requestParameters: FuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataBasisRespItem>> {
            return localVarFp.getFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {FuturesApiGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataDeliveryPrice(requestParameters: FuturesApiGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>> {
            return localVarFp.getFuturesDataDeliveryPrice(requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataGlobalLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>> {
            return localVarFp.getFuturesDataGlobalLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {FuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataOpenInterestHist(requestParameters: FuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>> {
            return localVarFp.getFuturesDataOpenInterestHist(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {FuturesApiGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTakerlongshortRatio(requestParameters: FuturesApiGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTakerlongshortRatioRespItem>> {
            return localVarFp.getFuturesDataTakerlongshortRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {FuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>> {
            return localVarFp.getFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {FuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortPositionRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>> {
            return localVarFp.getFuturesDataTopLongShortPositionRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {FuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1(requestParameters: FuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>> {
            return localVarFp.getHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {FuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1(requestParameters: FuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp> {
            return localVarFp.getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {FuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1(requestParameters: FuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp> {
            return localVarFp.getIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {FuturesApiGetIndexInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexInfoV1(requestParameters: FuturesApiGetIndexInfoV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIndexInfoV1RespItem>> {
            return localVarFp.getIndexInfoV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {FuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexPriceKlinesV1(requestParameters: FuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {FuturesApiGetKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1(requestParameters: FuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user notional and leverage bracket on speicfic symbol
         * @summary Notional and Leverage Brackets (USER_DATA)
         * @param {FuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV1(requestParameters: FuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetLeverageBracketV1Resp> {
            return localVarFp.getLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {FuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkPriceKlinesV1(requestParameters: FuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Get Current Multi-Assets Mode (USER_DATA)
         * @param {FuturesApiGetMultiAssetsMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiAssetsMarginV1(requestParameters: FuturesApiGetMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMultiAssetsMarginV1Resp> {
            return localVarFp.getMultiAssetsMarginV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {FuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1(requestParameters: FuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenInterestV1Resp> {
            return localVarFp.getOpenInterestV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {FuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderV1(requestParameters: FuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenOrderV1Resp> {
            return localVarFp.getOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {FuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1(requestParameters: FuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>> {
            return localVarFp.getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {FuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAmendmentV1(requestParameters: FuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOrderAmendmentV1RespItem>> {
            return localVarFp.getOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {FuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynIdV1(requestParameters: FuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynIdV1Resp> {
            return localVarFp.getOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {FuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynV1(requestParameters: FuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOrderAsynV1Resp> {
            return localVarFp.getOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {FuturesApiGetOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1(requestParameters: FuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp> {
            return localVarFp.getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {FuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmAccountInfoV1(requestParameters: FuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPmAccountInfoV1Resp> {
            return localVarFp.getPmAccountInfoV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {FuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionMarginHistoryV1(requestParameters: FuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>> {
            return localVarFp.getPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {FuturesApiGetPositionRiskV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV2(requestParameters: FuturesApiGetPositionRiskV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV2RespItem>> {
            return localVarFp.getPositionRiskV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {FuturesApiGetPositionRiskV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV3(requestParameters: FuturesApiGetPositionRiskV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV3RespItem>> {
            return localVarFp.getPositionRiskV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {FuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionSideDualV1(requestParameters: FuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPositionSideDualV1Resp> {
            return localVarFp.getPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {FuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexKlinesV1(requestParameters: FuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {FuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexV1(requestParameters: FuturesApiGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetPremiumIndexV1Resp> {
            return localVarFp.getPremiumIndexV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {FuturesApiGetRateLimitOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimitOrderV1(requestParameters: FuturesApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRateLimitOrderV1RespItem>> {
            return localVarFp.getRateLimitOrderV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account symbol configuration.
         * @summary Symbol Configuration(USER_DATA)
         * @param {FuturesApiGetSymbolConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolConfigV1(requestParameters: FuturesApiGetSymbolConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetSymbolConfigV1RespItem>> {
            return localVarFp.getSymbolConfigV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {FuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV1(requestParameters: FuturesApiGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTicker24hrV1Resp> {
            return localVarFp.getTicker24hrV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {FuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV1(requestParameters: FuturesApiGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerBookTickerV1Resp> {
            return localVarFp.getTickerBookTickerV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {FuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV1(requestParameters: FuturesApiGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV1Resp> {
            return localVarFp.getTickerPriceV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {FuturesApiGetTickerPriceV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV2(requestParameters: FuturesApiGetTickerPriceV2Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV2Resp> {
            return localVarFp.getTickerPriceV2(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp> {
            return localVarFp.getTimeV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {FuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynIdV1(requestParameters: FuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynIdV1Resp> {
            return localVarFp.getTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {FuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynV1(requestParameters: FuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynV1Resp> {
            return localVarFp.getTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {FuturesApiGetTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1(requestParameters: FuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>> {
            return localVarFp.getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {FuturesApiGetUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1(requestParameters: FuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>> {
            return localVarFp.getUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {FuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchOrdersV1(requestParameters: FuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>> {
            return localVarFp.updateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<UpdateListenKeyV1Resp> {
            return localVarFp.updateListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {FuturesApiUpdateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderV1(requestParameters: FuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderV1Resp> {
            return localVarFp.updateOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FuturesApi - interface
 * @export
 * @interface FuturesApi
 */
export interface FuturesApiInterface {
    /**
     * Place Multiple Orders
     * @summary Place Multiple Orders(TRADE)
     * @param {FuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createBatchOrdersV1(requestParameters: FuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>>;

    /**
     * Accept the offered quote by quote ID.
     * @summary Accept the offered quote (USER_DATA)
     * @param {FuturesApiCreateConvertAcceptQuoteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createConvertAcceptQuoteV1(requestParameters: FuturesApiCreateConvertAcceptQuoteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateConvertAcceptQuoteV1Resp>;

    /**
     * Request a quote for the requested token pairs
     * @summary Send Quote Request(USER_DATA)
     * @param {FuturesApiCreateConvertGetQuoteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createConvertGetQuoteV1(requestParameters: FuturesApiCreateConvertGetQuoteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateConvertGetQuoteV1Resp>;

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {FuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createCountdownCancelAllV1(requestParameters?: FuturesApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp>;

    /**
     * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
     * @summary Toggle BNB Burn On Futures Trade (TRADE)
     * @param {FuturesApiCreateFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createFeeBurnV1(requestParameters: FuturesApiCreateFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateFeeBurnV1Resp>;

    /**
     * Change user\'s initial leverage of specific symbol market.
     * @summary Change Initial Leverage(TRADE)
     * @param {FuturesApiCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createLeverageV1(requestParameters: FuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeverageV1Resp>;

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp>;

    /**
     * Change symbol level margin type
     * @summary Change Margin Type(TRADE)
     * @param {FuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createMarginTypeV1(requestParameters: FuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginTypeV1Resp>;

    /**
     * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Change Multi-Assets Mode (TRADE)
     * @param {FuturesApiCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createMultiAssetsMarginV1(requestParameters: FuturesApiCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMultiAssetsMarginV1Resp>;

    /**
     * Testing order request, this order will not be submitted to matching engine
     * @summary Test Order(TRADE)
     * @param {FuturesApiCreateOrderTestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createOrderTestV1(requestParameters: FuturesApiCreateOrderTestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderTestV1Resp>;

    /**
     * Send in a new order.
     * @summary New Order(TRADE)
     * @param {FuturesApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createOrderV1(requestParameters: FuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderV1Resp>;

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {FuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createPositionMarginV1(requestParameters: FuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionMarginV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {FuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    createPositionSideDualV1(requestParameters: FuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionSideDualV1Resp>;

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders (TRADE)
     * @param {FuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    deleteAllOpenOrdersV1(requestParameters: FuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp>;

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders (TRADE)
     * @param {FuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    deleteBatchOrdersV1(requestParameters: FuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>>;

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {FuturesApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    deleteOrderV1(requestParameters: FuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp>;

    /**
     * Query account configuration
     * @summary Futures Account Configuration(USER_DATA)
     * @param {FuturesApiGetAccountConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAccountConfigV1(requestParameters: FuturesApiGetAccountConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountConfigV1Resp>;

    /**
     * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
     * @summary Account Information V2(USER_DATA)
     * @param {FuturesApiGetAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAccountV2(requestParameters: FuturesApiGetAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV2Resp>;

    /**
     * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
     * @summary Account Information V3(USER_DATA)
     * @param {FuturesApiGetAccountV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAccountV3(requestParameters: FuturesApiGetAccountV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV3Resp>;

    /**
     * Position ADL Quantile Estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {FuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAdlQuantileV1(requestParameters: FuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAdlQuantileV1RespItem>>;

    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {FuturesApiGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAggTradesV1(requestParameters: FuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>>;

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {FuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAllOrdersV1(requestParameters: FuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV1RespItem>>;

    /**
     * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
     * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
     * @param {FuturesApiGetApiTradingStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getApiTradingStatusV1(requestParameters: FuturesApiGetApiTradingStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetApiTradingStatusV1Resp>;

    /**
     * asset index for Multi-Assets mode
     * @summary Multi-Assets Mode Asset Index
     * @param {FuturesApiGetAssetIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getAssetIndexV1(requestParameters?: FuturesApiGetAssetIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetAssetIndexV1Resp>;

    /**
     * Query account balance info
     * @summary Futures Account Balance V2 (USER_DATA)
     * @param {FuturesApiGetBalanceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getBalanceV2(requestParameters: FuturesApiGetBalanceV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV2RespItem>>;

    /**
     * Query account balance info
     * @summary Futures Account Balance V3 (USER_DATA)
     * @param {FuturesApiGetBalanceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getBalanceV3(requestParameters: FuturesApiGetBalanceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV3RespItem>>;

    /**
     * Get User Commission Rate
     * @summary User Commission Rate (USER_DATA)
     * @param {FuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getCommissionRateV1(requestParameters: FuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCommissionRateV1Resp>;

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {FuturesApiGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getConstituentsV1(requestParameters: FuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConstituentsV1Resp>;

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {FuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getContinuousKlinesV1(requestParameters: FuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query for all convertible token pairs and the tokens’ respective upper/lower limits
     * @summary List All Convert Pairs
     * @param {FuturesApiGetConvertExchangeInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getConvertExchangeInfoV1(requestParameters?: FuturesApiGetConvertExchangeInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetConvertExchangeInfoV1RespItem>>;

    /**
     * Query order status by order ID.
     * @summary Order status(USER_DATA)
     * @param {FuturesApiGetConvertOrderStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getConvertOrderStatusV1(requestParameters?: FuturesApiGetConvertOrderStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConvertOrderStatusV1Resp>;

    /**
     * Query symbol orderbook
     * @summary Order Book
     * @param {FuturesApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getDepthV1(requestParameters: FuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp>;

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetExchangeInfoV1Resp>;

    /**
     * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
     * @summary Get BNB Burn Status (USER_DATA)
     * @param {FuturesApiGetFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFeeBurnV1(requestParameters: FuturesApiGetFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetFeeBurnV1Resp>;

    /**
     * Query user\'s Force Orders
     * @summary User\'s Force Orders (USER_DATA)
     * @param {FuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getForceOrdersV1(requestParameters: FuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetForceOrdersV1RespItem>>;

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingInfoV1RespItem>>;

    /**
     * Get Funding Rate History
     * @summary Get Funding Rate History
     * @param {FuturesApiGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFundingRateV1(requestParameters?: FuturesApiGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingRateV1RespItem>>;

    /**
     * Query future basis
     * @summary Basis
     * @param {FuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataBasis(requestParameters: FuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataBasisRespItem>>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Quarterly Contract Settlement Price
     * @param {FuturesApiGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataDeliveryPrice(requestParameters: FuturesApiGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>>;

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataGlobalLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>>;

    /**
     * Open Interest Statistics
     * @summary Open Interest Statistics
     * @param {FuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataOpenInterestHist(requestParameters: FuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>>;

    /**
     * Taker Buy/Sell Volume
     * @summary Taker Buy/Sell Volume
     * @param {FuturesApiGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataTakerlongshortRatio(requestParameters: FuturesApiGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTakerlongshortRatioRespItem>>;

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {FuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataTopLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>>;

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {FuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getFuturesDataTopLongShortPositionRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>>;

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {FuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getHistoricalTradesV1(requestParameters: FuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>>;

    /**
     * Get futures transaction history download link by Id
     * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
     * @param {FuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getIncomeAsynIdV1(requestParameters: FuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp>;

    /**
     * Get download id for futures transaction history
     * @summary Get Download Id For Futures Transaction History(USER_DATA)
     * @param {FuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getIncomeAsynV1(requestParameters: FuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp>;

    /**
     * Query composite index symbol information
     * @summary Composite Index Symbol Information
     * @param {FuturesApiGetIndexInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getIndexInfoV1(requestParameters?: FuturesApiGetIndexInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIndexInfoV1RespItem>>;

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {FuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getIndexPriceKlinesV1(requestParameters: FuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {FuturesApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getKlinesV1(requestParameters: FuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query user notional and leverage bracket on speicfic symbol
     * @summary Notional and Leverage Brackets (USER_DATA)
     * @param {FuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getLeverageBracketV1(requestParameters: FuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetLeverageBracketV1Resp>;

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {FuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getMarkPriceKlinesV1(requestParameters: FuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Get Current Multi-Assets Mode (USER_DATA)
     * @param {FuturesApiGetMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getMultiAssetsMarginV1(requestParameters: FuturesApiGetMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMultiAssetsMarginV1Resp>;

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {FuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOpenInterestV1(requestParameters: FuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenInterestV1Resp>;

    /**
     * Query open order
     * @summary Query Current Open Order (USER_DATA)
     * @param {FuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOpenOrderV1(requestParameters: FuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {FuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOpenOrdersV1(requestParameters: FuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {FuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOrderAmendmentV1(requestParameters: FuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOrderAmendmentV1RespItem>>;

    /**
     * Get futures order history download link by Id
     * @summary Get Futures Order History Download Link by Id (USER_DATA)
     * @param {FuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOrderAsynIdV1(requestParameters: FuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynIdV1Resp>;

    /**
     * Get Download Id For Futures Order History
     * @summary Get Download Id For Futures Order History (USER_DATA)
     * @param {FuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOrderAsynV1(requestParameters: FuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOrderAsynV1Resp>;

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {FuturesApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getOrderV1(requestParameters: FuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Get Classic Portfolio Margin current account information.
     * @summary Classic Portfolio Margin Account Information (USER_DATA)
     * @param {FuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPmAccountInfoV1(requestParameters: FuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPmAccountInfoV1Resp>;

    /**
     * Get Position Margin Change History
     * @summary Get Position Margin Change History (TRADE)
     * @param {FuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPositionMarginHistoryV1(requestParameters: FuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>>;

    /**
     * Get current position information.
     * @summary Position Information V2 (USER_DATA)
     * @param {FuturesApiGetPositionRiskV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPositionRiskV2(requestParameters: FuturesApiGetPositionRiskV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV2RespItem>>;

    /**
     * Get current position information(only symbol that has position or open orders will be returned).
     * @summary Position Information V3 (USER_DATA)
     * @param {FuturesApiGetPositionRiskV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPositionRiskV3(requestParameters: FuturesApiGetPositionRiskV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV3RespItem>>;

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Get Current Position Mode(USER_DATA)
     * @param {FuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPositionSideDualV1(requestParameters: FuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPositionSideDualV1Resp>;

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {FuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPremiumIndexKlinesV1(requestParameters: FuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Mark Price and Funding Rate
     * @summary Mark Price
     * @param {FuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getPremiumIndexV1(requestParameters?: FuturesApiGetPremiumIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetPremiumIndexV1Resp>;

    /**
     * Query User Rate Limit
     * @summary Query User Rate Limit (USER_DATA)
     * @param {FuturesApiGetRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getRateLimitOrderV1(requestParameters: FuturesApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRateLimitOrderV1RespItem>>;

    /**
     * Get current account symbol configuration.
     * @summary Symbol Configuration(USER_DATA)
     * @param {FuturesApiGetSymbolConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getSymbolConfigV1(requestParameters: FuturesApiGetSymbolConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetSymbolConfigV1RespItem>>;

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
     * @summary 24hr Ticker Price Change Statistics
     * @param {FuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTicker24hrV1(requestParameters?: FuturesApiGetTicker24hrV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTicker24hrV1Resp>;

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {FuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTickerBookTickerV1(requestParameters?: FuturesApiGetTickerBookTickerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerBookTickerV1Resp>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {FuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTickerPriceV1(requestParameters?: FuturesApiGetTickerPriceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV1Resp>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker V2
     * @param {FuturesApiGetTickerPriceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTickerPriceV2(requestParameters?: FuturesApiGetTickerPriceV2Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV2Resp>;

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp>;

    /**
     * Get futures trade download link by Id
     * @summary Get Futures Trade Download Link by Id(USER_DATA)
     * @param {FuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTradeAsynIdV1(requestParameters: FuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynIdV1Resp>;

    /**
     * Get download id for futures trade history
     * @summary Get Download Id For Futures Trade History (USER_DATA)
     * @param {FuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTradeAsynV1(requestParameters: FuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynV1Resp>;

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {FuturesApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getTradesV1(requestParameters: FuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {FuturesApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    getUserTradesV1(requestParameters: FuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>>;

    /**
     * Modify Multiple Orders (TRADE)
     * @summary Modify Multiple Orders(TRADE)
     * @param {FuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    updateBatchOrdersV1(requestParameters: FuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>>;

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<UpdateListenKeyV1Resp>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {FuturesApiUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApiInterface
     */
    updateOrderV1(requestParameters: FuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderV1Resp>;

}

/**
 * Request parameters for createBatchOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateBatchOrdersV1Request
 */
export interface FuturesApiCreateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>}
     * @memberof FuturesApiCreateBatchOrdersV1
     */
    readonly batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createConvertAcceptQuoteV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateConvertAcceptQuoteV1Request
 */
export interface FuturesApiCreateConvertAcceptQuoteV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateConvertAcceptQuoteV1
     */
    readonly quoteId: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateConvertAcceptQuoteV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateConvertAcceptQuoteV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createConvertGetQuoteV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateConvertGetQuoteV1Request
 */
export interface FuturesApiCreateConvertGetQuoteV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateConvertGetQuoteV1
     */
    readonly fromAsset: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateConvertGetQuoteV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateConvertGetQuoteV1
     */
    readonly toAsset: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateConvertGetQuoteV1
     */
    readonly fromAmount?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateConvertGetQuoteV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateConvertGetQuoteV1
     */
    readonly toAmount?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateConvertGetQuoteV1
     */
    readonly validTime?: string
}

/**
 * Request parameters for createCountdownCancelAllV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateCountdownCancelAllV1Request
 */
export interface FuturesApiCreateCountdownCancelAllV1Request {
    /**
     * 
     * @type {UmfuturesCreateCountdownCancelAllV1Req}
     * @memberof FuturesApiCreateCountdownCancelAllV1
     */
    readonly umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req
}

/**
 * Request parameters for createFeeBurnV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateFeeBurnV1Request
 */
export interface FuturesApiCreateFeeBurnV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateFeeBurnV1
     */
    readonly feeBurn: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateFeeBurnV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateFeeBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createLeverageV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateLeverageV1Request
 */
export interface FuturesApiCreateLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginTypeV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateMarginTypeV1Request
 */
export interface FuturesApiCreateMarginTypeV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateMarginTypeV1
     */
    readonly marginType: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateMarginTypeV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateMarginTypeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateMarginTypeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMultiAssetsMarginV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateMultiAssetsMarginV1Request
 */
export interface FuturesApiCreateMultiAssetsMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateMultiAssetsMarginV1
     */
    readonly multiAssetsMargin: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateMultiAssetsMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateMultiAssetsMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createOrderTestV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateOrderTestV1Request
 */
export interface FuturesApiCreateOrderTestV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderTestV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for createOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreateOrderV1Request
 */
export interface FuturesApiCreateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreateOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for createPositionMarginV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreatePositionMarginV1Request
 */
export interface FuturesApiCreatePositionMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly type: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createPositionSideDualV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiCreatePositionSideDualV1Request
 */
export interface FuturesApiCreatePositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiCreatePositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiCreatePositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteAllOpenOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiDeleteAllOpenOrdersV1Request
 */
export interface FuturesApiDeleteAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiDeleteAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteBatchOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiDeleteBatchOrdersV1Request
 */
export interface FuturesApiDeleteBatchOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * max length 10 &lt;br/&gt; e.g. [1234567,2345678]
     * @type {Array<number>}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly orderIdList?: Array<number>

    /**
     * max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
     * @type {Array<string>}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly origClientOrderIdList?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiDeleteOrderV1Request
 */
export interface FuturesApiDeleteOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiDeleteOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountConfigV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAccountConfigV1Request
 */
export interface FuturesApiGetAccountConfigV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAccountConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAccountConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountV2 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAccountV2Request
 */
export interface FuturesApiGetAccountV2Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAccountV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAccountV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountV3 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAccountV3Request
 */
export interface FuturesApiGetAccountV3Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAccountV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAccountV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAdlQuantileV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAdlQuantileV1Request
 */
export interface FuturesApiGetAdlQuantileV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAdlQuantileV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetAdlQuantileV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAdlQuantileV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAggTradesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAggTradesV1Request
 */
export interface FuturesApiGetAggTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly symbol: string

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly fromId?: number

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof FuturesApiGetAggTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getAllOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAllOrdersV1Request
 */
export interface FuturesApiGetAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getApiTradingStatusV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetApiTradingStatusV1Request
 */
export interface FuturesApiGetApiTradingStatusV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetApiTradingStatusV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetApiTradingStatusV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetApiTradingStatusV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAssetIndexV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetAssetIndexV1Request
 */
export interface FuturesApiGetAssetIndexV1Request {
    /**
     * Asset pair
     * @type {string}
     * @memberof FuturesApiGetAssetIndexV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getBalanceV2 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetBalanceV2Request
 */
export interface FuturesApiGetBalanceV2Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetBalanceV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetBalanceV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBalanceV3 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetBalanceV3Request
 */
export interface FuturesApiGetBalanceV3Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetBalanceV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetBalanceV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCommissionRateV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetCommissionRateV1Request
 */
export interface FuturesApiGetCommissionRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetCommissionRateV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetCommissionRateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetCommissionRateV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getConstituentsV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetConstituentsV1Request
 */
export interface FuturesApiGetConstituentsV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetConstituentsV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getContinuousKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetContinuousKlinesV1Request
 */
export interface FuturesApiGetContinuousKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly contractType: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetContinuousKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getConvertExchangeInfoV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetConvertExchangeInfoV1Request
 */
export interface FuturesApiGetConvertExchangeInfoV1Request {
    /**
     * User spends coin
     * @type {string}
     * @memberof FuturesApiGetConvertExchangeInfoV1
     */
    readonly fromAsset?: string

    /**
     * User receives coin
     * @type {string}
     * @memberof FuturesApiGetConvertExchangeInfoV1
     */
    readonly toAsset?: string
}

/**
 * Request parameters for getConvertOrderStatusV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetConvertOrderStatusV1Request
 */
export interface FuturesApiGetConvertOrderStatusV1Request {
    /**
     * Either orderId or quoteId is required
     * @type {string}
     * @memberof FuturesApiGetConvertOrderStatusV1
     */
    readonly orderId?: string

    /**
     * Either orderId or quoteId is required
     * @type {string}
     * @memberof FuturesApiGetConvertOrderStatusV1
     */
    readonly quoteId?: string
}

/**
 * Request parameters for getDepthV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetDepthV1Request
 */
export interface FuturesApiGetDepthV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetDepthV1
     */
    readonly symbol: string

    /**
     * Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
     * @type {number}
     * @memberof FuturesApiGetDepthV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getFeeBurnV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFeeBurnV1Request
 */
export interface FuturesApiGetFeeBurnV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFeeBurnV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFeeBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getForceOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetForceOrdersV1Request
 */
export interface FuturesApiGetForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
     * @type {string}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getFundingRateV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFundingRateV1Request
 */
export interface FuturesApiGetFundingRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetFundingRateV1
     */
    readonly symbol?: string

    /**
     * Timestamp in ms to get funding rate from INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetFundingRateV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding rate  until INCLUSIVE.
     * @type {number}
     * @memberof FuturesApiGetFundingRateV1
     */
    readonly endTime?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof FuturesApiGetFundingRateV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getFuturesDataBasis operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataBasisRequest
 */
export interface FuturesApiGetFuturesDataBasisRequest {
    /**
     * BTCUSDT
     * @type {string}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly pair: string

    /**
     * CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly limit: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataBasis
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataDeliveryPrice operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataDeliveryPriceRequest
 */
export interface FuturesApiGetFuturesDataDeliveryPriceRequest {
    /**
     * e.g BTCUSDT
     * @type {string}
     * @memberof FuturesApiGetFuturesDataDeliveryPrice
     */
    readonly pair: string
}

/**
 * Request parameters for getFuturesDataGlobalLongShortAccountRatio operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest
 */
export interface FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataOpenInterestHist operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataOpenInterestHistRequest
 */
export interface FuturesApiGetFuturesDataOpenInterestHistRequest {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataOpenInterestHist
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTakerlongshortRatio operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataTakerlongshortRatioRequest
 */
export interface FuturesApiGetFuturesDataTakerlongshortRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTopLongShortAccountRatio operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataTopLongShortAccountRatioRequest
 */
export interface FuturesApiGetFuturesDataTopLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTopLongShortPositionRatio operation in FuturesApi.
 * @export
 * @interface FuturesApiGetFuturesDataTopLongShortPositionRatioRequest
 */
export interface FuturesApiGetFuturesDataTopLongShortPositionRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getHistoricalTradesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetHistoricalTradesV1Request
 */
export interface FuturesApiGetHistoricalTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetHistoricalTradesV1
     */
    readonly symbol: string

    /**
     * Default 100; max 500.
     * @type {number}
     * @memberof FuturesApiGetHistoricalTradesV1
     */
    readonly limit?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof FuturesApiGetHistoricalTradesV1
     */
    readonly fromId?: number
}

/**
 * Request parameters for getIncomeAsynIdV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetIncomeAsynIdV1Request
 */
export interface FuturesApiGetIncomeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof FuturesApiGetIncomeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIncomeAsynV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetIncomeAsynV1Request
 */
export interface FuturesApiGetIncomeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIncomeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIndexInfoV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetIndexInfoV1Request
 */
export interface FuturesApiGetIndexInfoV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetIndexInfoV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getIndexPriceKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetIndexPriceKlinesV1Request
 */
export interface FuturesApiGetIndexPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetIndexPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetKlinesV1Request
 */
export interface FuturesApiGetKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getLeverageBracketV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetLeverageBracketV1Request
 */
export interface FuturesApiGetLeverageBracketV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetLeverageBracketV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetLeverageBracketV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetLeverageBracketV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarkPriceKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetMarkPriceKlinesV1Request
 */
export interface FuturesApiGetMarkPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetMarkPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getMultiAssetsMarginV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetMultiAssetsMarginV1Request
 */
export interface FuturesApiGetMultiAssetsMarginV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetMultiAssetsMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetMultiAssetsMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenInterestV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOpenInterestV1Request
 */
export interface FuturesApiGetOpenInterestV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenInterestV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getOpenOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOpenOrderV1Request
 */
export interface FuturesApiGetOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOpenOrdersV1Request
 */
export interface FuturesApiGetOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAmendmentV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOrderAmendmentV1Request
 */
export interface FuturesApiGetOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAsynIdV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOrderAsynIdV1Request
 */
export interface FuturesApiGetOrderAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof FuturesApiGetOrderAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAsynV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOrderAsynV1Request
 */
export interface FuturesApiGetOrderAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetOrderAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetOrderAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetOrderV1Request
 */
export interface FuturesApiGetOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPmAccountInfoV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPmAccountInfoV1Request
 */
export interface FuturesApiGetPmAccountInfoV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPmAccountInfoV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPmAccountInfoV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPmAccountInfoV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionMarginHistoryV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPositionMarginHistoryV1Request
 */
export interface FuturesApiGetPositionMarginHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly timestamp: number

    /**
     * 1: Add position margin，2: Reduce position margin
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly type?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly startTime?: number

    /**
     * Default current time if not pass
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly endTime?: number

    /**
     * Default: 500
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionMarginHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionRiskV2 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPositionRiskV2Request
 */
export interface FuturesApiGetPositionRiskV2Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionRiskV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPositionRiskV2
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionRiskV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionRiskV3 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPositionRiskV3Request
 */
export interface FuturesApiGetPositionRiskV3Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionRiskV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPositionRiskV3
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionRiskV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionSideDualV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPositionSideDualV1Request
 */
export interface FuturesApiGetPositionSideDualV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPremiumIndexKlinesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPremiumIndexKlinesV1Request
 */
export interface FuturesApiGetPremiumIndexKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof FuturesApiGetPremiumIndexKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getPremiumIndexV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetPremiumIndexV1Request
 */
export interface FuturesApiGetPremiumIndexV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetPremiumIndexV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getRateLimitOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetRateLimitOrderV1Request
 */
export interface FuturesApiGetRateLimitOrderV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetRateLimitOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetRateLimitOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getSymbolConfigV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetSymbolConfigV1Request
 */
export interface FuturesApiGetSymbolConfigV1Request {
    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetSymbolConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetSymbolConfigV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetSymbolConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTicker24hrV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTicker24hrV1Request
 */
export interface FuturesApiGetTicker24hrV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTicker24hrV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTickerBookTickerV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTickerBookTickerV1Request
 */
export interface FuturesApiGetTickerBookTickerV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTickerBookTickerV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTickerPriceV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTickerPriceV1Request
 */
export interface FuturesApiGetTickerPriceV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTickerPriceV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTickerPriceV2 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTickerPriceV2Request
 */
export interface FuturesApiGetTickerPriceV2Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTickerPriceV2
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTradeAsynIdV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTradeAsynIdV1Request
 */
export interface FuturesApiGetTradeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof FuturesApiGetTradeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetTradeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetTradeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTradeAsynV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTradeAsynV1Request
 */
export interface FuturesApiGetTradeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetTradeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof FuturesApiGetTradeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetTradeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetTradeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTradesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetTradesV1Request
 */
export interface FuturesApiGetTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetTradesV1
     */
    readonly symbol: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof FuturesApiGetTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getUserTradesV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiGetUserTradesV1Request
 */
export interface FuturesApiGetUserTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly timestamp: number

    /**
     * This can only be used in combination with &#x60;symbol&#x60;
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiGetUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateBatchOrdersV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiUpdateBatchOrdersV1Request
 */
export interface FuturesApiUpdateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>}
     * @memberof FuturesApiUpdateBatchOrdersV1
     */
    readonly batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateOrderV1 operation in FuturesApi.
 * @export
 * @interface FuturesApiUpdateOrderV1Request
 */
export interface FuturesApiUpdateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {number}
     * @memberof FuturesApiUpdateOrderV1
     */
    readonly recvWindow?: number
}

/**
 * FuturesApi - object-oriented interface
 * @export
 * @class FuturesApi
 * @extends {BaseAPI}
 */
export class FuturesApi extends BaseAPI implements FuturesApiInterface {
    /**
     * Place Multiple Orders
     * @summary Place Multiple Orders(TRADE)
     * @param {FuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createBatchOrdersV1(requestParameters: FuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept the offered quote by quote ID.
     * @summary Accept the offered quote (USER_DATA)
     * @param {FuturesApiCreateConvertAcceptQuoteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createConvertAcceptQuoteV1(requestParameters: FuturesApiCreateConvertAcceptQuoteV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createConvertAcceptQuoteV1(requestParameters.quoteId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a quote for the requested token pairs
     * @summary Send Quote Request(USER_DATA)
     * @param {FuturesApiCreateConvertGetQuoteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createConvertGetQuoteV1(requestParameters: FuturesApiCreateConvertGetQuoteV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createConvertGetQuoteV1(requestParameters.fromAsset, requestParameters.timestamp, requestParameters.toAsset, requestParameters.fromAmount, requestParameters.recvWindow, requestParameters.toAmount, requestParameters.validTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {FuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createCountdownCancelAllV1(requestParameters: FuturesApiCreateCountdownCancelAllV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createCountdownCancelAllV1(requestParameters.umfuturesCreateCountdownCancelAllV1Req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
     * @summary Toggle BNB Burn On Futures Trade (TRADE)
     * @param {FuturesApiCreateFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createFeeBurnV1(requestParameters: FuturesApiCreateFeeBurnV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createFeeBurnV1(requestParameters.feeBurn, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage of specific symbol market.
     * @summary Change Initial Leverage(TRADE)
     * @param {FuturesApiCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createLeverageV1(requestParameters: FuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createListenKeyV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change symbol level margin type
     * @summary Change Margin Type(TRADE)
     * @param {FuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createMarginTypeV1(requestParameters: FuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Change Multi-Assets Mode (TRADE)
     * @param {FuturesApiCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createMultiAssetsMarginV1(requestParameters: FuturesApiCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createMultiAssetsMarginV1(requestParameters.multiAssetsMargin, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Testing order request, this order will not be submitted to matching engine
     * @summary Test Order(TRADE)
     * @param {FuturesApiCreateOrderTestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createOrderTestV1(requestParameters: FuturesApiCreateOrderTestV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createOrderTestV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new order.
     * @summary New Order(TRADE)
     * @param {FuturesApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createOrderV1(requestParameters: FuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {FuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createPositionMarginV1(requestParameters: FuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createPositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {FuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public createPositionSideDualV1(requestParameters: FuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).createPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders (TRADE)
     * @param {FuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public deleteAllOpenOrdersV1(requestParameters: FuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders (TRADE)
     * @param {FuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public deleteBatchOrdersV1(requestParameters: FuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public deleteListenKeyV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).deleteListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {FuturesApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public deleteOrderV1(requestParameters: FuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account configuration
     * @summary Futures Account Configuration(USER_DATA)
     * @param {FuturesApiGetAccountConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAccountConfigV1(requestParameters: FuturesApiGetAccountConfigV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAccountConfigV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
     * @summary Account Information V2(USER_DATA)
     * @param {FuturesApiGetAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAccountV2(requestParameters: FuturesApiGetAccountV2Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAccountV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
     * @summary Account Information V3(USER_DATA)
     * @param {FuturesApiGetAccountV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAccountV3(requestParameters: FuturesApiGetAccountV3Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAccountV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Position ADL Quantile Estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {FuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAdlQuantileV1(requestParameters: FuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {FuturesApiGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAggTradesV1(requestParameters: FuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {FuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAllOrdersV1(requestParameters: FuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
     * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
     * @param {FuturesApiGetApiTradingStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getApiTradingStatusV1(requestParameters: FuturesApiGetApiTradingStatusV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getApiTradingStatusV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * asset index for Multi-Assets mode
     * @summary Multi-Assets Mode Asset Index
     * @param {FuturesApiGetAssetIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getAssetIndexV1(requestParameters: FuturesApiGetAssetIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getAssetIndexV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account balance info
     * @summary Futures Account Balance V2 (USER_DATA)
     * @param {FuturesApiGetBalanceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getBalanceV2(requestParameters: FuturesApiGetBalanceV2Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getBalanceV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account balance info
     * @summary Futures Account Balance V3 (USER_DATA)
     * @param {FuturesApiGetBalanceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getBalanceV3(requestParameters: FuturesApiGetBalanceV3Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getBalanceV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get User Commission Rate
     * @summary User Commission Rate (USER_DATA)
     * @param {FuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getCommissionRateV1(requestParameters: FuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {FuturesApiGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getConstituentsV1(requestParameters: FuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getConstituentsV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {FuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getContinuousKlinesV1(requestParameters: FuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for all convertible token pairs and the tokens’ respective upper/lower limits
     * @summary List All Convert Pairs
     * @param {FuturesApiGetConvertExchangeInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getConvertExchangeInfoV1(requestParameters: FuturesApiGetConvertExchangeInfoV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getConvertExchangeInfoV1(requestParameters.fromAsset, requestParameters.toAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query order status by order ID.
     * @summary Order status(USER_DATA)
     * @param {FuturesApiGetConvertOrderStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getConvertOrderStatusV1(requestParameters: FuturesApiGetConvertOrderStatusV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getConvertOrderStatusV1(requestParameters.orderId, requestParameters.quoteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol orderbook
     * @summary Order Book
     * @param {FuturesApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getDepthV1(requestParameters: FuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getExchangeInfoV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getExchangeInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
     * @summary Get BNB Burn Status (USER_DATA)
     * @param {FuturesApiGetFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFeeBurnV1(requestParameters: FuturesApiGetFeeBurnV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFeeBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user\'s Force Orders
     * @summary User\'s Force Orders (USER_DATA)
     * @param {FuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getForceOrdersV1(requestParameters: FuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFundingInfoV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFundingInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Funding Rate History
     * @summary Get Funding Rate History
     * @param {FuturesApiGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFundingRateV1(requestParameters: FuturesApiGetFundingRateV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query future basis
     * @summary Basis
     * @param {FuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataBasis(requestParameters: FuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Quarterly Contract Settlement Price
     * @param {FuturesApiGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataDeliveryPrice(requestParameters: FuturesApiGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataDeliveryPrice(requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataGlobalLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataGlobalLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Open Interest Statistics
     * @summary Open Interest Statistics
     * @param {FuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataOpenInterestHist(requestParameters: FuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataOpenInterestHist(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Taker Buy/Sell Volume
     * @summary Taker Buy/Sell Volume
     * @param {FuturesApiGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataTakerlongshortRatio(requestParameters: FuturesApiGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataTakerlongshortRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {FuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataTopLongShortAccountRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {FuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getFuturesDataTopLongShortPositionRatio(requestParameters: FuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getFuturesDataTopLongShortPositionRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {FuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getHistoricalTradesV1(requestParameters: FuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures transaction history download link by Id
     * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
     * @param {FuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getIncomeAsynIdV1(requestParameters: FuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for futures transaction history
     * @summary Get Download Id For Futures Transaction History(USER_DATA)
     * @param {FuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getIncomeAsynV1(requestParameters: FuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query composite index symbol information
     * @summary Composite Index Symbol Information
     * @param {FuturesApiGetIndexInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getIndexInfoV1(requestParameters: FuturesApiGetIndexInfoV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getIndexInfoV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {FuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getIndexPriceKlinesV1(requestParameters: FuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {FuturesApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getKlinesV1(requestParameters: FuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user notional and leverage bracket on speicfic symbol
     * @summary Notional and Leverage Brackets (USER_DATA)
     * @param {FuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getLeverageBracketV1(requestParameters: FuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {FuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getMarkPriceKlinesV1(requestParameters: FuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Get Current Multi-Assets Mode (USER_DATA)
     * @param {FuturesApiGetMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getMultiAssetsMarginV1(requestParameters: FuturesApiGetMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getMultiAssetsMarginV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {FuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOpenInterestV1(requestParameters: FuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOpenInterestV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query open order
     * @summary Query Current Open Order (USER_DATA)
     * @param {FuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOpenOrderV1(requestParameters: FuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {FuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOpenOrdersV1(requestParameters: FuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {FuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOrderAmendmentV1(requestParameters: FuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures order history download link by Id
     * @summary Get Futures Order History Download Link by Id (USER_DATA)
     * @param {FuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOrderAsynIdV1(requestParameters: FuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Download Id For Futures Order History
     * @summary Get Download Id For Futures Order History (USER_DATA)
     * @param {FuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOrderAsynV1(requestParameters: FuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {FuturesApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getOrderV1(requestParameters: FuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPingV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Classic Portfolio Margin current account information.
     * @summary Classic Portfolio Margin Account Information (USER_DATA)
     * @param {FuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPmAccountInfoV1(requestParameters: FuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPmAccountInfoV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Position Margin Change History
     * @summary Get Position Margin Change History (TRADE)
     * @param {FuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPositionMarginHistoryV1(requestParameters: FuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current position information.
     * @summary Position Information V2 (USER_DATA)
     * @param {FuturesApiGetPositionRiskV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPositionRiskV2(requestParameters: FuturesApiGetPositionRiskV2Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPositionRiskV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current position information(only symbol that has position or open orders will be returned).
     * @summary Position Information V3 (USER_DATA)
     * @param {FuturesApiGetPositionRiskV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPositionRiskV3(requestParameters: FuturesApiGetPositionRiskV3Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPositionRiskV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Get Current Position Mode(USER_DATA)
     * @param {FuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPositionSideDualV1(requestParameters: FuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {FuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPremiumIndexKlinesV1(requestParameters: FuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark Price and Funding Rate
     * @summary Mark Price
     * @param {FuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getPremiumIndexV1(requestParameters: FuturesApiGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getPremiumIndexV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query User Rate Limit
     * @summary Query User Rate Limit (USER_DATA)
     * @param {FuturesApiGetRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getRateLimitOrderV1(requestParameters: FuturesApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getRateLimitOrderV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account symbol configuration.
     * @summary Symbol Configuration(USER_DATA)
     * @param {FuturesApiGetSymbolConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getSymbolConfigV1(requestParameters: FuturesApiGetSymbolConfigV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getSymbolConfigV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
     * @summary 24hr Ticker Price Change Statistics
     * @param {FuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTicker24hrV1(requestParameters: FuturesApiGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTicker24hrV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {FuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTickerBookTickerV1(requestParameters: FuturesApiGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTickerBookTickerV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {FuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTickerPriceV1(requestParameters: FuturesApiGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTickerPriceV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker V2
     * @param {FuturesApiGetTickerPriceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTickerPriceV2(requestParameters: FuturesApiGetTickerPriceV2Request = {}, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTickerPriceV2(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTimeV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTimeV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures trade download link by Id
     * @summary Get Futures Trade Download Link by Id(USER_DATA)
     * @param {FuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTradeAsynIdV1(requestParameters: FuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for futures trade history
     * @summary Get Download Id For Futures Trade History (USER_DATA)
     * @param {FuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTradeAsynV1(requestParameters: FuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {FuturesApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getTradesV1(requestParameters: FuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {FuturesApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public getUserTradesV1(requestParameters: FuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).getUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Multiple Orders (TRADE)
     * @summary Modify Multiple Orders(TRADE)
     * @param {FuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public updateBatchOrdersV1(requestParameters: FuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).updateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public updateListenKeyV1(options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).updateListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {FuturesApiUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuturesApi
     */
    public updateOrderV1(requestParameters: FuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig) {
        return FuturesApiFp(this.configuration).updateOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

