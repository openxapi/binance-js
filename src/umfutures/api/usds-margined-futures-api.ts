/* tslint:disable */
/* eslint-disable */
/**
 * Binance USD-M Futures API
 * OpenAPI specification for Binance exchange - Umfutures API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setBinanceAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { APIError } from '../model';
// @ts-ignore
import type { CreateConvertAcceptQuoteV1Resp } from '../model';
// @ts-ignore
import type { CreateConvertGetQuoteV1Resp } from '../model';
// @ts-ignore
import type { CreateFeeBurnV1Resp } from '../model';
// @ts-ignore
import type { CreateLeverageV1Resp } from '../model';
// @ts-ignore
import type { CreateListenKeyV1Resp } from '../model';
// @ts-ignore
import type { CreateMarginTypeV1Resp } from '../model';
// @ts-ignore
import type { CreateMultiAssetsMarginV1Resp } from '../model';
// @ts-ignore
import type { CreateOrderTestV1Resp } from '../model';
// @ts-ignore
import type { CreateOrderV1Resp } from '../model';
// @ts-ignore
import type { CreatePositionMarginV1Resp } from '../model';
// @ts-ignore
import type { CreatePositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { DeleteAllOpenOrdersV1Resp } from '../model';
// @ts-ignore
import type { DeleteOrderV1Resp } from '../model';
// @ts-ignore
import type { GetAccountConfigV1Resp } from '../model';
// @ts-ignore
import type { GetAccountV2Resp } from '../model';
// @ts-ignore
import type { GetAccountV3Resp } from '../model';
// @ts-ignore
import type { GetAdlQuantileV1RespItem } from '../model';
// @ts-ignore
import type { GetAllOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetBalanceV2RespItem } from '../model';
// @ts-ignore
import type { GetBalanceV3RespItem } from '../model';
// @ts-ignore
import type { GetCommissionRateV1Resp } from '../model';
// @ts-ignore
import type { GetConstituentsV1Resp } from '../model';
// @ts-ignore
import type { GetConvertExchangeInfoV1RespItem } from '../model';
// @ts-ignore
import type { GetConvertOrderStatusV1Resp } from '../model';
// @ts-ignore
import type { GetDepthV1Resp } from '../model';
// @ts-ignore
import type { GetFeeBurnV1Resp } from '../model';
// @ts-ignore
import type { GetForceOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetFundingInfoV1RespItem } from '../model';
// @ts-ignore
import type { GetFundingRateV1RespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataBasisRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataGlobalLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataOpenInterestHistRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTakerlongshortRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTopLongShortAccountRatioRespItem } from '../model';
// @ts-ignore
import type { GetFuturesDataTopLongShortPositionRatioRespItem } from '../model';
// @ts-ignore
import type { GetHistoricalTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetIncomeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetIncomeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetIndexInfoV1RespItem } from '../model';
// @ts-ignore
import type { GetMultiAssetsMarginV1Resp } from '../model';
// @ts-ignore
import type { GetOpenInterestV1Resp } from '../model';
// @ts-ignore
import type { GetOpenOrderV1Resp } from '../model';
// @ts-ignore
import type { GetOpenOrdersV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderAmendmentV1RespItem } from '../model';
// @ts-ignore
import type { GetOrderAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetOrderV1Resp } from '../model';
// @ts-ignore
import type { GetPmAccountInfoV1Resp } from '../model';
// @ts-ignore
import type { GetPositionMarginHistoryV1RespItem } from '../model';
// @ts-ignore
import type { GetPositionRiskV2RespItem } from '../model';
// @ts-ignore
import type { GetPositionRiskV3RespItem } from '../model';
// @ts-ignore
import type { GetPositionSideDualV1Resp } from '../model';
// @ts-ignore
import type { GetRateLimitOrderV1RespItem } from '../model';
// @ts-ignore
import type { GetSymbolConfigV1RespItem } from '../model';
// @ts-ignore
import type { GetTimeV1Resp } from '../model';
// @ts-ignore
import type { GetTradeAsynIdV1Resp } from '../model';
// @ts-ignore
import type { GetTradeAsynV1Resp } from '../model';
// @ts-ignore
import type { GetTradesV1RespItem } from '../model';
// @ts-ignore
import type { GetUserTradesV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { UmfuturesCreateBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { UmfuturesCreateCountdownCancelAllV1Req } from '../model';
// @ts-ignore
import type { UmfuturesCreateCountdownCancelAllV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesDeleteBatchOrdersV1RespInner } from '../model';
// @ts-ignore
import type { UmfuturesGetAggTradesV1RespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetApiTradingStatusV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetAssetIndexV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetContinuousKlinesV1RespInnerInner } from '../model';
// @ts-ignore
import type { UmfuturesGetExchangeInfoV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetFuturesDataDeliveryPriceRespItem } from '../model';
// @ts-ignore
import type { UmfuturesGetLeverageBracketV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetOrderAsynV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetPremiumIndexV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTicker24hrV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerBookTickerV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerPriceV1Resp } from '../model';
// @ts-ignore
import type { UmfuturesGetTickerPriceV2Resp } from '../model';
// @ts-ignore
import type { UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem } from '../model';
// @ts-ignore
import type { UmfuturesUpdateBatchOrdersV1RespItem } from '../model';
// @ts-ignore
import type { UpdateListenKeyV1Resp } from '../model';
// @ts-ignore
import type { UpdateOrderV1Resp } from '../model';
/**
 * UsdsMarginedFuturesApi - axios parameter creator
 * @export
 */
export const UsdsMarginedFuturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1: async (batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept the offered quote by quote ID.
         * @summary Accept the offered quote (USER_DATA)
         * @param {string} quoteId 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConvertAcceptQuoteV1: async (quoteId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteId' is not null or undefined
            assertParamExists('createConvertAcceptQuoteV1', 'quoteId', quoteId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createConvertAcceptQuoteV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/convert/acceptQuote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (quoteId !== undefined) { 
                localVarFormParams.set('quoteId', quoteId as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a quote for the requested token pairs
         * @summary Send Quote Request(USER_DATA)
         * @param {string} fromAsset 
         * @param {number} timestamp 
         * @param {string} toAsset 
         * @param {string} [fromAmount] 
         * @param {number} [recvWindow] 
         * @param {string} [toAmount] 
         * @param {string} [validTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConvertGetQuoteV1: async (fromAsset: string, timestamp: number, toAsset: string, fromAmount?: string, recvWindow?: number, toAmount?: string, validTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromAsset' is not null or undefined
            assertParamExists('createConvertGetQuoteV1', 'fromAsset', fromAsset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createConvertGetQuoteV1', 'timestamp', timestamp)
            // verify required parameter 'toAsset' is not null or undefined
            assertParamExists('createConvertGetQuoteV1', 'toAsset', toAsset)
            const localVarPath = `/fapi/v1/convert/getQuote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (fromAmount !== undefined) { 
                localVarFormParams.set('fromAmount', fromAmount as any);
            }
    
            if (fromAsset !== undefined) { 
                localVarFormParams.set('fromAsset', fromAsset as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (toAmount !== undefined) { 
                localVarFormParams.set('toAmount', toAmount as any);
            }
    
            if (toAsset !== undefined) { 
                localVarFormParams.set('toAsset', toAsset as any);
            }
    
            if (validTime !== undefined) { 
                localVarFormParams.set('validTime', validTime as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {UmfuturesCreateCountdownCancelAllV1Req} [umfuturesCreateCountdownCancelAllV1Req] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1: async (umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/countdownCancelAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(umfuturesCreateCountdownCancelAllV1Req, localVarRequestOptions, configuration)
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On Futures Trade (TRADE)
         * @param {string} feeBurn 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeeBurnV1: async (feeBurn: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feeBurn' is not null or undefined
            assertParamExists('createFeeBurnV1', 'feeBurn', feeBurn)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createFeeBurnV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/feeBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (feeBurn !== undefined) { 
                localVarFormParams.set('feeBurn', feeBurn as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeverageV1: async (leverage: number, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('createLeverageV1', 'leverage', leverage)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createLeverageV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createLeverageV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (leverage !== undefined) { 
                localVarFormParams.set('leverage', leverage as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginTypeV1: async (marginType: string, symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marginType' is not null or undefined
            assertParamExists('createMarginTypeV1', 'marginType', marginType)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createMarginTypeV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMarginTypeV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/marginType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (marginType !== undefined) { 
                localVarFormParams.set('marginType', marginType as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {string} multiAssetsMargin 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultiAssetsMarginV1: async (multiAssetsMargin: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'multiAssetsMargin' is not null or undefined
            assertParamExists('createMultiAssetsMarginV1', 'multiAssetsMargin', multiAssetsMargin)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createMultiAssetsMarginV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/multiAssetsMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (multiAssetsMargin !== undefined) { 
                localVarFormParams.set('multiAssetsMargin', multiAssetsMargin as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderTestV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderTestV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderTestV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderTestV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderTestV1', 'type', type)
            const localVarPath = `/fapi/v1/order/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1: async (side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('createOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createOrderV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createOrderV1', 'type', type)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (activationPrice !== undefined) { 
                localVarFormParams.set('activationPrice', activationPrice as any);
            }
    
            if (callbackRate !== undefined) { 
                localVarFormParams.set('callbackRate', callbackRate as any);
            }
    
            if (closePosition !== undefined) { 
                localVarFormParams.set('closePosition', closePosition as any);
            }
    
            if (goodTillDate !== undefined) { 
                localVarFormParams.set('goodTillDate', goodTillDate as any);
            }
    
            if (newClientOrderId !== undefined) { 
                localVarFormParams.set('newClientOrderId', newClientOrderId as any);
            }
    
            if (newOrderRespType !== undefined) { 
                localVarFormParams.set('newOrderRespType', newOrderRespType as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (priceProtect !== undefined) { 
                localVarFormParams.set('priceProtect', priceProtect as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (reduceOnly !== undefined) { 
                localVarFormParams.set('reduceOnly', reduceOnly as any);
            }
    
            if (selfTradePreventionMode !== undefined) { 
                localVarFormParams.set('selfTradePreventionMode', selfTradePreventionMode as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timeInForce !== undefined) { 
                localVarFormParams.set('timeInForce', timeInForce as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (workingType !== undefined) { 
                localVarFormParams.set('workingType', workingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionMarginV1: async (amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createPositionMarginV1', 'amount', amount)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('createPositionMarginV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPositionMarginV1', 'timestamp', timestamp)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createPositionMarginV1', 'type', type)
            const localVarPath = `/fapi/v1/positionMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
    
            if (positionSide !== undefined) { 
                localVarFormParams.set('positionSide', positionSide as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionSideDualV1: async (dualSidePosition: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('createPositionSideDualV1', 'dualSidePosition', dualSidePosition)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('createPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (dualSidePosition !== undefined) { 
                localVarFormParams.set('dualSidePosition', dualSidePosition as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteAllOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/allOpenOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1: async (symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIdList) {
                localVarQueryParameter['orderIdList'] = orderIdList;
            }

            if (origClientOrderIdList) {
                localVarQueryParameter['origClientOrderIdList'] = origClientOrderIdList;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account configuration
         * @summary Futures Account Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountConfigV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountConfigV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/accountConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V2(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV2', 'timestamp', timestamp)
            const localVarPath = `/fapi/v2/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V3(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV3: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAccountV3', 'timestamp', timestamp)
            const localVarPath = `/fapi/v3/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdlQuantileV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAdlQuantileV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/adlQuantile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV1: async (symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAggTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/aggTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getAllOrdersV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getAllOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/allOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
         * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTradingStatusV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getApiTradingStatusV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/apiTradingStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {string} [symbol] Asset pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetIndexV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/assetIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV2: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBalanceV2', 'timestamp', timestamp)
            const localVarPath = `/fapi/v2/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV3: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBalanceV3', 'timestamp', timestamp)
            const localVarPath = `/fapi/v3/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Commission Rate
         * @summary User Commission Rate (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommissionRateV1: async (symbol: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCommissionRateV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getCommissionRateV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/commissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstituentsV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getConstituentsV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/constituents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinuousKlinesV1: async (pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'contractType', contractType)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getContinuousKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/continuousKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for all convertible token pairs and the tokens respective upper/lower limits
         * @summary List All Convert Pairs
         * @param {string} [fromAsset] User spends coin
         * @param {string} [toAsset] User receives coin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertExchangeInfoV1: async (fromAsset?: string, toAsset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/convert/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromAsset !== undefined) {
                localVarQueryParameter['fromAsset'] = fromAsset;
            }

            if (toAsset !== undefined) {
                localVarQueryParameter['toAsset'] = toAsset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query order status by order ID.
         * @summary Order status(USER_DATA)
         * @param {string} [orderId] Either orderId or quoteId is required
         * @param {string} [quoteId] Either orderId or quoteId is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertOrderStatusV1: async (orderId?: string, quoteId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/convert/orderStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (quoteId !== undefined) {
                localVarQueryParameter['quoteId'] = quoteId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getDepthV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeBurnV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getFeeBurnV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/feeBurn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForceOrdersV1: async (timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getForceOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/forceOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingInfoV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/fundingInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {string} [symbol] 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateV1: async (symbol?: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/fundingRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {string} pair BTCUSDT
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} limit Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataBasis: async (pair: string, contractType: string, period: string, limit: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'pair', pair)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'contractType', contractType)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'period', period)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getFuturesDataBasis', 'limit', limit)
            const localVarPath = `/futures/data/basis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {string} pair e.g BTCUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataDeliveryPrice: async (pair: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getFuturesDataDeliveryPrice', 'pair', pair)
            const localVarPath = `/futures/data/delivery-price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataGlobalLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataGlobalLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataGlobalLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/globalLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataOpenInterestHist: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataOpenInterestHist', 'period', period)
            const localVarPath = `/futures/data/openInterestHist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTakerlongshortRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataTakerlongshortRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTakerlongshortRatio', 'period', period)
            const localVarPath = `/futures/data/takerlongshortRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortAccountRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortAccountRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortAccountRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortAccountRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortPositionRatio: async (symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortPositionRatio', 'symbol', symbol)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getFuturesDataTopLongShortPositionRatio', 'period', period)
            const localVarPath = `/futures/data/topLongShortPositionRatio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1: async (symbol: string, limit?: number, fromId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getHistoricalTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/income/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getIncomeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/income/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexInfoV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/indexInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexPriceKlinesV1: async (pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('getIndexPriceKlinesV1', 'pair', pair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getIndexPriceKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/indexPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query user notional and leverage bracket on speicfic symbol
         * @summary Notional and Leverage Brackets (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getLeverageBracketV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/leverageBracket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkPriceKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarkPriceKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getMarkPriceKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/markPriceKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Get Current Multi-Assets Mode (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiAssetsMarginV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getMultiAssetsMarginV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/multiAssetsMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenInterestV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/openInterest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/openOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOpenOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAmendmentV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderAmendmentV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAmendmentV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/orderAmendment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getOrderAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getOrderAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getOrderAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderAsynV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1: async (symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmAccountInfoV1: async (asset: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPmAccountInfoV1', 'asset', asset)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPmAccountInfoV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/pmAccountInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] Default current time if not pass
         * @param {number} [limit] Default: 500
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionMarginHistoryV1: async (symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPositionMarginHistoryV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionMarginHistoryV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/positionMargin/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV2: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionRiskV2', 'timestamp', timestamp)
            const localVarPath = `/fapi/v2/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV3: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionRiskV3', 'timestamp', timestamp)
            const localVarPath = `/fapi/v3/positionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionSideDualV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getPositionSideDualV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/positionSide/dual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexKlinesV1: async (symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPremiumIndexKlinesV1', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getPremiumIndexKlinesV1', 'interval', interval)
            const localVarPath = `/fapi/v1/premiumIndexKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/premiumIndex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimitOrderV1: async (timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getRateLimitOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/rateLimit/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account symbol configuration.
         * @summary Symbol Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolConfigV1: async (timestamp: number, symbol?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getSymbolConfigV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/symbolConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/24hr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/bookTicker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV1: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV2: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v2/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynIdV1: async (downloadId: string, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getTradeAsynIdV1', 'downloadId', downloadId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTradeAsynIdV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/trade/asyn/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (downloadId !== undefined) {
                localVarQueryParameter['downloadId'] = downloadId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynV1: async (startTime: number, endTime: number, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getTradeAsynV1', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getTradeAsynV1', 'endTime', endTime)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTradeAsynV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/trade/asyn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTradesV1', 'symbol', symbol)
            const localVarPath = `/fapi/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] This can only be used in combination with &#x60;symbol&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1: async (symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUserTradesV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserTradesV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchOrdersV1: async (batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('updateBatchOrdersV1', 'batchOrders', batchOrders)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateBatchOrdersV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/batchOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required

            if (batchOrders) {
                localVarFormParams.set('batchOrders', batchOrders.join(COLLECTION_FORMATS.csv));
            }

    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fapi/v1/listenKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderV1: async (price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'price' is not null or undefined
            assertParamExists('updateOrderV1', 'price', price)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('updateOrderV1', 'quantity', quantity)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('updateOrderV1', 'side', side)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('updateOrderV1', 'symbol', symbol)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateOrderV1', 'timestamp', timestamp)
            const localVarPath = `/fapi/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication ApiKey required


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (origClientOrderId !== undefined) { 
                localVarFormParams.set('origClientOrderId', origClientOrderId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.set('price', price as any);
            }
    
            if (priceMatch !== undefined) { 
                localVarFormParams.set('priceMatch', priceMatch as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.set('quantity', quantity as any);
            }
    
            if (recvWindow !== undefined) { 
                localVarFormParams.set('recvWindow', recvWindow as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (symbol !== undefined) { 
                localVarFormParams.set('symbol', symbol as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.set('timestamp', timestamp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();
            // Handle Binance authentication with API key in header and signature in query parameters
            await setBinanceAuthToObject(localVarUrlObj, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsdsMarginedFuturesApi - functional programming interface
 * @export
 */
export const UsdsMarginedFuturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsdsMarginedFuturesApiAxiosParamCreator(configuration)
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchOrdersV1(batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accept the offered quote by quote ID.
         * @summary Accept the offered quote (USER_DATA)
         * @param {string} quoteId 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConvertAcceptQuoteV1(quoteId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConvertAcceptQuoteV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConvertAcceptQuoteV1(quoteId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createConvertAcceptQuoteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request a quote for the requested token pairs
         * @summary Send Quote Request(USER_DATA)
         * @param {string} fromAsset 
         * @param {number} timestamp 
         * @param {string} toAsset 
         * @param {string} [fromAmount] 
         * @param {number} [recvWindow] 
         * @param {string} [toAmount] 
         * @param {string} [validTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConvertGetQuoteV1(fromAsset: string, timestamp: number, toAsset: string, fromAmount?: string, recvWindow?: number, toAmount?: string, validTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConvertGetQuoteV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConvertGetQuoteV1(fromAsset, timestamp, toAsset, fromAmount, recvWindow, toAmount, validTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createConvertGetQuoteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {UmfuturesCreateCountdownCancelAllV1Req} [umfuturesCreateCountdownCancelAllV1Req] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCountdownCancelAllV1(umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCountdownCancelAllV1(umfuturesCreateCountdownCancelAllV1Req, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createCountdownCancelAllV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On Futures Trade (TRADE)
         * @param {string} feeBurn 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeeBurnV1(feeBurn: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFeeBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeeBurnV1(feeBurn, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createFeeBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {number} leverage 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeverageV1(leverage: number, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLeverageV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeverageV1(leverage, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createLeverageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {string} marginType 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMarginTypeV1(marginType: string, symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMarginTypeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMarginTypeV1(marginType, symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createMarginTypeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {string} multiAssetsMargin 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMultiAssetsMarginV1(multiAssetsMargin: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMultiAssetsMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMultiAssetsMarginV1(multiAssetsMargin, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createMultiAssetsMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderTestV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderTestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderTestV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, goodTillDate, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createOrderTestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {string} type 
         * @param {string} [activationPrice] 
         * @param {string} [callbackRate] 
         * @param {string} [closePosition] 
         * @param {number} [goodTillDate] 
         * @param {string} [newClientOrderId] 
         * @param {string} [newOrderRespType] 
         * @param {string} [positionSide] 
         * @param {string} [price] 
         * @param {string} [priceMatch] 
         * @param {string} [priceProtect] 
         * @param {string} [quantity] 
         * @param {number} [recvWindow] 
         * @param {string} [reduceOnly] 
         * @param {string} [selfTradePreventionMode] 
         * @param {string} [stopPrice] 
         * @param {string} [timeInForce] 
         * @param {string} [workingType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderV1(side: string, symbol: string, timestamp: number, type: string, activationPrice?: string, callbackRate?: string, closePosition?: string, goodTillDate?: number, newClientOrderId?: string, newOrderRespType?: string, positionSide?: string, price?: string, priceMatch?: string, priceProtect?: string, quantity?: string, recvWindow?: number, reduceOnly?: string, selfTradePreventionMode?: string, stopPrice?: string, timeInForce?: string, workingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderV1(side, symbol, timestamp, type, activationPrice, callbackRate, closePosition, goodTillDate, newClientOrderId, newOrderRespType, positionSide, price, priceMatch, priceProtect, quantity, recvWindow, reduceOnly, selfTradePreventionMode, stopPrice, timeInForce, workingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} amount 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} type 
         * @param {string} [positionSide] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionMarginV1(amount: string, symbol: string, timestamp: number, type: number, positionSide?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePositionMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionMarginV1(amount, symbol, timestamp, type, positionSide, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createPositionMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionSideDualV1(dualSidePosition: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionSideDualV1(dualSidePosition, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.createPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllOpenOrdersV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAllOpenOrdersV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllOpenOrdersV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.deleteAllOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {Array<number>} [orderIdList] max length 10 &lt;br/&gt; e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatchOrdersV1(symbol: string, timestamp: number, orderIdList?: Array<number>, origClientOrderIdList?: Array<string>, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatchOrdersV1(symbol, timestamp, orderIdList, origClientOrderIdList, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.deleteBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.deleteListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.deleteOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account configuration
         * @summary Futures Account Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountConfigV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountConfigV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountConfigV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getAccountConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V2(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV2(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV2Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV2(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getAccountV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V3(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV3(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountV3Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV3(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getAccountV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdlQuantileV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAdlQuantileV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdlQuantileV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getAdlQuantileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol 
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggTradesV1(symbol: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggTradesV1(symbol, fromId, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getAggTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrdersV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrdersV1(symbol, timestamp, orderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getAllOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
         * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiTradingStatusV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetApiTradingStatusV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiTradingStatusV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getApiTradingStatusV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {string} [symbol] Asset pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetIndexV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetAssetIndexV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetIndexV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getAssetIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceV2(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBalanceV2RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceV2(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getBalanceV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceV3(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetBalanceV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceV3(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getBalanceV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User Commission Rate
         * @summary User Commission Rate (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommissionRateV1(symbol: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommissionRateV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionRateV1(symbol, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getCommissionRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConstituentsV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConstituentsV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConstituentsV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getConstituentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} contractType 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContinuousKlinesV1(pair: string, contractType: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContinuousKlinesV1(pair, contractType, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getContinuousKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query for all convertible token pairs and the tokens respective upper/lower limits
         * @summary List All Convert Pairs
         * @param {string} [fromAsset] User spends coin
         * @param {string} [toAsset] User receives coin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvertExchangeInfoV1(fromAsset?: string, toAsset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetConvertExchangeInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvertExchangeInfoV1(fromAsset, toAsset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getConvertExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query order status by order ID.
         * @summary Order status(USER_DATA)
         * @param {string} [orderId] Either orderId or quoteId is required
         * @param {string} [quoteId] Either orderId or quoteId is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvertOrderStatusV1(orderId?: string, quoteId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConvertOrderStatusV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvertOrderStatusV1(orderId, quoteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getConvertOrderStatusV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {string} symbol 
         * @param {number} [limit] Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepthV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDepthV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepthV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getDepthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetExchangeInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getExchangeInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeBurnV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeeBurnV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeeBurnV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFeeBurnV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {string} [autoCloseType] &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 50; max 100.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForceOrdersV1(timestamp: number, symbol?: string, autoCloseType?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetForceOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForceOrdersV1(timestamp, symbol, autoCloseType, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getForceOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingInfoV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFundingInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingInfoV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFundingInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {string} [symbol] 
         * @param {number} [startTime] Timestamp in ms to get funding rate from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get funding rate  until INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingRateV1(symbol?: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFundingRateV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingRateV1(symbol, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFundingRateV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {string} pair BTCUSDT
         * @param {string} contractType CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} limit Default 30,Max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataBasis(pair: string, contractType: string, period: string, limit: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataBasisRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataBasis(pair, contractType, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFuturesDataBasis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {string} pair e.g BTCUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataDeliveryPrice(pair: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataDeliveryPrice(pair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFuturesDataDeliveryPrice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataGlobalLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataGlobalLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFuturesDataGlobalLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataOpenInterestHist(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataOpenInterestHist(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFuturesDataOpenInterestHist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTakerlongshortRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTakerlongshortRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTakerlongshortRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFuturesDataTakerlongshortRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTopLongShortAccountRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTopLongShortAccountRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFuturesDataTopLongShortAccountRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} symbol 
         * @param {string} period &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
         * @param {number} [limit] default 30, max 500
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDataTopLongShortPositionRatio(symbol: string, period: string, limit?: number, startTime?: number, endTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDataTopLongShortPositionRatio(symbol, period, limit, startTime, endTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getFuturesDataTopLongShortPositionRatio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol 
         * @param {number} [limit] Default 100; max 500.
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTradesV1(symbol: string, limit?: number, fromId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetHistoricalTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTradesV1(symbol, limit, fromId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getHistoricalTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getIncomeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getIncomeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndexInfoV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetIndexInfoV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndexInfoV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getIndexInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndexPriceKlinesV1(pair: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndexPriceKlinesV1(pair, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getIndexPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query user notional and leverage bracket on speicfic symbol
         * @summary Notional and Leverage Brackets (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeverageBracketV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetLeverageBracketV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeverageBracketV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getLeverageBracketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarkPriceKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarkPriceKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getMarkPriceKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Get Current Multi-Assets Mode (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultiAssetsMarginV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMultiAssetsMarginV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultiAssetsMarginV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getMultiAssetsMarginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenInterestV1(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOpenInterestV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenInterestV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getOpenInterestV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOpenOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getOpenOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrdersV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOpenOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrdersV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getOpenOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [startTime] Timestamp in ms to get modification history from INCLUSIVE
         * @param {number} [endTime] Timestamp in ms to get modification history until INCLUSIVE
         * @param {number} [limit] Default 50; max 100
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAmendmentV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrderAmendmentV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAmendmentV1(symbol, timestamp, orderId, origClientOrderId, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getOrderAmendmentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getOrderAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetOrderAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getOrderAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderV1(symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderV1(symbol, timestamp, orderId, origClientOrderId, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getPingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {string} asset 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmAccountInfoV1(asset: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPmAccountInfoV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmAccountInfoV1(asset, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getPmAccountInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [type] 1: Add position margin2: Reduce position margin
         * @param {number} [startTime] 
         * @param {number} [endTime] Default current time if not pass
         * @param {number} [limit] Default: 500
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionMarginHistoryV1(symbol: string, timestamp: number, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionMarginHistoryV1(symbol, timestamp, type, startTime, endTime, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getPositionMarginHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionRiskV2(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionRiskV2RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionRiskV2(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getPositionRiskV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionRiskV3(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPositionRiskV3RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionRiskV3(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getPositionRiskV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionSideDualV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPositionSideDualV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionSideDualV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getPositionSideDualV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {string} symbol 
         * @param {string} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] Default 500; max 1500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPremiumIndexKlinesV1(symbol: string, interval: string, startTime?: number, endTime?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPremiumIndexKlinesV1(symbol, interval, startTime, endTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getPremiumIndexKlinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPremiumIndexV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetPremiumIndexV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPremiumIndexV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getPremiumIndexV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimitOrderV1(timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRateLimitOrderV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimitOrderV1(timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getRateLimitOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account symbol configuration.
         * @summary Symbol Configuration(USER_DATA)
         * @param {number} timestamp 
         * @param {string} [symbol] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSymbolConfigV1(timestamp: number, symbol?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetSymbolConfigV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSymbolConfigV1(timestamp, symbol, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getSymbolConfigV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicker24hrV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTicker24hrV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker24hrV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getTicker24hrV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerBookTickerV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerBookTickerV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerBookTickerV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getTickerBookTickerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerPriceV1(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerPriceV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerPriceV1(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getTickerPriceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerPriceV2(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UmfuturesGetTickerPriceV2Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickerPriceV2(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getTickerPriceV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTimeV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getTimeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeAsynIdV1(downloadId: string, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTradeAsynIdV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradeAsynIdV1(downloadId, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getTradeAsynIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {number} startTime Timestamp in ms
         * @param {number} endTime Timestamp in ms
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeAsynV1(startTime: number, endTime: number, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTradeAsynV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradeAsynV1(startTime, endTime, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getTradeAsynV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {string} symbol 
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradesV1(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTradesV1(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] This can only be used in combination with &#x60;symbol&#x60;
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTradesV1(symbol: string, timestamp: number, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserTradesV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTradesV1(symbol, timestamp, orderId, startTime, endTime, fromId, limit, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.getUserTradesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>} batchOrders 
         * @param {number} timestamp 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatchOrdersV1(batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>, timestamp: number, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatchOrdersV1(batchOrders, timestamp, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.updateBatchOrdersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateListenKeyV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateListenKeyV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateListenKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.updateListenKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {string} price 
         * @param {string} quantity 
         * @param {string} side 
         * @param {string} symbol 
         * @param {number} timestamp 
         * @param {number} [orderId] 
         * @param {string} [origClientOrderId] 
         * @param {string} [priceMatch] 
         * @param {number} [recvWindow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrderV1(price: string, quantity: string, side: string, symbol: string, timestamp: number, orderId?: number, origClientOrderId?: string, priceMatch?: string, recvWindow?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOrderV1Resp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrderV1(price, quantity, side, symbol, timestamp, orderId, origClientOrderId, priceMatch, recvWindow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsdsMarginedFuturesApi.updateOrderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsdsMarginedFuturesApi - factory interface
 * @export
 */
export const UsdsMarginedFuturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsdsMarginedFuturesApiFp(configuration)
    return {
        /**
         * Place Multiple Orders
         * @summary Place Multiple Orders(TRADE)
         * @param {UsdsMarginedFuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>> {
            return localVarFp.createBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept the offered quote by quote ID.
         * @summary Accept the offered quote (USER_DATA)
         * @param {UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConvertAcceptQuoteV1(requestParameters: UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateConvertAcceptQuoteV1Resp> {
            return localVarFp.createConvertAcceptQuoteV1(requestParameters.quoteId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a quote for the requested token pairs
         * @summary Send Quote Request(USER_DATA)
         * @param {UsdsMarginedFuturesApiCreateConvertGetQuoteV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConvertGetQuoteV1(requestParameters: UsdsMarginedFuturesApiCreateConvertGetQuoteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateConvertGetQuoteV1Resp> {
            return localVarFp.createConvertGetQuoteV1(requestParameters.fromAsset, requestParameters.timestamp, requestParameters.toAsset, requestParameters.fromAmount, requestParameters.recvWindow, requestParameters.toAmount, requestParameters.validTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {UsdsMarginedFuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCountdownCancelAllV1(requestParameters: UsdsMarginedFuturesApiCreateCountdownCancelAllV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp> {
            return localVarFp.createCountdownCancelAllV1(requestParameters.umfuturesCreateCountdownCancelAllV1Req, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
         * @summary Toggle BNB Burn On Futures Trade (TRADE)
         * @param {UsdsMarginedFuturesApiCreateFeeBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeeBurnV1(requestParameters: UsdsMarginedFuturesApiCreateFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateFeeBurnV1Resp> {
            return localVarFp.createFeeBurnV1(requestParameters.feeBurn, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s initial leverage of specific symbol market.
         * @summary Change Initial Leverage(TRADE)
         * @param {UsdsMarginedFuturesApiCreateLeverageV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeverageV1(requestParameters: UsdsMarginedFuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeverageV1Resp> {
            return localVarFp.createLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
         * @summary Start User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp> {
            return localVarFp.createListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Change symbol level margin type
         * @summary Change Margin Type(TRADE)
         * @param {UsdsMarginedFuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMarginTypeV1(requestParameters: UsdsMarginedFuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginTypeV1Resp> {
            return localVarFp.createMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {UsdsMarginedFuturesApiCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultiAssetsMarginV1(requestParameters: UsdsMarginedFuturesApiCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMultiAssetsMarginV1Resp> {
            return localVarFp.createMultiAssetsMarginV1(requestParameters.multiAssetsMargin, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         * @summary Test Order(TRADE)
         * @param {UsdsMarginedFuturesApiCreateOrderTestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderTestV1(requestParameters: UsdsMarginedFuturesApiCreateOrderTestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderTestV1Resp> {
            return localVarFp.createOrderTestV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Send in a new order.
         * @summary New Order(TRADE)
         * @param {UsdsMarginedFuturesApiCreateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderV1(requestParameters: UsdsMarginedFuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderV1Resp> {
            return localVarFp.createOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Isolated Position Margin
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {UsdsMarginedFuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionMarginV1(requestParameters: UsdsMarginedFuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionMarginV1Resp> {
            return localVarFp.createPositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Change Position Mode(TRADE)
         * @param {UsdsMarginedFuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionSideDualV1(requestParameters: UsdsMarginedFuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionSideDualV1Resp> {
            return localVarFp.createPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel All Open Orders
         * @summary Cancel All Open Orders (TRADE)
         * @param {UsdsMarginedFuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOpenOrdersV1(requestParameters: UsdsMarginedFuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp> {
            return localVarFp.deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Multiple Orders
         * @summary Cancel Multiple Orders (TRADE)
         * @param {UsdsMarginedFuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>> {
            return localVarFp.deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Close out a user data stream.
         * @summary Close User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an active order.
         * @summary Cancel Order (TRADE)
         * @param {UsdsMarginedFuturesApiDeleteOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderV1(requestParameters: UsdsMarginedFuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp> {
            return localVarFp.deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account configuration
         * @summary Futures Account Configuration(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetAccountConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountConfigV1(requestParameters: UsdsMarginedFuturesApiGetAccountConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountConfigV1Resp> {
            return localVarFp.getAccountConfigV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V2(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetAccountV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2(requestParameters: UsdsMarginedFuturesApiGetAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV2Resp> {
            return localVarFp.getAccountV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
         * @summary Account Information V3(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetAccountV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV3(requestParameters: UsdsMarginedFuturesApiGetAccountV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV3Resp> {
            return localVarFp.getAccountV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Position ADL Quantile Estimation
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdlQuantileV1(requestParameters: UsdsMarginedFuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAdlQuantileV1RespItem>> {
            return localVarFp.getAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         * @summary Compressed/Aggregate Trades List
         * @param {UsdsMarginedFuturesApiGetAggTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggTradesV1(requestParameters: UsdsMarginedFuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>> {
            return localVarFp.getAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * @summary All Orders (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV1(requestParameters: UsdsMarginedFuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV1RespItem>> {
            return localVarFp.getAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
         * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetApiTradingStatusV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTradingStatusV1(requestParameters: UsdsMarginedFuturesApiGetApiTradingStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetApiTradingStatusV1Resp> {
            return localVarFp.getApiTradingStatusV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * asset index for Multi-Assets mode
         * @summary Multi-Assets Mode Asset Index
         * @param {UsdsMarginedFuturesApiGetAssetIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetIndexV1(requestParameters: UsdsMarginedFuturesApiGetAssetIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetAssetIndexV1Resp> {
            return localVarFp.getAssetIndexV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V2 (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetBalanceV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV2(requestParameters: UsdsMarginedFuturesApiGetBalanceV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV2RespItem>> {
            return localVarFp.getBalanceV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query account balance info
         * @summary Futures Account Balance V3 (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetBalanceV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceV3(requestParameters: UsdsMarginedFuturesApiGetBalanceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV3RespItem>> {
            return localVarFp.getBalanceV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User Commission Rate
         * @summary User Commission Rate (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommissionRateV1(requestParameters: UsdsMarginedFuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCommissionRateV1Resp> {
            return localVarFp.getCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query index price constituents
         * @summary Query Index Price Constituents
         * @param {UsdsMarginedFuturesApiGetConstituentsV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstituentsV1(requestParameters: UsdsMarginedFuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConstituentsV1Resp> {
            return localVarFp.getConstituentsV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {UsdsMarginedFuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinuousKlinesV1(requestParameters: UsdsMarginedFuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for all convertible token pairs and the tokens respective upper/lower limits
         * @summary List All Convert Pairs
         * @param {UsdsMarginedFuturesApiGetConvertExchangeInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertExchangeInfoV1(requestParameters: UsdsMarginedFuturesApiGetConvertExchangeInfoV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetConvertExchangeInfoV1RespItem>> {
            return localVarFp.getConvertExchangeInfoV1(requestParameters.fromAsset, requestParameters.toAsset, options).then((request) => request(axios, basePath));
        },
        /**
         * Query order status by order ID.
         * @summary Order status(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetConvertOrderStatusV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertOrderStatusV1(requestParameters: UsdsMarginedFuturesApiGetConvertOrderStatusV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetConvertOrderStatusV1Resp> {
            return localVarFp.getConvertOrderStatusV1(requestParameters.orderId, requestParameters.quoteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol orderbook
         * @summary Order Book
         * @param {UsdsMarginedFuturesApiGetDepthV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthV1(requestParameters: UsdsMarginedFuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp> {
            return localVarFp.getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information
         * @summary Exchange Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetExchangeInfoV1Resp> {
            return localVarFp.getExchangeInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
         * @summary Get BNB Burn Status (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetFeeBurnV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeBurnV1(requestParameters: UsdsMarginedFuturesApiGetFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetFeeBurnV1Resp> {
            return localVarFp.getFeeBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user\'s Force Orders
         * @summary User\'s Force Orders (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForceOrdersV1(requestParameters: UsdsMarginedFuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetForceOrdersV1RespItem>> {
            return localVarFp.getForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         * @summary Get Funding Rate Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingInfoV1RespItem>> {
            return localVarFp.getFundingInfoV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Funding Rate History
         * @summary Get Funding Rate History
         * @param {UsdsMarginedFuturesApiGetFundingRateV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateV1(requestParameters: UsdsMarginedFuturesApiGetFundingRateV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingRateV1RespItem>> {
            return localVarFp.getFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query future basis
         * @summary Basis
         * @param {UsdsMarginedFuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataBasis(requestParameters: UsdsMarginedFuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataBasisRespItem>> {
            return localVarFp.getFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Quarterly Contract Settlement Price
         * @param {UsdsMarginedFuturesApiGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataDeliveryPrice(requestParameters: UsdsMarginedFuturesApiGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>> {
            return localVarFp.getFuturesDataDeliveryPrice(requestParameters.pair, options).then((request) => request(axios, basePath));
        },
        /**
         * Query symbol Long/Short Ratio
         * @summary Long/Short Ratio
         * @param {UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataGlobalLongShortAccountRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>> {
            return localVarFp.getFuturesDataGlobalLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Open Interest Statistics
         * @summary Open Interest Statistics
         * @param {UsdsMarginedFuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataOpenInterestHist(requestParameters: UsdsMarginedFuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>> {
            return localVarFp.getFuturesDataOpenInterestHist(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Taker Buy/Sell Volume
         * @summary Taker Buy/Sell Volume
         * @param {UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTakerlongshortRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTakerlongshortRatioRespItem>> {
            return localVarFp.getFuturesDataTakerlongshortRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortAccountRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>> {
            return localVarFp.getFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDataTopLongShortPositionRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>> {
            return localVarFp.getFuturesDataTopLongShortPositionRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get older market historical trades.
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {UsdsMarginedFuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTradesV1(requestParameters: UsdsMarginedFuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>> {
            return localVarFp.getHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures transaction history download link by Id
         * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp> {
            return localVarFp.getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for futures transaction history
         * @summary Get Download Id For Futures Transaction History(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeAsynV1(requestParameters: UsdsMarginedFuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp> {
            return localVarFp.getIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query composite index symbol information
         * @summary Composite Index Symbol Information
         * @param {UsdsMarginedFuturesApiGetIndexInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexInfoV1(requestParameters: UsdsMarginedFuturesApiGetIndexInfoV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIndexInfoV1RespItem>> {
            return localVarFp.getIndexInfoV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         * @summary Index Price Kline/Candlestick Data
         * @param {UsdsMarginedFuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexPriceKlinesV1(requestParameters: UsdsMarginedFuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
         * @summary Kline/Candlestick Data
         * @param {UsdsMarginedFuturesApiGetKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKlinesV1(requestParameters: UsdsMarginedFuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Query user notional and leverage bracket on speicfic symbol
         * @summary Notional and Leverage Brackets (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeverageBracketV1(requestParameters: UsdsMarginedFuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetLeverageBracketV1Resp> {
            return localVarFp.getLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
         * @summary Mark Price Kline/Candlestick Data
         * @param {UsdsMarginedFuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkPriceKlinesV1(requestParameters: UsdsMarginedFuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
         * @summary Get Current Multi-Assets Mode (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetMultiAssetsMarginV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiAssetsMarginV1(requestParameters: UsdsMarginedFuturesApiGetMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMultiAssetsMarginV1Resp> {
            return localVarFp.getMultiAssetsMarginV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get present open interest of a specific symbol.
         * @summary Open Interest
         * @param {UsdsMarginedFuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenInterestV1(requestParameters: UsdsMarginedFuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenInterestV1Resp> {
            return localVarFp.getOpenInterestV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query open order
         * @summary Query Current Open Order (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrderV1(requestParameters: UsdsMarginedFuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenOrderV1Resp> {
            return localVarFp.getOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all open orders on a symbol.
         * @summary Current All Open Orders (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrdersV1(requestParameters: UsdsMarginedFuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>> {
            return localVarFp.getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order modification history
         * @summary Get Order Modify History (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAmendmentV1(requestParameters: UsdsMarginedFuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOrderAmendmentV1RespItem>> {
            return localVarFp.getOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures order history download link by Id
         * @summary Get Futures Order History Download Link by Id (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynIdV1Resp> {
            return localVarFp.getOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Download Id For Futures Order History
         * @summary Get Download Id For Futures Order History (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderAsynV1(requestParameters: UsdsMarginedFuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOrderAsynV1Resp> {
            return localVarFp.getOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Check an order\'s status.
         * @summary Query Order (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderV1(requestParameters: UsdsMarginedFuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp> {
            return localVarFp.getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Classic Portfolio Margin current account information.
         * @summary Classic Portfolio Margin Account Information (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmAccountInfoV1(requestParameters: UsdsMarginedFuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPmAccountInfoV1Resp> {
            return localVarFp.getPmAccountInfoV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Position Margin Change History
         * @summary Get Position Margin Change History (TRADE)
         * @param {UsdsMarginedFuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionMarginHistoryV1(requestParameters: UsdsMarginedFuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>> {
            return localVarFp.getPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current position information.
         * @summary Position Information V2 (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetPositionRiskV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV2(requestParameters: UsdsMarginedFuturesApiGetPositionRiskV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV2RespItem>> {
            return localVarFp.getPositionRiskV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         * @summary Position Information V3 (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetPositionRiskV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionRiskV3(requestParameters: UsdsMarginedFuturesApiGetPositionRiskV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV3RespItem>> {
            return localVarFp.getPositionRiskV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
         * @summary Get Current Position Mode(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionSideDualV1(requestParameters: UsdsMarginedFuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPositionSideDualV1Resp> {
            return localVarFp.getPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         * @summary Premium index Kline Data
         * @param {UsdsMarginedFuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexKlinesV1(requestParameters: UsdsMarginedFuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>> {
            return localVarFp.getPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark Price and Funding Rate
         * @summary Mark Price
         * @param {UsdsMarginedFuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPremiumIndexV1(requestParameters: UsdsMarginedFuturesApiGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetPremiumIndexV1Resp> {
            return localVarFp.getPremiumIndexV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User Rate Limit
         * @summary Query User Rate Limit (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetRateLimitOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimitOrderV1(requestParameters: UsdsMarginedFuturesApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRateLimitOrderV1RespItem>> {
            return localVarFp.getRateLimitOrderV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account symbol configuration.
         * @summary Symbol Configuration(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetSymbolConfigV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolConfigV1(requestParameters: UsdsMarginedFuturesApiGetSymbolConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetSymbolConfigV1RespItem>> {
            return localVarFp.getSymbolConfigV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
         * @summary 24hr Ticker Price Change Statistics
         * @param {UsdsMarginedFuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker24hrV1(requestParameters: UsdsMarginedFuturesApiGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTicker24hrV1Resp> {
            return localVarFp.getTicker24hrV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * @summary Symbol Order Book Ticker
         * @param {UsdsMarginedFuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBookTickerV1(requestParameters: UsdsMarginedFuturesApiGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerBookTickerV1Resp> {
            return localVarFp.getTickerBookTickerV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker
         * @param {UsdsMarginedFuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV1(requestParameters: UsdsMarginedFuturesApiGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV1Resp> {
            return localVarFp.getTickerPriceV1(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.
         * @summary Symbol Price Ticker V2
         * @param {UsdsMarginedFuturesApiGetTickerPriceV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerPriceV2(requestParameters: UsdsMarginedFuturesApiGetTickerPriceV2Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV2Resp> {
            return localVarFp.getTickerPriceV2(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp> {
            return localVarFp.getTimeV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get futures trade download link by Id
         * @summary Get Futures Trade Download Link by Id(USER_DATA)
         * @param {UsdsMarginedFuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynIdV1Resp> {
            return localVarFp.getTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download id for futures trade history
         * @summary Get Download Id For Futures Trade History (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeAsynV1(requestParameters: UsdsMarginedFuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynV1Resp> {
            return localVarFp.getTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent market trades
         * @summary Recent Trades List
         * @param {UsdsMarginedFuturesApiGetTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradesV1(requestParameters: UsdsMarginedFuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>> {
            return localVarFp.getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a specific account and symbol.
         * @summary Account Trade List (USER_DATA)
         * @param {UsdsMarginedFuturesApiGetUserTradesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradesV1(requestParameters: UsdsMarginedFuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>> {
            return localVarFp.getUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify Multiple Orders (TRADE)
         * @summary Modify Multiple Orders(TRADE)
         * @param {UsdsMarginedFuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>> {
            return localVarFp.updateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
         * @summary Keepalive User Data Stream (USER_STREAM)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<UpdateListenKeyV1Resp> {
            return localVarFp.updateListenKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         * @summary Modify Order (TRADE)
         * @param {UsdsMarginedFuturesApiUpdateOrderV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderV1(requestParameters: UsdsMarginedFuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderV1Resp> {
            return localVarFp.updateOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsdsMarginedFuturesApi - interface
 * @export
 * @interface UsdsMarginedFuturesApi
 */
export interface UsdsMarginedFuturesApiInterface {
    /**
     * Place Multiple Orders
     * @summary Place Multiple Orders(TRADE)
     * @param {UsdsMarginedFuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesCreateBatchOrdersV1RespInner>>;

    /**
     * Accept the offered quote by quote ID.
     * @summary Accept the offered quote (USER_DATA)
     * @param {UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createConvertAcceptQuoteV1(requestParameters: UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateConvertAcceptQuoteV1Resp>;

    /**
     * Request a quote for the requested token pairs
     * @summary Send Quote Request(USER_DATA)
     * @param {UsdsMarginedFuturesApiCreateConvertGetQuoteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createConvertGetQuoteV1(requestParameters: UsdsMarginedFuturesApiCreateConvertGetQuoteV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateConvertGetQuoteV1Resp>;

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {UsdsMarginedFuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createCountdownCancelAllV1(requestParameters?: UsdsMarginedFuturesApiCreateCountdownCancelAllV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesCreateCountdownCancelAllV1Resp>;

    /**
     * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
     * @summary Toggle BNB Burn On Futures Trade (TRADE)
     * @param {UsdsMarginedFuturesApiCreateFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createFeeBurnV1(requestParameters: UsdsMarginedFuturesApiCreateFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateFeeBurnV1Resp>;

    /**
     * Change user\'s initial leverage of specific symbol market.
     * @summary Change Initial Leverage(TRADE)
     * @param {UsdsMarginedFuturesApiCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createLeverageV1(requestParameters: UsdsMarginedFuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeverageV1Resp>;

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<CreateListenKeyV1Resp>;

    /**
     * Change symbol level margin type
     * @summary Change Margin Type(TRADE)
     * @param {UsdsMarginedFuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createMarginTypeV1(requestParameters: UsdsMarginedFuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMarginTypeV1Resp>;

    /**
     * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Change Multi-Assets Mode (TRADE)
     * @param {UsdsMarginedFuturesApiCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createMultiAssetsMarginV1(requestParameters: UsdsMarginedFuturesApiCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateMultiAssetsMarginV1Resp>;

    /**
     * Testing order request, this order will not be submitted to matching engine
     * @summary Test Order(TRADE)
     * @param {UsdsMarginedFuturesApiCreateOrderTestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createOrderTestV1(requestParameters: UsdsMarginedFuturesApiCreateOrderTestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderTestV1Resp>;

    /**
     * Send in a new order.
     * @summary New Order(TRADE)
     * @param {UsdsMarginedFuturesApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createOrderV1(requestParameters: UsdsMarginedFuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderV1Resp>;

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {UsdsMarginedFuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createPositionMarginV1(requestParameters: UsdsMarginedFuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionMarginV1Resp>;

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {UsdsMarginedFuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    createPositionSideDualV1(requestParameters: UsdsMarginedFuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CreatePositionSideDualV1Resp>;

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders (TRADE)
     * @param {UsdsMarginedFuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    deleteAllOpenOrdersV1(requestParameters: UsdsMarginedFuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAllOpenOrdersV1Resp>;

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders (TRADE)
     * @param {UsdsMarginedFuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    deleteBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesDeleteBatchOrdersV1RespInner>>;

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    deleteListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {UsdsMarginedFuturesApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    deleteOrderV1(requestParameters: UsdsMarginedFuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderV1Resp>;

    /**
     * Query account configuration
     * @summary Futures Account Configuration(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAccountConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getAccountConfigV1(requestParameters: UsdsMarginedFuturesApiGetAccountConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountConfigV1Resp>;

    /**
     * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
     * @summary Account Information V2(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getAccountV2(requestParameters: UsdsMarginedFuturesApiGetAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV2Resp>;

    /**
     * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
     * @summary Account Information V3(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAccountV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getAccountV3(requestParameters: UsdsMarginedFuturesApiGetAccountV3Request, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountV3Resp>;

    /**
     * Position ADL Quantile Estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getAdlQuantileV1(requestParameters: UsdsMarginedFuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAdlQuantileV1RespItem>>;

    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {UsdsMarginedFuturesApiGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getAggTradesV1(requestParameters: UsdsMarginedFuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetAggTradesV1RespItem>>;

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getAllOrdersV1(requestParameters: UsdsMarginedFuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllOrdersV1RespItem>>;

    /**
     * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
     * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetApiTradingStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getApiTradingStatusV1(requestParameters: UsdsMarginedFuturesApiGetApiTradingStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetApiTradingStatusV1Resp>;

    /**
     * asset index for Multi-Assets mode
     * @summary Multi-Assets Mode Asset Index
     * @param {UsdsMarginedFuturesApiGetAssetIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getAssetIndexV1(requestParameters?: UsdsMarginedFuturesApiGetAssetIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetAssetIndexV1Resp>;

    /**
     * Query account balance info
     * @summary Futures Account Balance V2 (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetBalanceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getBalanceV2(requestParameters: UsdsMarginedFuturesApiGetBalanceV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV2RespItem>>;

    /**
     * Query account balance info
     * @summary Futures Account Balance V3 (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetBalanceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getBalanceV3(requestParameters: UsdsMarginedFuturesApiGetBalanceV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetBalanceV3RespItem>>;

    /**
     * Get User Commission Rate
     * @summary User Commission Rate (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getCommissionRateV1(requestParameters: UsdsMarginedFuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetCommissionRateV1Resp>;

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {UsdsMarginedFuturesApiGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getConstituentsV1(requestParameters: UsdsMarginedFuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConstituentsV1Resp>;

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {UsdsMarginedFuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getContinuousKlinesV1(requestParameters: UsdsMarginedFuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query for all convertible token pairs and the tokens respective upper/lower limits
     * @summary List All Convert Pairs
     * @param {UsdsMarginedFuturesApiGetConvertExchangeInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getConvertExchangeInfoV1(requestParameters?: UsdsMarginedFuturesApiGetConvertExchangeInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetConvertExchangeInfoV1RespItem>>;

    /**
     * Query order status by order ID.
     * @summary Order status(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetConvertOrderStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getConvertOrderStatusV1(requestParameters?: UsdsMarginedFuturesApiGetConvertOrderStatusV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetConvertOrderStatusV1Resp>;

    /**
     * Query symbol orderbook
     * @summary Order Book
     * @param {UsdsMarginedFuturesApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getDepthV1(requestParameters: UsdsMarginedFuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetDepthV1Resp>;

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getExchangeInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetExchangeInfoV1Resp>;

    /**
     * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
     * @summary Get BNB Burn Status (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFeeBurnV1(requestParameters: UsdsMarginedFuturesApiGetFeeBurnV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetFeeBurnV1Resp>;

    /**
     * Query user\'s Force Orders
     * @summary User\'s Force Orders (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getForceOrdersV1(requestParameters: UsdsMarginedFuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetForceOrdersV1RespItem>>;

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFundingInfoV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingInfoV1RespItem>>;

    /**
     * Get Funding Rate History
     * @summary Get Funding Rate History
     * @param {UsdsMarginedFuturesApiGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFundingRateV1(requestParameters?: UsdsMarginedFuturesApiGetFundingRateV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFundingRateV1RespItem>>;

    /**
     * Query future basis
     * @summary Basis
     * @param {UsdsMarginedFuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFuturesDataBasis(requestParameters: UsdsMarginedFuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataBasisRespItem>>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Quarterly Contract Settlement Price
     * @param {UsdsMarginedFuturesApiGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFuturesDataDeliveryPrice(requestParameters: UsdsMarginedFuturesApiGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesGetFuturesDataDeliveryPriceRespItem>>;

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFuturesDataGlobalLongShortAccountRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataGlobalLongShortAccountRatioRespItem>>;

    /**
     * Open Interest Statistics
     * @summary Open Interest Statistics
     * @param {UsdsMarginedFuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFuturesDataOpenInterestHist(requestParameters: UsdsMarginedFuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataOpenInterestHistRespItem>>;

    /**
     * Taker Buy/Sell Volume
     * @summary Taker Buy/Sell Volume
     * @param {UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFuturesDataTakerlongshortRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTakerlongshortRatioRespItem>>;

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFuturesDataTopLongShortAccountRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortAccountRatioRespItem>>;

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getFuturesDataTopLongShortPositionRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFuturesDataTopLongShortPositionRatioRespItem>>;

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {UsdsMarginedFuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getHistoricalTradesV1(requestParameters: UsdsMarginedFuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetHistoricalTradesV1RespItem>>;

    /**
     * Get futures transaction history download link by Id
     * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getIncomeAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynIdV1Resp>;

    /**
     * Get download id for futures transaction history
     * @summary Get Download Id For Futures Transaction History(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getIncomeAsynV1(requestParameters: UsdsMarginedFuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeAsynV1Resp>;

    /**
     * Query composite index symbol information
     * @summary Composite Index Symbol Information
     * @param {UsdsMarginedFuturesApiGetIndexInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getIndexInfoV1(requestParameters?: UsdsMarginedFuturesApiGetIndexInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIndexInfoV1RespItem>>;

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {UsdsMarginedFuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getIndexPriceKlinesV1(requestParameters: UsdsMarginedFuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {UsdsMarginedFuturesApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getKlinesV1(requestParameters: UsdsMarginedFuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Query user notional and leverage bracket on speicfic symbol
     * @summary Notional and Leverage Brackets (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getLeverageBracketV1(requestParameters: UsdsMarginedFuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetLeverageBracketV1Resp>;

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {UsdsMarginedFuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getMarkPriceKlinesV1(requestParameters: UsdsMarginedFuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Get Current Multi-Assets Mode (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getMultiAssetsMarginV1(requestParameters: UsdsMarginedFuturesApiGetMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetMultiAssetsMarginV1Resp>;

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {UsdsMarginedFuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getOpenInterestV1(requestParameters: UsdsMarginedFuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenInterestV1Resp>;

    /**
     * Query open order
     * @summary Query Current Open Order (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getOpenOrderV1(requestParameters: UsdsMarginedFuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOpenOrderV1Resp>;

    /**
     * Get all open orders on a symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getOpenOrdersV1(requestParameters: UsdsMarginedFuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOpenOrdersV1RespItem>>;

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getOrderAmendmentV1(requestParameters: UsdsMarginedFuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOrderAmendmentV1RespItem>>;

    /**
     * Get futures order history download link by Id
     * @summary Get Futures Order History Download Link by Id (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getOrderAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderAsynIdV1Resp>;

    /**
     * Get Download Id For Futures Order History
     * @summary Get Download Id For Futures Order History (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getOrderAsynV1(requestParameters: UsdsMarginedFuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetOrderAsynV1Resp>;

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getOrderV1(requestParameters: UsdsMarginedFuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderV1Resp>;

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getPingV1(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Get Classic Portfolio Margin current account information.
     * @summary Classic Portfolio Margin Account Information (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getPmAccountInfoV1(requestParameters: UsdsMarginedFuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPmAccountInfoV1Resp>;

    /**
     * Get Position Margin Change History
     * @summary Get Position Margin Change History (TRADE)
     * @param {UsdsMarginedFuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getPositionMarginHistoryV1(requestParameters: UsdsMarginedFuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionMarginHistoryV1RespItem>>;

    /**
     * Get current position information.
     * @summary Position Information V2 (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetPositionRiskV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getPositionRiskV2(requestParameters: UsdsMarginedFuturesApiGetPositionRiskV2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV2RespItem>>;

    /**
     * Get current position information(only symbol that has position or open orders will be returned).
     * @summary Position Information V3 (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetPositionRiskV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getPositionRiskV3(requestParameters: UsdsMarginedFuturesApiGetPositionRiskV3Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPositionRiskV3RespItem>>;

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Get Current Position Mode(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getPositionSideDualV1(requestParameters: UsdsMarginedFuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetPositionSideDualV1Resp>;

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {UsdsMarginedFuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getPremiumIndexKlinesV1(requestParameters: UsdsMarginedFuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<UmfuturesGetContinuousKlinesV1RespInnerInner>>>;

    /**
     * Mark Price and Funding Rate
     * @summary Mark Price
     * @param {UsdsMarginedFuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getPremiumIndexV1(requestParameters?: UsdsMarginedFuturesApiGetPremiumIndexV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetPremiumIndexV1Resp>;

    /**
     * Query User Rate Limit
     * @summary Query User Rate Limit (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getRateLimitOrderV1(requestParameters: UsdsMarginedFuturesApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRateLimitOrderV1RespItem>>;

    /**
     * Get current account symbol configuration.
     * @summary Symbol Configuration(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetSymbolConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getSymbolConfigV1(requestParameters: UsdsMarginedFuturesApiGetSymbolConfigV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetSymbolConfigV1RespItem>>;

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
     * @summary 24hr Ticker Price Change Statistics
     * @param {UsdsMarginedFuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getTicker24hrV1(requestParameters?: UsdsMarginedFuturesApiGetTicker24hrV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTicker24hrV1Resp>;

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {UsdsMarginedFuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getTickerBookTickerV1(requestParameters?: UsdsMarginedFuturesApiGetTickerBookTickerV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerBookTickerV1Resp>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {UsdsMarginedFuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getTickerPriceV1(requestParameters?: UsdsMarginedFuturesApiGetTickerPriceV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV1Resp>;

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker V2
     * @param {UsdsMarginedFuturesApiGetTickerPriceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getTickerPriceV2(requestParameters?: UsdsMarginedFuturesApiGetTickerPriceV2Request, options?: RawAxiosRequestConfig): AxiosPromise<UmfuturesGetTickerPriceV2Resp>;

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getTimeV1(options?: RawAxiosRequestConfig): AxiosPromise<GetTimeV1Resp>;

    /**
     * Get futures trade download link by Id
     * @summary Get Futures Trade Download Link by Id(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getTradeAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynIdV1Resp>;

    /**
     * Get download id for futures trade history
     * @summary Get Download Id For Futures Trade History (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getTradeAsynV1(requestParameters: UsdsMarginedFuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTradeAsynV1Resp>;

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {UsdsMarginedFuturesApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getTradesV1(requestParameters: UsdsMarginedFuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTradesV1RespItem>>;

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    getUserTradesV1(requestParameters: UsdsMarginedFuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserTradesV1RespItem>>;

    /**
     * Modify Multiple Orders (TRADE)
     * @summary Modify Multiple Orders(TRADE)
     * @param {UsdsMarginedFuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    updateBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<UmfuturesUpdateBatchOrdersV1RespItem>>;

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    updateListenKeyV1(options?: RawAxiosRequestConfig): AxiosPromise<UpdateListenKeyV1Resp>;

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {UsdsMarginedFuturesApiUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApiInterface
     */
    updateOrderV1(requestParameters: UsdsMarginedFuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderV1Resp>;

}

/**
 * Request parameters for createBatchOrdersV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateBatchOrdersV1Request
 */
export interface UsdsMarginedFuturesApiCreateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>}
     * @memberof UsdsMarginedFuturesApiCreateBatchOrdersV1
     */
    readonly batchOrders: Array<UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createConvertAcceptQuoteV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1Request
 */
export interface UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1
     */
    readonly quoteId: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createConvertGetQuoteV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateConvertGetQuoteV1Request
 */
export interface UsdsMarginedFuturesApiCreateConvertGetQuoteV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateConvertGetQuoteV1
     */
    readonly fromAsset: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateConvertGetQuoteV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateConvertGetQuoteV1
     */
    readonly toAsset: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateConvertGetQuoteV1
     */
    readonly fromAmount?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateConvertGetQuoteV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateConvertGetQuoteV1
     */
    readonly toAmount?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateConvertGetQuoteV1
     */
    readonly validTime?: string
}

/**
 * Request parameters for createCountdownCancelAllV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateCountdownCancelAllV1Request
 */
export interface UsdsMarginedFuturesApiCreateCountdownCancelAllV1Request {
    /**
     * 
     * @type {UmfuturesCreateCountdownCancelAllV1Req}
     * @memberof UsdsMarginedFuturesApiCreateCountdownCancelAllV1
     */
    readonly umfuturesCreateCountdownCancelAllV1Req?: UmfuturesCreateCountdownCancelAllV1Req
}

/**
 * Request parameters for createFeeBurnV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateFeeBurnV1Request
 */
export interface UsdsMarginedFuturesApiCreateFeeBurnV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateFeeBurnV1
     */
    readonly feeBurn: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateFeeBurnV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateFeeBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createLeverageV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateLeverageV1Request
 */
export interface UsdsMarginedFuturesApiCreateLeverageV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateLeverageV1
     */
    readonly leverage: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateLeverageV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateLeverageV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateLeverageV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMarginTypeV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateMarginTypeV1Request
 */
export interface UsdsMarginedFuturesApiCreateMarginTypeV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateMarginTypeV1
     */
    readonly marginType: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateMarginTypeV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateMarginTypeV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateMarginTypeV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createMultiAssetsMarginV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateMultiAssetsMarginV1Request
 */
export interface UsdsMarginedFuturesApiCreateMultiAssetsMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateMultiAssetsMarginV1
     */
    readonly multiAssetsMargin: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateMultiAssetsMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateMultiAssetsMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createOrderTestV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateOrderTestV1Request
 */
export interface UsdsMarginedFuturesApiCreateOrderTestV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderTestV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for createOrderV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreateOrderV1Request
 */
export interface UsdsMarginedFuturesApiCreateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly type: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly activationPrice?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly callbackRate?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly closePosition?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly goodTillDate?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly newClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly newOrderRespType?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly price?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly priceProtect?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly quantity?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly recvWindow?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly reduceOnly?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly selfTradePreventionMode?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly stopPrice?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly timeInForce?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreateOrderV1
     */
    readonly workingType?: string
}

/**
 * Request parameters for createPositionMarginV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreatePositionMarginV1Request
 */
export interface UsdsMarginedFuturesApiCreatePositionMarginV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreatePositionMarginV1
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreatePositionMarginV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreatePositionMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreatePositionMarginV1
     */
    readonly type: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreatePositionMarginV1
     */
    readonly positionSide?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreatePositionMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for createPositionSideDualV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiCreatePositionSideDualV1Request
 */
export interface UsdsMarginedFuturesApiCreatePositionSideDualV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiCreatePositionSideDualV1
     */
    readonly dualSidePosition: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreatePositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiCreatePositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteAllOpenOrdersV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiDeleteAllOpenOrdersV1Request
 */
export interface UsdsMarginedFuturesApiDeleteAllOpenOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiDeleteAllOpenOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiDeleteAllOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiDeleteAllOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteBatchOrdersV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiDeleteBatchOrdersV1Request
 */
export interface UsdsMarginedFuturesApiDeleteBatchOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * max length 10 &lt;br/&gt; e.g. [1234567,2345678]
     * @type {Array<number>}
     * @memberof UsdsMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly orderIdList?: Array<number>

    /**
     * max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
     * @type {Array<string>}
     * @memberof UsdsMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly origClientOrderIdList?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiDeleteBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for deleteOrderV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiDeleteOrderV1Request
 */
export interface UsdsMarginedFuturesApiDeleteOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiDeleteOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiDeleteOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiDeleteOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiDeleteOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiDeleteOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountConfigV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetAccountConfigV1Request
 */
export interface UsdsMarginedFuturesApiGetAccountConfigV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAccountConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAccountConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountV2 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetAccountV2Request
 */
export interface UsdsMarginedFuturesApiGetAccountV2Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAccountV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAccountV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAccountV3 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetAccountV3Request
 */
export interface UsdsMarginedFuturesApiGetAccountV3Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAccountV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAccountV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAdlQuantileV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetAdlQuantileV1Request
 */
export interface UsdsMarginedFuturesApiGetAdlQuantileV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAdlQuantileV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetAdlQuantileV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAdlQuantileV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAggTradesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetAggTradesV1Request
 */
export interface UsdsMarginedFuturesApiGetAggTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetAggTradesV1
     */
    readonly symbol: string

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAggTradesV1
     */
    readonly fromId?: number

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAggTradesV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAggTradesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAggTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getAllOrdersV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetAllOrdersV1Request
 */
export interface UsdsMarginedFuturesApiGetAllOrdersV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetAllOrdersV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAllOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAllOrdersV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAllOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAllOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAllOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetAllOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getApiTradingStatusV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetApiTradingStatusV1Request
 */
export interface UsdsMarginedFuturesApiGetApiTradingStatusV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetApiTradingStatusV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetApiTradingStatusV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetApiTradingStatusV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getAssetIndexV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetAssetIndexV1Request
 */
export interface UsdsMarginedFuturesApiGetAssetIndexV1Request {
    /**
     * Asset pair
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetAssetIndexV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getBalanceV2 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetBalanceV2Request
 */
export interface UsdsMarginedFuturesApiGetBalanceV2Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetBalanceV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetBalanceV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getBalanceV3 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetBalanceV3Request
 */
export interface UsdsMarginedFuturesApiGetBalanceV3Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetBalanceV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetBalanceV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getCommissionRateV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetCommissionRateV1Request
 */
export interface UsdsMarginedFuturesApiGetCommissionRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetCommissionRateV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetCommissionRateV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetCommissionRateV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getConstituentsV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetConstituentsV1Request
 */
export interface UsdsMarginedFuturesApiGetConstituentsV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetConstituentsV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getContinuousKlinesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetContinuousKlinesV1Request
 */
export interface UsdsMarginedFuturesApiGetContinuousKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly contractType: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetContinuousKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getConvertExchangeInfoV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetConvertExchangeInfoV1Request
 */
export interface UsdsMarginedFuturesApiGetConvertExchangeInfoV1Request {
    /**
     * User spends coin
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetConvertExchangeInfoV1
     */
    readonly fromAsset?: string

    /**
     * User receives coin
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetConvertExchangeInfoV1
     */
    readonly toAsset?: string
}

/**
 * Request parameters for getConvertOrderStatusV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetConvertOrderStatusV1Request
 */
export interface UsdsMarginedFuturesApiGetConvertOrderStatusV1Request {
    /**
     * Either orderId or quoteId is required
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetConvertOrderStatusV1
     */
    readonly orderId?: string

    /**
     * Either orderId or quoteId is required
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetConvertOrderStatusV1
     */
    readonly quoteId?: string
}

/**
 * Request parameters for getDepthV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetDepthV1Request
 */
export interface UsdsMarginedFuturesApiGetDepthV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetDepthV1
     */
    readonly symbol: string

    /**
     * Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetDepthV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getFeeBurnV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFeeBurnV1Request
 */
export interface UsdsMarginedFuturesApiGetFeeBurnV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFeeBurnV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFeeBurnV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getForceOrdersV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetForceOrdersV1Request
 */
export interface UsdsMarginedFuturesApiGetForceOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetForceOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetForceOrdersV1
     */
    readonly symbol?: string

    /**
     * &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetForceOrdersV1
     */
    readonly autoCloseType?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetForceOrdersV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetForceOrdersV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetForceOrdersV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetForceOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getFundingRateV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFundingRateV1Request
 */
export interface UsdsMarginedFuturesApiGetFundingRateV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFundingRateV1
     */
    readonly symbol?: string

    /**
     * Timestamp in ms to get funding rate from INCLUSIVE.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFundingRateV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get funding rate  until INCLUSIVE.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFundingRateV1
     */
    readonly endTime?: number

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFundingRateV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getFuturesDataBasis operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFuturesDataBasisRequest
 */
export interface UsdsMarginedFuturesApiGetFuturesDataBasisRequest {
    /**
     * BTCUSDT
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataBasis
     */
    readonly pair: string

    /**
     * CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataBasis
     */
    readonly contractType: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataBasis
     */
    readonly period: string

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataBasis
     */
    readonly limit: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataBasis
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataBasis
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataDeliveryPrice operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFuturesDataDeliveryPriceRequest
 */
export interface UsdsMarginedFuturesApiGetFuturesDataDeliveryPriceRequest {
    /**
     * e.g BTCUSDT
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataDeliveryPrice
     */
    readonly pair: string
}

/**
 * Request parameters for getFuturesDataGlobalLongShortAccountRatio operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest
 */
export interface UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataOpenInterestHist operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFuturesDataOpenInterestHistRequest
 */
export interface UsdsMarginedFuturesApiGetFuturesDataOpenInterestHistRequest {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataOpenInterestHist
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTakerlongshortRatio operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatioRequest
 */
export interface UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTopLongShortAccountRatio operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest
 */
export interface UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getFuturesDataTopLongShortPositionRatio operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest
 */
export interface UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly symbol: string

    /**
     * &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly period: string

    /**
     * default 30, max 500
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatio
     */
    readonly endTime?: number
}

/**
 * Request parameters for getHistoricalTradesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetHistoricalTradesV1Request
 */
export interface UsdsMarginedFuturesApiGetHistoricalTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetHistoricalTradesV1
     */
    readonly symbol: string

    /**
     * Default 100; max 500.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetHistoricalTradesV1
     */
    readonly limit?: number

    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetHistoricalTradesV1
     */
    readonly fromId?: number
}

/**
 * Request parameters for getIncomeAsynIdV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetIncomeAsynIdV1Request
 */
export interface UsdsMarginedFuturesApiGetIncomeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetIncomeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIncomeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIncomeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIncomeAsynV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetIncomeAsynV1Request
 */
export interface UsdsMarginedFuturesApiGetIncomeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIncomeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIncomeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIncomeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIncomeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getIndexInfoV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetIndexInfoV1Request
 */
export interface UsdsMarginedFuturesApiGetIndexInfoV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetIndexInfoV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getIndexPriceKlinesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetIndexPriceKlinesV1Request
 */
export interface UsdsMarginedFuturesApiGetIndexPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly pair: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetIndexPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getKlinesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetKlinesV1Request
 */
export interface UsdsMarginedFuturesApiGetKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getLeverageBracketV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetLeverageBracketV1Request
 */
export interface UsdsMarginedFuturesApiGetLeverageBracketV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetLeverageBracketV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetLeverageBracketV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetLeverageBracketV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getMarkPriceKlinesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetMarkPriceKlinesV1Request
 */
export interface UsdsMarginedFuturesApiGetMarkPriceKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetMarkPriceKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getMultiAssetsMarginV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetMultiAssetsMarginV1Request
 */
export interface UsdsMarginedFuturesApiGetMultiAssetsMarginV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetMultiAssetsMarginV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetMultiAssetsMarginV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenInterestV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetOpenInterestV1Request
 */
export interface UsdsMarginedFuturesApiGetOpenInterestV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOpenInterestV1
     */
    readonly symbol: string
}

/**
 * Request parameters for getOpenOrderV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetOpenOrderV1Request
 */
export interface UsdsMarginedFuturesApiGetOpenOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOpenOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOpenOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOpenOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOpenOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOpenOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOpenOrdersV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetOpenOrdersV1Request
 */
export interface UsdsMarginedFuturesApiGetOpenOrdersV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOpenOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOpenOrdersV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOpenOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAmendmentV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetOrderAmendmentV1Request
 */
export interface UsdsMarginedFuturesApiGetOrderAmendmentV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly origClientOrderId?: string

    /**
     * Timestamp in ms to get modification history from INCLUSIVE
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly startTime?: number

    /**
     * Timestamp in ms to get modification history until INCLUSIVE
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly endTime?: number

    /**
     * Default 50; max 100
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAmendmentV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAsynIdV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetOrderAsynIdV1Request
 */
export interface UsdsMarginedFuturesApiGetOrderAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOrderAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderAsynV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetOrderAsynV1Request
 */
export interface UsdsMarginedFuturesApiGetOrderAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getOrderV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetOrderV1Request
 */
export interface UsdsMarginedFuturesApiGetOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPmAccountInfoV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetPmAccountInfoV1Request
 */
export interface UsdsMarginedFuturesApiGetPmAccountInfoV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetPmAccountInfoV1
     */
    readonly asset: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPmAccountInfoV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPmAccountInfoV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionMarginHistoryV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetPositionMarginHistoryV1Request
 */
export interface UsdsMarginedFuturesApiGetPositionMarginHistoryV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly timestamp: number

    /**
     * 1: Add position margin2: Reduce position margin
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly type?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly startTime?: number

    /**
     * Default current time if not pass
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly endTime?: number

    /**
     * Default: 500
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionMarginHistoryV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionRiskV2 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetPositionRiskV2Request
 */
export interface UsdsMarginedFuturesApiGetPositionRiskV2Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionRiskV2
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetPositionRiskV2
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionRiskV2
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionRiskV3 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetPositionRiskV3Request
 */
export interface UsdsMarginedFuturesApiGetPositionRiskV3Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionRiskV3
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetPositionRiskV3
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionRiskV3
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPositionSideDualV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetPositionSideDualV1Request
 */
export interface UsdsMarginedFuturesApiGetPositionSideDualV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionSideDualV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPositionSideDualV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getPremiumIndexKlinesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetPremiumIndexKlinesV1Request
 */
export interface UsdsMarginedFuturesApiGetPremiumIndexKlinesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly interval: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly endTime?: number

    /**
     * Default 500; max 1500.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetPremiumIndexKlinesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getPremiumIndexV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetPremiumIndexV1Request
 */
export interface UsdsMarginedFuturesApiGetPremiumIndexV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetPremiumIndexV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getRateLimitOrderV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetRateLimitOrderV1Request
 */
export interface UsdsMarginedFuturesApiGetRateLimitOrderV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetRateLimitOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetRateLimitOrderV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getSymbolConfigV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetSymbolConfigV1Request
 */
export interface UsdsMarginedFuturesApiGetSymbolConfigV1Request {
    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetSymbolConfigV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetSymbolConfigV1
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetSymbolConfigV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTicker24hrV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetTicker24hrV1Request
 */
export interface UsdsMarginedFuturesApiGetTicker24hrV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetTicker24hrV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTickerBookTickerV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetTickerBookTickerV1Request
 */
export interface UsdsMarginedFuturesApiGetTickerBookTickerV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetTickerBookTickerV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTickerPriceV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetTickerPriceV1Request
 */
export interface UsdsMarginedFuturesApiGetTickerPriceV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetTickerPriceV1
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTickerPriceV2 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetTickerPriceV2Request
 */
export interface UsdsMarginedFuturesApiGetTickerPriceV2Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetTickerPriceV2
     */
    readonly symbol?: string
}

/**
 * Request parameters for getTradeAsynIdV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetTradeAsynIdV1Request
 */
export interface UsdsMarginedFuturesApiGetTradeAsynIdV1Request {
    /**
     * get by download id api
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetTradeAsynIdV1
     */
    readonly downloadId: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetTradeAsynIdV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetTradeAsynIdV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTradeAsynV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetTradeAsynV1Request
 */
export interface UsdsMarginedFuturesApiGetTradeAsynV1Request {
    /**
     * Timestamp in ms
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetTradeAsynV1
     */
    readonly startTime: number

    /**
     * Timestamp in ms
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetTradeAsynV1
     */
    readonly endTime: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetTradeAsynV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetTradeAsynV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for getTradesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetTradesV1Request
 */
export interface UsdsMarginedFuturesApiGetTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetTradesV1
     */
    readonly symbol: string

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetTradesV1
     */
    readonly limit?: number
}

/**
 * Request parameters for getUserTradesV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiGetUserTradesV1Request
 */
export interface UsdsMarginedFuturesApiGetUserTradesV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiGetUserTradesV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetUserTradesV1
     */
    readonly timestamp: number

    /**
     * This can only be used in combination with &#x60;symbol&#x60;
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetUserTradesV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetUserTradesV1
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetUserTradesV1
     */
    readonly endTime?: number

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetUserTradesV1
     */
    readonly fromId?: number

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetUserTradesV1
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiGetUserTradesV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateBatchOrdersV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiUpdateBatchOrdersV1Request
 */
export interface UsdsMarginedFuturesApiUpdateBatchOrdersV1Request {
    /**
     * 
     * @type {Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>}
     * @memberof UsdsMarginedFuturesApiUpdateBatchOrdersV1
     */
    readonly batchOrders: Array<UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiUpdateBatchOrdersV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiUpdateBatchOrdersV1
     */
    readonly recvWindow?: number
}

/**
 * Request parameters for updateOrderV1 operation in UsdsMarginedFuturesApi.
 * @export
 * @interface UsdsMarginedFuturesApiUpdateOrderV1Request
 */
export interface UsdsMarginedFuturesApiUpdateOrderV1Request {
    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly price: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly quantity: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly side: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly timestamp: number

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly orderId?: number

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly origClientOrderId?: string

    /**
     * 
     * @type {string}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly priceMatch?: string

    /**
     * 
     * @type {number}
     * @memberof UsdsMarginedFuturesApiUpdateOrderV1
     */
    readonly recvWindow?: number
}

/**
 * UsdsMarginedFuturesApi - object-oriented interface
 * @export
 * @class UsdsMarginedFuturesApi
 * @extends {BaseAPI}
 */
export class UsdsMarginedFuturesApi extends BaseAPI implements UsdsMarginedFuturesApiInterface {
    /**
     * Place Multiple Orders
     * @summary Place Multiple Orders(TRADE)
     * @param {UsdsMarginedFuturesApiCreateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiCreateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept the offered quote by quote ID.
     * @summary Accept the offered quote (USER_DATA)
     * @param {UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createConvertAcceptQuoteV1(requestParameters: UsdsMarginedFuturesApiCreateConvertAcceptQuoteV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createConvertAcceptQuoteV1(requestParameters.quoteId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a quote for the requested token pairs
     * @summary Send Quote Request(USER_DATA)
     * @param {UsdsMarginedFuturesApiCreateConvertGetQuoteV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createConvertGetQuoteV1(requestParameters: UsdsMarginedFuturesApiCreateConvertGetQuoteV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createConvertGetQuoteV1(requestParameters.fromAsset, requestParameters.timestamp, requestParameters.toAsset, requestParameters.fromAmount, requestParameters.recvWindow, requestParameters.toAmount, requestParameters.validTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {UsdsMarginedFuturesApiCreateCountdownCancelAllV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createCountdownCancelAllV1(requestParameters: UsdsMarginedFuturesApiCreateCountdownCancelAllV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createCountdownCancelAllV1(requestParameters.umfuturesCreateCountdownCancelAllV1Req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol
     * @summary Toggle BNB Burn On Futures Trade (TRADE)
     * @param {UsdsMarginedFuturesApiCreateFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createFeeBurnV1(requestParameters: UsdsMarginedFuturesApiCreateFeeBurnV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createFeeBurnV1(requestParameters.feeBurn, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s initial leverage of specific symbol market.
     * @summary Change Initial Leverage(TRADE)
     * @param {UsdsMarginedFuturesApiCreateLeverageV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createLeverageV1(requestParameters: UsdsMarginedFuturesApiCreateLeverageV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createLeverageV1(requestParameters.leverage, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
     * @summary Start User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createListenKeyV1(options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change symbol level margin type
     * @summary Change Margin Type(TRADE)
     * @param {UsdsMarginedFuturesApiCreateMarginTypeV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createMarginTypeV1(requestParameters: UsdsMarginedFuturesApiCreateMarginTypeV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createMarginTypeV1(requestParameters.marginType, requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Change Multi-Assets Mode (TRADE)
     * @param {UsdsMarginedFuturesApiCreateMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createMultiAssetsMarginV1(requestParameters: UsdsMarginedFuturesApiCreateMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createMultiAssetsMarginV1(requestParameters.multiAssetsMargin, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Testing order request, this order will not be submitted to matching engine
     * @summary Test Order(TRADE)
     * @param {UsdsMarginedFuturesApiCreateOrderTestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createOrderTestV1(requestParameters: UsdsMarginedFuturesApiCreateOrderTestV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createOrderTestV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send in a new order.
     * @summary New Order(TRADE)
     * @param {UsdsMarginedFuturesApiCreateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createOrderV1(requestParameters: UsdsMarginedFuturesApiCreateOrderV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createOrderV1(requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.activationPrice, requestParameters.callbackRate, requestParameters.closePosition, requestParameters.goodTillDate, requestParameters.newClientOrderId, requestParameters.newOrderRespType, requestParameters.positionSide, requestParameters.price, requestParameters.priceMatch, requestParameters.priceProtect, requestParameters.quantity, requestParameters.recvWindow, requestParameters.reduceOnly, requestParameters.selfTradePreventionMode, requestParameters.stopPrice, requestParameters.timeInForce, requestParameters.workingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Isolated Position Margin
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {UsdsMarginedFuturesApiCreatePositionMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createPositionMarginV1(requestParameters: UsdsMarginedFuturesApiCreatePositionMarginV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createPositionMarginV1(requestParameters.amount, requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.positionSide, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Change Position Mode(TRADE)
     * @param {UsdsMarginedFuturesApiCreatePositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public createPositionSideDualV1(requestParameters: UsdsMarginedFuturesApiCreatePositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).createPositionSideDualV1(requestParameters.dualSidePosition, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel All Open Orders
     * @summary Cancel All Open Orders (TRADE)
     * @param {UsdsMarginedFuturesApiDeleteAllOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public deleteAllOpenOrdersV1(requestParameters: UsdsMarginedFuturesApiDeleteAllOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).deleteAllOpenOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Multiple Orders
     * @summary Cancel Multiple Orders (TRADE)
     * @param {UsdsMarginedFuturesApiDeleteBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public deleteBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiDeleteBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).deleteBatchOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderIdList, requestParameters.origClientOrderIdList, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close out a user data stream.
     * @summary Close User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public deleteListenKeyV1(options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).deleteListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an active order.
     * @summary Cancel Order (TRADE)
     * @param {UsdsMarginedFuturesApiDeleteOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public deleteOrderV1(requestParameters: UsdsMarginedFuturesApiDeleteOrderV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).deleteOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account configuration
     * @summary Futures Account Configuration(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAccountConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getAccountConfigV1(requestParameters: UsdsMarginedFuturesApiGetAccountConfigV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getAccountConfigV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
     * @summary Account Information V2(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getAccountV2(requestParameters: UsdsMarginedFuturesApiGetAccountV2Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getAccountV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account information. User in single-asset/ multi-assets mode will see different value, see comments in response section for detail.
     * @summary Account Information V3(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAccountV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getAccountV3(requestParameters: UsdsMarginedFuturesApiGetAccountV3Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getAccountV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Position ADL Quantile Estimation
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAdlQuantileV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getAdlQuantileV1(requestParameters: UsdsMarginedFuturesApiGetAdlQuantileV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getAdlQuantileV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * @summary Compressed/Aggregate Trades List
     * @param {UsdsMarginedFuturesApiGetAggTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getAggTradesV1(requestParameters: UsdsMarginedFuturesApiGetAggTradesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getAggTradesV1(requestParameters.symbol, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * @summary All Orders (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetAllOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getAllOrdersV1(requestParameters: UsdsMarginedFuturesApiGetAllOrdersV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getAllOrdersV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules
     * @summary Futures Trading Quantitative Rules Indicators (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetApiTradingStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getApiTradingStatusV1(requestParameters: UsdsMarginedFuturesApiGetApiTradingStatusV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getApiTradingStatusV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * asset index for Multi-Assets mode
     * @summary Multi-Assets Mode Asset Index
     * @param {UsdsMarginedFuturesApiGetAssetIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getAssetIndexV1(requestParameters: UsdsMarginedFuturesApiGetAssetIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getAssetIndexV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account balance info
     * @summary Futures Account Balance V2 (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetBalanceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getBalanceV2(requestParameters: UsdsMarginedFuturesApiGetBalanceV2Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getBalanceV2(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query account balance info
     * @summary Futures Account Balance V3 (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetBalanceV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getBalanceV3(requestParameters: UsdsMarginedFuturesApiGetBalanceV3Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getBalanceV3(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get User Commission Rate
     * @summary User Commission Rate (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetCommissionRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getCommissionRateV1(requestParameters: UsdsMarginedFuturesApiGetCommissionRateV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getCommissionRateV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query index price constituents
     * @summary Query Index Price Constituents
     * @param {UsdsMarginedFuturesApiGetConstituentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getConstituentsV1(requestParameters: UsdsMarginedFuturesApiGetConstituentsV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getConstituentsV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a specific contract type. Klines are uniquely identified by their open time.
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {UsdsMarginedFuturesApiGetContinuousKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getContinuousKlinesV1(requestParameters: UsdsMarginedFuturesApiGetContinuousKlinesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getContinuousKlinesV1(requestParameters.pair, requestParameters.contractType, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for all convertible token pairs and the tokens respective upper/lower limits
     * @summary List All Convert Pairs
     * @param {UsdsMarginedFuturesApiGetConvertExchangeInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getConvertExchangeInfoV1(requestParameters: UsdsMarginedFuturesApiGetConvertExchangeInfoV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getConvertExchangeInfoV1(requestParameters.fromAsset, requestParameters.toAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query order status by order ID.
     * @summary Order status(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetConvertOrderStatusV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getConvertOrderStatusV1(requestParameters: UsdsMarginedFuturesApiGetConvertOrderStatusV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getConvertOrderStatusV1(requestParameters.orderId, requestParameters.quoteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol orderbook
     * @summary Order Book
     * @param {UsdsMarginedFuturesApiGetDepthV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getDepthV1(requestParameters: UsdsMarginedFuturesApiGetDepthV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getDepthV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information
     * @summary Exchange Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getExchangeInfoV1(options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getExchangeInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s BNB Fee Discount (Fee Discount On or Fee Discount Off )
     * @summary Get BNB Burn Status (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetFeeBurnV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFeeBurnV1(requestParameters: UsdsMarginedFuturesApiGetFeeBurnV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFeeBurnV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user\'s Force Orders
     * @summary User\'s Force Orders (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetForceOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getForceOrdersV1(requestParameters: UsdsMarginedFuturesApiGetForceOrdersV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getForceOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.autoCloseType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     * @summary Get Funding Rate Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFundingInfoV1(options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFundingInfoV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Funding Rate History
     * @summary Get Funding Rate History
     * @param {UsdsMarginedFuturesApiGetFundingRateV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFundingRateV1(requestParameters: UsdsMarginedFuturesApiGetFundingRateV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFundingRateV1(requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query future basis
     * @summary Basis
     * @param {UsdsMarginedFuturesApiGetFuturesDataBasisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFuturesDataBasis(requestParameters: UsdsMarginedFuturesApiGetFuturesDataBasisRequest, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFuturesDataBasis(requestParameters.pair, requestParameters.contractType, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Quarterly Contract Settlement Price
     * @param {UsdsMarginedFuturesApiGetFuturesDataDeliveryPriceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFuturesDataDeliveryPrice(requestParameters: UsdsMarginedFuturesApiGetFuturesDataDeliveryPriceRequest, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFuturesDataDeliveryPrice(requestParameters.pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query symbol Long/Short Ratio
     * @summary Long/Short Ratio
     * @param {UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFuturesDataGlobalLongShortAccountRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataGlobalLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFuturesDataGlobalLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Open Interest Statistics
     * @summary Open Interest Statistics
     * @param {UsdsMarginedFuturesApiGetFuturesDataOpenInterestHistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFuturesDataOpenInterestHist(requestParameters: UsdsMarginedFuturesApiGetFuturesDataOpenInterestHistRequest, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFuturesDataOpenInterestHist(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Taker Buy/Sell Volume
     * @summary Taker Buy/Sell Volume
     * @param {UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFuturesDataTakerlongshortRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTakerlongshortRatioRequest, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFuturesDataTakerlongshortRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only. Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions Long/Short Ratio (Accounts) = Long Account % / Short Account %
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFuturesDataTopLongShortAccountRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTopLongShortAccountRatioRequest, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFuturesDataTopLongShortAccountRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance. Long Position % = Long positions of top traders / Total open positions of top traders Short Position % = Short positions of top traders / Total open positions of top traders Long/Short Ratio (Positions) = Long Position % / Short Position %
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getFuturesDataTopLongShortPositionRatio(requestParameters: UsdsMarginedFuturesApiGetFuturesDataTopLongShortPositionRatioRequest, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getFuturesDataTopLongShortPositionRatio(requestParameters.symbol, requestParameters.period, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older market historical trades.
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {UsdsMarginedFuturesApiGetHistoricalTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getHistoricalTradesV1(requestParameters: UsdsMarginedFuturesApiGetHistoricalTradesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getHistoricalTradesV1(requestParameters.symbol, requestParameters.limit, requestParameters.fromId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures transaction history download link by Id
     * @summary Get Futures Transaction History Download Link by Id (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetIncomeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getIncomeAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetIncomeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getIncomeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for futures transaction history
     * @summary Get Download Id For Futures Transaction History(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetIncomeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getIncomeAsynV1(requestParameters: UsdsMarginedFuturesApiGetIncomeAsynV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getIncomeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query composite index symbol information
     * @summary Composite Index Symbol Information
     * @param {UsdsMarginedFuturesApiGetIndexInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getIndexInfoV1(requestParameters: UsdsMarginedFuturesApiGetIndexInfoV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getIndexInfoV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     * @summary Index Price Kline/Candlestick Data
     * @param {UsdsMarginedFuturesApiGetIndexPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getIndexPriceKlinesV1(requestParameters: UsdsMarginedFuturesApiGetIndexPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getIndexPriceKlinesV1(requestParameters.pair, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * @summary Kline/Candlestick Data
     * @param {UsdsMarginedFuturesApiGetKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getKlinesV1(requestParameters: UsdsMarginedFuturesApiGetKlinesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query user notional and leverage bracket on speicfic symbol
     * @summary Notional and Leverage Brackets (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetLeverageBracketV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getLeverageBracketV1(requestParameters: UsdsMarginedFuturesApiGetLeverageBracketV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getLeverageBracketV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.
     * @summary Mark Price Kline/Candlestick Data
     * @param {UsdsMarginedFuturesApiGetMarkPriceKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getMarkPriceKlinesV1(requestParameters: UsdsMarginedFuturesApiGetMarkPriceKlinesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getMarkPriceKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
     * @summary Get Current Multi-Assets Mode (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetMultiAssetsMarginV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getMultiAssetsMarginV1(requestParameters: UsdsMarginedFuturesApiGetMultiAssetsMarginV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getMultiAssetsMarginV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get present open interest of a specific symbol.
     * @summary Open Interest
     * @param {UsdsMarginedFuturesApiGetOpenInterestV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getOpenInterestV1(requestParameters: UsdsMarginedFuturesApiGetOpenInterestV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getOpenInterestV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query open order
     * @summary Query Current Open Order (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOpenOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getOpenOrderV1(requestParameters: UsdsMarginedFuturesApiGetOpenOrderV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getOpenOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all open orders on a symbol.
     * @summary Current All Open Orders (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOpenOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getOpenOrdersV1(requestParameters: UsdsMarginedFuturesApiGetOpenOrdersV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getOpenOrdersV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order modification history
     * @summary Get Order Modify History (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOrderAmendmentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getOrderAmendmentV1(requestParameters: UsdsMarginedFuturesApiGetOrderAmendmentV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getOrderAmendmentV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures order history download link by Id
     * @summary Get Futures Order History Download Link by Id (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOrderAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getOrderAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetOrderAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getOrderAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Download Id For Futures Order History
     * @summary Get Download Id For Futures Order History (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOrderAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getOrderAsynV1(requestParameters: UsdsMarginedFuturesApiGetOrderAsynV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getOrderAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check an order\'s status.
     * @summary Query Order (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getOrderV1(requestParameters: UsdsMarginedFuturesApiGetOrderV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getOrderV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getPingV1(options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getPingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Classic Portfolio Margin current account information.
     * @summary Classic Portfolio Margin Account Information (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetPmAccountInfoV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getPmAccountInfoV1(requestParameters: UsdsMarginedFuturesApiGetPmAccountInfoV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getPmAccountInfoV1(requestParameters.asset, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Position Margin Change History
     * @summary Get Position Margin Change History (TRADE)
     * @param {UsdsMarginedFuturesApiGetPositionMarginHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getPositionMarginHistoryV1(requestParameters: UsdsMarginedFuturesApiGetPositionMarginHistoryV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getPositionMarginHistoryV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.type, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current position information.
     * @summary Position Information V2 (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetPositionRiskV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getPositionRiskV2(requestParameters: UsdsMarginedFuturesApiGetPositionRiskV2Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getPositionRiskV2(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current position information(only symbol that has position or open orders will be returned).
     * @summary Position Information V3 (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetPositionRiskV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getPositionRiskV3(requestParameters: UsdsMarginedFuturesApiGetPositionRiskV3Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getPositionRiskV3(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s position mode (Hedge Mode or One-way Mode ) on EVERY symbol
     * @summary Get Current Position Mode(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetPositionSideDualV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getPositionSideDualV1(requestParameters: UsdsMarginedFuturesApiGetPositionSideDualV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getPositionSideDualV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     * @summary Premium index Kline Data
     * @param {UsdsMarginedFuturesApiGetPremiumIndexKlinesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getPremiumIndexKlinesV1(requestParameters: UsdsMarginedFuturesApiGetPremiumIndexKlinesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getPremiumIndexKlinesV1(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark Price and Funding Rate
     * @summary Mark Price
     * @param {UsdsMarginedFuturesApiGetPremiumIndexV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getPremiumIndexV1(requestParameters: UsdsMarginedFuturesApiGetPremiumIndexV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getPremiumIndexV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query User Rate Limit
     * @summary Query User Rate Limit (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetRateLimitOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getRateLimitOrderV1(requestParameters: UsdsMarginedFuturesApiGetRateLimitOrderV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getRateLimitOrderV1(requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account symbol configuration.
     * @summary Symbol Configuration(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetSymbolConfigV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getSymbolConfigV1(requestParameters: UsdsMarginedFuturesApiGetSymbolConfigV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getSymbolConfigV1(requestParameters.timestamp, requestParameters.symbol, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
     * @summary 24hr Ticker Price Change Statistics
     * @param {UsdsMarginedFuturesApiGetTicker24hrV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getTicker24hrV1(requestParameters: UsdsMarginedFuturesApiGetTicker24hrV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getTicker24hrV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * @summary Symbol Order Book Ticker
     * @param {UsdsMarginedFuturesApiGetTickerBookTickerV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getTickerBookTickerV1(requestParameters: UsdsMarginedFuturesApiGetTickerBookTickerV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getTickerBookTickerV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker
     * @param {UsdsMarginedFuturesApiGetTickerPriceV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getTickerPriceV1(requestParameters: UsdsMarginedFuturesApiGetTickerPriceV1Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getTickerPriceV1(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.
     * @summary Symbol Price Ticker V2
     * @param {UsdsMarginedFuturesApiGetTickerPriceV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getTickerPriceV2(requestParameters: UsdsMarginedFuturesApiGetTickerPriceV2Request = {}, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getTickerPriceV2(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getTimeV1(options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getTimeV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get futures trade download link by Id
     * @summary Get Futures Trade Download Link by Id(USER_DATA)
     * @param {UsdsMarginedFuturesApiGetTradeAsynIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getTradeAsynIdV1(requestParameters: UsdsMarginedFuturesApiGetTradeAsynIdV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getTradeAsynIdV1(requestParameters.downloadId, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download id for futures trade history
     * @summary Get Download Id For Futures Trade History (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetTradeAsynV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getTradeAsynV1(requestParameters: UsdsMarginedFuturesApiGetTradeAsynV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getTradeAsynV1(requestParameters.startTime, requestParameters.endTime, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent market trades
     * @summary Recent Trades List
     * @param {UsdsMarginedFuturesApiGetTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getTradesV1(requestParameters: UsdsMarginedFuturesApiGetTradesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getTradesV1(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a specific account and symbol.
     * @summary Account Trade List (USER_DATA)
     * @param {UsdsMarginedFuturesApiGetUserTradesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public getUserTradesV1(requestParameters: UsdsMarginedFuturesApiGetUserTradesV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).getUserTradesV1(requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.startTime, requestParameters.endTime, requestParameters.fromId, requestParameters.limit, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify Multiple Orders (TRADE)
     * @summary Modify Multiple Orders(TRADE)
     * @param {UsdsMarginedFuturesApiUpdateBatchOrdersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public updateBatchOrdersV1(requestParameters: UsdsMarginedFuturesApiUpdateBatchOrdersV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).updateBatchOrdersV1(requestParameters.batchOrders, requestParameters.timestamp, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It\'s recommended to send a ping about every 60 minutes.
     * @summary Keepalive User Data Stream (USER_STREAM)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public updateListenKeyV1(options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).updateListenKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     * @summary Modify Order (TRADE)
     * @param {UsdsMarginedFuturesApiUpdateOrderV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsdsMarginedFuturesApi
     */
    public updateOrderV1(requestParameters: UsdsMarginedFuturesApiUpdateOrderV1Request, options?: RawAxiosRequestConfig) {
        return UsdsMarginedFuturesApiFp(this.configuration).updateOrderV1(requestParameters.price, requestParameters.quantity, requestParameters.side, requestParameters.symbol, requestParameters.timestamp, requestParameters.orderId, requestParameters.origClientOrderId, requestParameters.priceMatch, requestParameters.recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}

